/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostBinding, Inject, InjectionToken, Injector, Input, NgZone, Optional, Output, QueryList, ViewChildren, ViewContainerRef, ViewEncapsulation } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE, UP_ARROW } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import { mixinColor } from '@angular/material';
import { merge, Subject, Subscription } from 'rxjs';
import { filter, take } from 'rxjs/operators';
import { TimeAdapter } from './time-adapter.service';
import { createMissingTimeImplError } from './time-select-errors';
import { MatTimeSelectIntl } from './time-select-intl.service';
import { MatTimeUnitSelectComponent } from './time-unit-select.component';
/**
 * Used to generate a unique ID for each time select instance.
 * @type {?}
 */
let timeSelectUid = 0;
/**
 * Injection token used to initialize the time select data.
 * @type {?}
 */
export const MAT_TIME_SELECT_DATA = new InjectionToken('mat-time-select-data');
/**
 * Injection token that determines the scroll handling while the time select is opened.
 * @type {?}
 */
export const MAT_TIME_SELECT_SCROLL_STRATEGY = new InjectionToken('mat-time-select-scroll-strategy');
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
export function MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/**
 * \@docs-private
 * @type {?}
 */
export const MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER = {
    provide: MAT_TIME_SELECT_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY
};
/**
 * @record
 * @template D
 */
export function MatTimeSelectData() { }
if (false) {
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.units;
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.value;
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.minTime;
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.maxTime;
}
/**
 * \@docs-private
 */
export class MatTimeSelectContentBase {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
if (false) {
    /** @type {?} */
    MatTimeSelectContentBase.prototype._elementRef;
}
/** @type {?} */
export const _MatTimeSelectContentMixinBase = mixinColor(MatTimeSelectContentBase);
/**
 * Component used as the content for the time select popup.
 * \@docs-private
 * @template D
 */
export class MatTimeSelectContentComponent extends _MatTimeSelectContentMixinBase {
    /**
     * @param {?} elementRef
     * @param {?} _intl
     * @param {?} _timeAdapter
     * @param {?} data
     */
    constructor(elementRef, _intl, _timeAdapter, data) {
        super(elementRef);
        this._intl = _intl;
        this._timeAdapter = _timeAdapter;
        /**
         * Emits when the time select content selected time has been changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.class = 'mat-time-select-content';
        if (!this._timeAdapter) {
            throw createMissingTimeImplError('TimeAdapter');
        }
        /** @type {?} */
        const time = this._timeAdapter.isDateInstance(data.value) && this._timeAdapter.isValid(data.value) ?
            this._timeAdapter.clone(data.value) : this._timeAdapter.now();
        /** @type {?} */
        const value = this._timeAdapter.toMoment(this._timeAdapter.clampTime(time, data.minTime, data.maxTime));
        /** @type {?} */
        const localeData = value.localeData();
        /** @type {?} */
        const displayFormat = localeData.longDateFormat('LTS');
        this.hourClock = /hh?/g.test(displayFormat) ? 12 : 24;
        this.value = value;
        this.units = data.units || ['hour', 'minute'];
        this.minTime = data.minTime ? this._timeAdapter.toMoment(data.minTime) : null;
        this.maxTime = data.maxTime ? this._timeAdapter.toMoment(data.maxTime) : null;
    }
    /**
     * The time period of the currently selected time of the time select content. Possible values: `am` when selected time hour is less
     * than 12; `pm` when selected time hour is greater than or equal to 12.
     * @return {?}
     */
    get amPm() { return this.value ? (this.value.hour() < 12 ? 'am' : 'pm') : null; }
    /**
     * @param {?} value
     * @return {?}
     */
    set amPm(value) {
        if (this.timeUnitSelectComponents) {
            this.timeUnitSelectComponents.toArray()
                .filter(timeSelect => timeSelect.unit === 'hour')
                .forEach(timeSelect => timeSelect.move(value === 'am' ? -12 : 12));
        }
    }
    /**
     * Gets the value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The retrieved value.
     */
    get(unit) {
        return this.value.get(unit);
    }
    /**
     * Sets the value of the given unit of time.
     * @param {?} unit The unit of time to update.
     * @param {?} value The value to set.
     * @return {?}
     */
    set(unit, value) {
        this.value.set(unit, value);
        this.valueChange.emit(this.value);
    }
    /**
     * Gets the minimum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The minimum value.
     */
    getMin(unit) {
        /** @type {?} */
        let min = null;
        if (this.minTime && this.value.isSame(this.minTime, 'day')) {
            if (this.getPrev(unit).isBefore(this.minTime)) {
                min = this.value.get(unit);
            }
            if (this.getNext(unit).isBefore(this.minTime)) {
                min = this.minTime.get(unit);
            }
        }
        return min;
    }
    /**
     * Gets the maximum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The maximum value.
     */
    getMax(unit) {
        /** @type {?} */
        let max = null;
        if (this.maxTime && this.value.isSame(this.maxTime, 'day')) {
            if (this.getNext(unit).isAfter(this.maxTime)) {
                max = this.value.get(unit);
            }
            if (this.getPrev(unit).isAfter(this.maxTime)) {
                max = this.maxTime.get(unit);
            }
        }
        return max;
    }
    /**
     * Gets the value after moving up the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    getPrev(unit) {
        /** @type {?} */
        const prev = this.value.clone().subtract((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        return this.value.clone().set(unit, prev.get(unit));
    }
    /**
     * Gets the value after moving down the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    getNext(unit) {
        /** @type {?} */
        const next = this.value.clone().add((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        return this.value.clone().set(unit, next.get(unit));
    }
    /**
     * Gets the value before midday.
     * @return {?}
     */
    getAM() {
        if (this.value.hour() >= 12) {
            return this.value.clone().subtract(12, 'hour');
        }
        return this.value;
    }
    /**
     * Gets the value after midday.
     * @return {?}
     */
    getPM() {
        if (this.value.hour() < 12) {
            return this.value.clone().add(12, 'hour');
        }
        return this.value;
    }
    /**
     * Whether the given value is selectable.
     * @param {?} value The value to check.
     * @return {?} `true` if the value is valid. Otherwise `false`.
     */
    isValid(value) {
        /** @type {?} */
        const beforeMin = this.minTime && value.isBefore(this.minTime);
        /** @type {?} */
        const afterMax = this.maxTime && value.isAfter(this.maxTime);
        return !(beforeMin || afterMax);
    }
}
MatTimeSelectContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-select-content',
                template: "<table class=\"mat-time-select-table mat-{{ color }}\">\r\n  <tr>\r\n    <ng-container *ngFor=\"let unit of units; first as first\">\r\n      <td *ngIf=\"!first\" class=\"mat-time-select-column mat-time-select-separator\">\r\n        <div class=\"mat-time-unit-separator\">\r\n          <span class=\"mat-time-unit-separator-text\">:</span>\r\n        </div>\r\n      </td>\r\n      <td class=\"mat-time-select-column mat-time-select-{{ unit }}\">\r\n        <mat-time-unit-select\r\n          [min]=\"getMin(unit)\"\r\n          [max]=\"getMax(unit)\"\r\n          [unit]=\"unit\"\r\n          [value]=\"get(unit)\"\r\n          (valueChange)=\"set(unit, $event)\">\r\n        </mat-time-unit-select>\r\n      </td>\r\n    </ng-container>\r\n  </tr>\r\n  <tr *ngIf=\"hourClock === 12\">\r\n    <td class=\"mat-time-ampm\" [colSpan]=\"(units.length * 2) - 1\">\r\n      <mat-button-toggle-group [value]=\"amPm\" (change)=\"amPm = $event.value\">\r\n        <mat-button-toggle value=\"am\" [disabled]=\"!isValid(getAM())\">{{ _intl.amLabel }}</mat-button-toggle>\r\n        <mat-button-toggle value=\"pm\" [disabled]=\"!isValid(getPM())\">{{ _intl.pmLabel }}</mat-button-toggle>\r\n      </mat-button-toggle-group>\r\n    </td>\r\n  </tr>\r\n</table>\r\n",
                exportAs: 'matTimeSelectContent',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".mat-time-select-content{display:block;border-radius:4px}.mat-time-select-content .mat-time-select-table{border-collapse:collapse}.mat-time-select-content .mat-time-select-column{width:80px;padding:0}.mat-time-select-content .mat-time-select-column .mat-time-unit-select-panel{position:relative}.mat-time-select-content .mat-time-select-hour .mat-time-unit-select-panel{top:-440px}.mat-time-select-content .mat-time-select-minute .mat-time-unit-select-panel,.mat-time-select-content .mat-time-select-second .mat-time-unit-select-panel{top:-1160px}.mat-time-select-content .mat-time-select-separator{text-align:center}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;height:40px;width:100%}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator-text{width:100%}.mat-time-select-content .mat-time-ampm{text-align:center}"]
            }] }
];
/** @nocollapse */
MatTimeSelectContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatTimeSelectIntl },
    { type: TimeAdapter, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TIME_SELECT_DATA,] }] }
];
MatTimeSelectContentComponent.propDecorators = {
    color: [{ type: Input }],
    units: [{ type: Input }],
    value: [{ type: Input }],
    minTime: [{ type: Input }],
    maxTime: [{ type: Input }],
    valueChange: [{ type: Output }],
    timeUnitSelectComponents: [{ type: ViewChildren, args: [MatTimeUnitSelectComponent,] }],
    class: [{ type: HostBinding, args: ['class',] }]
};
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.color;
    /**
     * The array of unit of time selectable in the time select content.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.units;
    /**
     * The currently selected time of the time select content.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.value;
    /**
     * The minimum selectable time.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.minTime;
    /**
     * The minimum selectable time.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.maxTime;
    /**
     * Emits when the time select content selected time has been changed.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.valueChange;
    /**
     * Reference to the internal time unit select components.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.timeUnitSelectComponents;
    /**
     * \@docs-private
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.class;
    /**
     * The hour clock type. Possible values: 12: 12 hour clock; 24: 24 hour clock
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.hourClock;
    /** @type {?} */
    MatTimeSelectContentComponent.prototype._intl;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectContentComponent.prototype._timeAdapter;
}
/**
 * Component responsible for managing the time select popup.
 * @template D
 */
export class MatTimeSelectComponent {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _ngZone
     * @param {?} _viewContainerRef
     * @param {?} scrollStrategy
     * @param {?} _timeAdapter
     * @param {?} _dir
     * @param {?} _document
     */
    constructor(_overlay, _injector, _ngZone, _viewContainerRef, scrollStrategy, _timeAdapter, _dir, _document) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._viewContainerRef = _viewContainerRef;
        this._timeAdapter = _timeAdapter;
        this._dir = _dir;
        this._document = _document;
        /**
         * Subscription to value changes in the associated input element.
         */
        this._inputSubscription = Subscription.EMPTY;
        this._opened = false;
        this._disabledChange = new Subject();
        this._selectedChange = new Subject();
        /**
         * The element that was focused before the time select was opened.
         */
        this._focusedElementBeforeOpen = null;
        /**
         * Emits when the time select has been opened.
         */
        this.openStream = new EventEmitter();
        /**
         * Emits when the time select has been closed.
         */
        this.closeStream = new EventEmitter();
        /**
         * The id for the time select popup.
         */
        this.id = `mat-time-select-${timeSelectUid++}`;
        if (!this._timeAdapter) {
            throw createMissingTimeImplError('TimeAdapter');
        }
        this._scrollStrategy = scrollStrategy;
    }
    /**
     * The initial time of the time select.
     * @return {?}
     */
    get startAt() { return this._startAt || (this._timeSelectInput ? this._timeSelectInput.value : null); }
    /**
     * @param {?} value
     * @return {?}
     */
    set startAt(value) { this._startAt = this._getValidDateOrNull(this._timeAdapter.deserialize(value)); }
    /**
     * The color palette to use on the time select popup.
     * @return {?}
     */
    get color() { return this._color || (this._timeSelectInput ? this._timeSelectInput.getThemePalette() : undefined); }
    /**
     * @param {?} value
     * @return {?}
     */
    set color(value) { this._color = value; }
    /**
     * Whether the time select pop-up should disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled !== undefined ? this._disabled : (this._timeSelectInput ? this._timeSelectInput.disabled : false);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const disabled = coerceBooleanProperty(value);
        if (this._disabled !== disabled) {
            this._disabled = disabled;
            this._disabledChange.next(disabled);
        }
    }
    /**
     * The currently selected time.
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) { this._selected = value; }
    /**
     * Whether the time select is opened.
     * @return {?}
     */
    get opened() { return this._opened; }
    /**
     * @param {?} value
     * @return {?}
     */
    set opened(value) { value ? this.open() : close(); }
    /**
     * Emits when the time select disabled state has been changed.
     * @return {?}
     */
    get disabledChange() { return this._disabledChange.asObservable(); }
    /**
     * Emits when the time select selected time has been changed.
     * @return {?}
     */
    get selectedChange() { return this._selectedChange.asObservable(); }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.close();
        this._inputSubscription.unsubscribe();
        this._disabledChange.complete();
        if (this._popupRef) {
            this._popupRef.dispose();
            this._popupComponentRef = null;
        }
    }
    /**
     * Selects the given time.
     * @param {?} time The date time to select.
     * @return {?}
     */
    select(time) {
        /** @type {?} */
        const oldValue = this.selected;
        /** @type {?} */
        const value = this._timeAdapter.clone(time);
        this.selected = value;
        if (!this._timeAdapter.sameTime(oldValue, value)) {
            this._selectedChange.next(value);
        }
    }
    /**
     * Register an input with this time select.
     * @param {?} input The time select input to register with this time select.
     * @return {?}
     */
    registerInput(input) {
        if (this._timeSelectInput) {
            throw Error('A MatTimeSelect can only be associated with a single input.');
        }
        this._timeSelectInput = input;
        this._inputSubscription = this._timeSelectInput.valueChange.subscribe((value) => this.selected = value);
    }
    /**
     * Open the time select.
     * @return {?}
     */
    open() {
        if (this._opened || this.disabled) {
            return;
        }
        if (!this._timeSelectInput) {
            throw Error('Attempted to open an MatTimeSelect with no associated input.');
        }
        if (this._document) {
            this._focusedElementBeforeOpen = this._document.activeElement;
        }
        this._openAsPopup();
        this._opened = true;
        this.openStream.emit();
    }
    /**
     * Close the time select.
     * @return {?}
     */
    close() {
        if (!this._opened) {
            return;
        }
        if (this._popupRef && this._popupRef.hasAttached()) {
            this._popupRef.detach();
        }
        if (this._popupComponentPortal && this._popupComponentPortal.isAttached) {
            this._popupComponentPortal.detach();
        }
        /** @type {?} */
        const completeClose = () => {
            // The `_opened` could've been reset already if
            // we got two events in quick succession.
            if (this._opened) {
                this._opened = false;
                this.closeStream.emit();
                this._focusedElementBeforeOpen = null;
            }
        };
        if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {
            // Because IE moves focus asynchronously, we can't count on it being restored before we've
            // marked the time select as closed. If the event fires out of sequence and the element that
            // we're refocusing opens the time select on focus, the user could be stuck with not being
            // able to close the select panel at all. We work around it by making the logic, that marks
            // the time select as closed, async as well.
            this._focusedElementBeforeOpen.focus();
            setTimeout(completeClose);
        }
        else {
            completeClose();
        }
    }
    /**
     * Open the time select as a popup.
     * @private
     * @return {?}
     */
    _openAsPopup() {
        this._popupComponentPortal = new ComponentPortal(MatTimeSelectContentComponent, this._viewContainerRef, this._createInjector());
        if (!this._popupRef) {
            this._createPopup();
        }
        if (!this._popupRef.hasAttached()) {
            this._popupComponentRef = this._popupRef.attach(this._popupComponentPortal);
            this._popupComponentRef.instance.valueChange.subscribe((value) => this.select(this._timeAdapter.deserialize(value.toISOString())));
            this._setColor();
            // Update the position once the select panel has rendered.
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this._popupRef.updatePosition();
            });
        }
    }
    /**
     * Create a portal injector to inject time select initial data.
     * @private
     * @return {?}
     */
    _createInjector() {
        /** @type {?} */
        const data = {
            value: this.startAt,
            minTime: this._timeSelectInput && this._timeSelectInput.min,
            maxTime: this._timeSelectInput && this._timeSelectInput.max
        };
        /** @type {?} */
        const injectorTokens = new WeakMap([
            [MAT_TIME_SELECT_DATA, data]
        ]);
        return new PortalInjector(this._injector, injectorTokens);
    }
    /**
     * Create the popup.
     * @private
     * @return {?}
     */
    _createPopup() {
        /** @type {?} */
        const overlayConfig = new OverlayConfig({
            positionStrategy: this._createPopupPositionStrategy(),
            hasBackdrop: true,
            backdropClass: 'mat-overlay-transparent-backdrop',
            direction: this._dir,
            scrollStrategy: this._scrollStrategy(),
            panelClass: 'mat-time-select-popup',
        });
        this._popupRef = this._overlay.create(overlayConfig);
        this._popupRef.overlayElement.setAttribute('role', 'dialog');
        merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(event => {
            // Closing on alt + up is only valid when there's an input associated with the time select.
            return event.keyCode === ESCAPE ||
                (this._timeSelectInput && event.altKey && event.keyCode === UP_ARROW);
        }))).subscribe(() => this.close());
    }
    /**
     * Create the popup position strategy.
     * @private
     * @return {?}
     */
    _createPopupPositionStrategy() {
        return this._overlay.position()
            .flexibleConnectedTo(this._timeSelectInput.getConnectedOverlayOrigin())
            .withTransformOriginOn('.mat-time-select-content')
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withLockedPosition()
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
    }
    /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    _getValidDateOrNull(obj) {
        return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
    }
    /**
     * Passes the current theme color along to the time select overlay.
     * @private
     * @return {?}
     */
    _setColor() {
        if (this._popupComponentRef) {
            this._popupComponentRef.instance.color = this.color;
        }
    }
}
MatTimeSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-select',
                template: '',
                exportAs: 'matTimeSelect',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
MatTimeSelectComponent.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: NgZone },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_TIME_SELECT_SCROLL_STRATEGY,] }] },
    { type: TimeAdapter, decorators: [{ type: Optional }] },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
MatTimeSelectComponent.propDecorators = {
    openStream: [{ type: Output, args: ['open',] }],
    closeStream: [{ type: Output, args: ['close',] }],
    startAt: [{ type: Input }],
    color: [{ type: Input }],
    disabled: [{ type: Input }],
    selected: [{ type: Input }],
    opened: [{ type: Input }]
};
if (false) {
    /**
     * Subscription to value changes in the associated input element.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._inputSubscription;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._startAt;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._color;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._opened;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._disabledChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._selectedChange;
    /**
     * A reference to the overlay when the time select is opened as a popup.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._popupRef;
    /**
     * A portal containing the popup for this time select.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._popupComponentPortal;
    /**
     * Reference to the component instantiated in popup mode.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._popupComponentRef;
    /**
     * The element that was focused before the time select was opened.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._focusedElementBeforeOpen;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._scrollStrategy;
    /**
     * The input element this time select is associated with.
     * @type {?}
     */
    MatTimeSelectComponent.prototype._timeSelectInput;
    /**
     * Emits when the time select has been opened.
     * @type {?}
     */
    MatTimeSelectComponent.prototype.openStream;
    /**
     * Emits when the time select has been closed.
     * @type {?}
     */
    MatTimeSelectComponent.prototype.closeStream;
    /**
     * The id for the time select popup.
     * @type {?}
     */
    MatTimeSelectComponent.prototype.id;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._timeAdapter;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1zZWxlY3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hdGVyaWFsLXRpbWUtc2VsZWN0LyIsInNvdXJjZXMiOlsibGliL3RpbWUtc2VsZWN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBRVQsVUFBVSxFQUNWLFlBQVksRUFDWixXQUFXLEVBQ1gsTUFBTSxFQUNOLGNBQWMsRUFDZCxRQUFRLEVBQ1IsS0FBSyxFQUNMLE1BQU0sRUFFTixRQUFRLEVBQ1IsTUFBTSxFQUVOLFNBQVMsRUFDVCxZQUFZLEVBQ1osZ0JBQWdCLEVBQ2hCLGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ2pELE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQzVELE9BQU8sRUFBQyxNQUFNLEVBQUUsUUFBUSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDdkQsT0FBTyxFQUFDLE9BQU8sRUFBRSxhQUFhLEVBQStDLE1BQU0sc0JBQXNCLENBQUM7QUFDMUcsT0FBTyxFQUFDLGVBQWUsRUFBRSxjQUFjLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRSxPQUFPLEVBQXlCLFVBQVUsRUFBZSxNQUFNLG1CQUFtQixDQUFDO0FBQ25GLE9BQU8sRUFBQyxLQUFLLEVBQWMsT0FBTyxFQUFFLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUM5RCxPQUFPLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRTVDLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsMEJBQTBCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztB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MEJBRWIsTUFBTSxTQUFDLE9BQU87c0JBTWQsS0FBSztvQkFLTCxLQUFLO3VCQUtMLEtBQUs7dUJBYUwsS0FBSztxQkFLTCxLQUFLOzs7Ozs7OztJQTlETixvREFBZ0Q7Ozs7O0lBRWhELDBDQUEyQjs7Ozs7SUFDM0Isd0NBQTZCOzs7OztJQUM3QiwyQ0FBMkI7Ozs7O0lBQzNCLDJDQUFxQjs7Ozs7SUFDckIseUNBQXdCOzs7OztJQUV4QixpREFBbUU7Ozs7O0lBQ25FLGlEQUF1RDs7Ozs7O0lBR3ZELDJDQUE4Qjs7Ozs7O0lBRTlCLHVEQUFpRjs7Ozs7O0lBRWpGLG9EQUEyRTs7Ozs7O0lBRTNFLDJEQUE2RDs7Ozs7SUFFN0QsaURBQXVEOzs7OztJQUd2RCxrREFBaUQ7Ozs7O0lBR2pELDRDQUEwRTs7Ozs7SUFFMUUsNkNBQTRFOzs7OztJQUc1RSxvQ0FBMEM7Ozs7O0lBd0M5QiwwQ0FBeUI7Ozs7O0lBQ3pCLDJDQUEyQjs7Ozs7SUFDM0IseUNBQXVCOzs7OztJQUN2QixtREFBMkM7Ozs7O0lBRTNDLDhDQUFnRDs7Ozs7SUFDaEQsc0NBQXdDOzs7OztJQUN4QywyQ0FBb0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBDb21wb25lbnRSZWYsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSG9zdEJpbmRpbmcsXHJcbiAgSW5qZWN0LFxyXG4gIEluamVjdGlvblRva2VuLFxyXG4gIEluamVjdG9yLFxyXG4gIElucHV0LFxyXG4gIE5nWm9uZSxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3B0aW9uYWwsXHJcbiAgT3V0cHV0LFxyXG4gIFByb3ZpZGVyLFxyXG4gIFF1ZXJ5TGlzdCxcclxuICBWaWV3Q2hpbGRyZW4sXHJcbiAgVmlld0NvbnRhaW5lclJlZixcclxuICBWaWV3RW5jYXBzdWxhdGlvblxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0RPQ1VNRU5UfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQge0RpcmVjdGlvbmFsaXR5fSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XHJcbmltcG9ydCB7Y29lcmNlQm9vbGVhblByb3BlcnR5fSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xyXG5pbXBvcnQge0VTQ0FQRSwgVVBfQVJST1d9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XHJcbmltcG9ydCB7T3ZlcmxheSwgT3ZlcmxheUNvbmZpZywgT3ZlcmxheVJlZiwgUG9zaXRpb25TdHJhdGVneSwgU2Nyb2xsU3RyYXRlZ3l9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcclxuaW1wb3J0IHtDb21wb25lbnRQb3J0YWwsIFBvcnRhbEluamVjdG9yfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcclxuaW1wb3J0IHtDYW5Db2xvciwgQ2FuQ29sb3JDdG9yLCBtaXhpbkNvbG9yLCBUaGVtZVBhbGV0dGV9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcclxuaW1wb3J0IHttZXJnZSwgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtmaWx0ZXIsIHRha2V9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHtEdXJhdGlvbklucHV0QXJnMSwgRHVyYXRpb25JbnB1dEFyZzIsIE1vbWVudCwgdW5pdE9mVGltZX0gZnJvbSAnbW9tZW50JztcclxuaW1wb3J0IHtUaW1lQWRhcHRlcn0gZnJvbSAnLi90aW1lLWFkYXB0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7Y3JlYXRlTWlzc2luZ1RpbWVJbXBsRXJyb3J9IGZyb20gJy4vdGltZS1zZWxlY3QtZXJyb3JzJztcclxuaW1wb3J0IHtNYXRUaW1lU2VsZWN0SW50bH0gZnJvbSAnLi90aW1lLXNlbGVjdC1pbnRsLnNlcnZpY2UnO1xyXG5pbXBvcnQge01hdFRpbWVTZWxlY3RJbnB1dERpcmVjdGl2ZX0gZnJvbSAnLi90aW1lLXNlbGVjdC1pbnB1dC5kaXJlY3RpdmUnO1xyXG5pbXBvcnQge01hdFRpbWVVbml0U2VsZWN0Q29tcG9uZW50fSBmcm9tICcuL3RpbWUtdW5pdC1zZWxlY3QuY29tcG9uZW50JztcclxuXHJcbi8qKiBVc2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBlYWNoIHRpbWUgc2VsZWN0IGluc3RhbmNlLiAqL1xyXG5sZXQgdGltZVNlbGVjdFVpZCA9IDA7XHJcblxyXG4vKiogSW5qZWN0aW9uIHRva2VuIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgdGltZSBzZWxlY3QgZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IE1BVF9USU1FX1NFTEVDVF9EQVRBID0gbmV3IEluamVjdGlvblRva2VuPE1vbWVudD4oJ21hdC10aW1lLXNlbGVjdC1kYXRhJyk7XHJcblxyXG4vKiogSW5qZWN0aW9uIHRva2VuIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2Nyb2xsIGhhbmRsaW5nIHdoaWxlIHRoZSB0aW1lIHNlbGVjdCBpcyBvcGVuZWQuICovXHJcbmV4cG9ydCBjb25zdCBNQVRfVElNRV9TRUxFQ1RfU0NST0xMX1NUUkFURUdZID0gbmV3IEluamVjdGlvblRva2VuPCgpID0+IFNjcm9sbFN0cmF0ZWd5PignbWF0LXRpbWUtc2VsZWN0LXNjcm9sbC1zdHJhdGVneScpO1xyXG5cclxuLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE1BVF9USU1FX1NFTEVDVF9TQ1JPTExfU1RSQVRFR1lfRkFDVE9SWShvdmVybGF5OiBPdmVybGF5KTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3kge1xyXG4gIHJldHVybiAoKSA9PiBvdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xyXG59XHJcblxyXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG5leHBvcnQgY29uc3QgTUFUX1RJTUVfU0VMRUNUX1NDUk9MTF9TVFJBVEVHWV9GQUNUT1JZX1BST1ZJREVSOiBQcm92aWRlciA9IHtcclxuICBwcm92aWRlOiBNQVRfVElNRV9TRUxFQ1RfU0NST0xMX1NUUkFURUdZLFxyXG4gIGRlcHM6IFtPdmVybGF5XSxcclxuICB1c2VGYWN0b3J5OiBNQVRfVElNRV9TRUxFQ1RfU0NST0xMX1NUUkFURUdZX0ZBQ1RPUllcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWF0VGltZVNlbGVjdERhdGE8RD4ge1xyXG4gIHVuaXRzPzogdW5pdE9mVGltZS5BbGxbXTtcclxuICB2YWx1ZT86IEQ7XHJcbiAgbWluVGltZT86IEQ7XHJcbiAgbWF4VGltZT86IEQ7XHJcbn1cclxuXHJcbi8qKiBAZG9jcy1wcml2YXRlICovXHJcbmV4cG9ydCBjbGFzcyBNYXRUaW1lU2VsZWN0Q29udGVudEJhc2Uge1xyXG5cclxuICBjb25zdHJ1Y3RvcihwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IF9NYXRUaW1lU2VsZWN0Q29udGVudE1peGluQmFzZTogQ2FuQ29sb3JDdG9yICYgdHlwZW9mIE1hdFRpbWVTZWxlY3RDb250ZW50QmFzZSA9XHJcbiAgbWl4aW5Db2xvcihNYXRUaW1lU2VsZWN0Q29udGVudEJhc2UpO1xyXG5cclxuLyoqXHJcbiAqIENvbXBvbmVudCB1c2VkIGFzIHRoZSBjb250ZW50IGZvciB0aGUgdGltZSBzZWxlY3QgcG9wdXAuXHJcbiAqIEBkb2NzLXByaXZhdGVcclxuICovXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbWF0LXRpbWUtc2VsZWN0LWNvbnRlbnQnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi90aW1lLXNlbGVjdC1jb250ZW50LmNvbXBvbmVudC5odG1sJyxcclxuICBzdHlsZVVybHM6IFsnLi90aW1lLXNlbGVjdC1jb250ZW50LmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgZXhwb3J0QXM6ICdtYXRUaW1lU2VsZWN0Q29udGVudCcsXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWF0VGltZVNlbGVjdENvbnRlbnRDb21wb25lbnQ8RD4gZXh0ZW5kcyBfTWF0VGltZVNlbGVjdENvbnRlbnRNaXhpbkJhc2UgaW1wbGVtZW50cyBDYW5Db2xvciB7XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgQElucHV0KCkgY29sb3I6IFRoZW1lUGFsZXR0ZTtcclxuICAvKiogVGhlIGFycmF5IG9mIHVuaXQgb2YgdGltZSBzZWxlY3RhYmxlIGluIHRoZSB0aW1lIHNlbGVjdCBjb250ZW50LiAqL1xyXG4gIEBJbnB1dCgpIHVuaXRzOiB1bml0T2ZUaW1lLkFsbFtdO1xyXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHRpbWUgb2YgdGhlIHRpbWUgc2VsZWN0IGNvbnRlbnQuICovXHJcbiAgQElucHV0KCkgdmFsdWU6IE1vbWVudDtcclxuICAvKiogVGhlIG1pbmltdW0gc2VsZWN0YWJsZSB0aW1lLiAqL1xyXG4gIEBJbnB1dCgpIG1pblRpbWU6IE1vbWVudDtcclxuICAvKiogVGhlIG1pbmltdW0gc2VsZWN0YWJsZSB0aW1lLiAqL1xyXG4gIEBJbnB1dCgpIG1heFRpbWU6IE1vbWVudDtcclxuXHJcbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHRpbWUgc2VsZWN0IGNvbnRlbnQgc2VsZWN0ZWQgdGltZSBoYXMgYmVlbiBjaGFuZ2VkLiAqL1xyXG4gIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPE1vbWVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vbWVudD4oKTtcclxuXHJcbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgdGltZSB1bml0IHNlbGVjdCBjb21wb25lbnRzLiAqL1xyXG4gIEBWaWV3Q2hpbGRyZW4oTWF0VGltZVVuaXRTZWxlY3RDb21wb25lbnQpIHRpbWVVbml0U2VsZWN0Q29tcG9uZW50czogUXVlcnlMaXN0PE1hdFRpbWVVbml0U2VsZWN0Q29tcG9uZW50PEQ+PjtcclxuXHJcbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgcmVhZG9ubHkgY2xhc3MgPSAnbWF0LXRpbWUtc2VsZWN0LWNvbnRlbnQnO1xyXG5cclxuICAvKiogVGhlIGhvdXIgY2xvY2sgdHlwZS4gUG9zc2libGUgdmFsdWVzOiAxMjogMTIgaG91ciBjbG9jazsgMjQ6IDI0IGhvdXIgY2xvY2sgKi9cclxuICBob3VyQ2xvY2s6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRpbWUgcGVyaW9kIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGltZSBvZiB0aGUgdGltZSBzZWxlY3QgY29udGVudC4gUG9zc2libGUgdmFsdWVzOiBgYW1gIHdoZW4gc2VsZWN0ZWQgdGltZSBob3VyIGlzIGxlc3NcclxuICAgKiB0aGFuIDEyOyBgcG1gIHdoZW4gc2VsZWN0ZWQgdGltZSBob3VyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxMi5cclxuICAgKi9cclxuICBnZXQgYW1QbSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy52YWx1ZSA/ICh0aGlzLnZhbHVlLmhvdXIoKSA8IDEyID8gJ2FtJyA6ICdwbScpIDogbnVsbDsgfVxyXG4gIHNldCBhbVBtKHZhbHVlOiBzdHJpbmcpIHtcclxuICAgIGlmICh0aGlzLnRpbWVVbml0U2VsZWN0Q29tcG9uZW50cykge1xyXG4gICAgICB0aGlzLnRpbWVVbml0U2VsZWN0Q29tcG9uZW50cy50b0FycmF5KClcclxuICAgICAgICAuZmlsdGVyKHRpbWVTZWxlY3QgPT4gdGltZVNlbGVjdC51bml0ID09PSAnaG91cicpXHJcbiAgICAgICAgLmZvckVhY2godGltZVNlbGVjdCA9PiB0aW1lU2VsZWN0Lm1vdmUodmFsdWUgPT09ICdhbScgPyAtMTIgOiAxMikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgICAgICAgICAgICBwdWJsaWMgX2ludGw6IE1hdFRpbWVTZWxlY3RJbnRsLFxyXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3RpbWVBZGFwdGVyOiBUaW1lQWRhcHRlcjxEPixcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BVF9USU1FX1NFTEVDVF9EQVRBKSBkYXRhOiBNYXRUaW1lU2VsZWN0RGF0YTxEPikge1xyXG4gICAgc3VwZXIoZWxlbWVudFJlZik7XHJcblxyXG4gICAgaWYgKCF0aGlzLl90aW1lQWRhcHRlcikge1xyXG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nVGltZUltcGxFcnJvcignVGltZUFkYXB0ZXInKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0aW1lID0gdGhpcy5fdGltZUFkYXB0ZXIuaXNEYXRlSW5zdGFuY2UoZGF0YS52YWx1ZSkgJiYgdGhpcy5fdGltZUFkYXB0ZXIuaXNWYWxpZChkYXRhLnZhbHVlKSA/XHJcbiAgICAgIHRoaXMuX3RpbWVBZGFwdGVyLmNsb25lKGRhdGEudmFsdWUpIDogdGhpcy5fdGltZUFkYXB0ZXIubm93KCk7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3RpbWVBZGFwdGVyLnRvTW9tZW50KHRoaXMuX3RpbWVBZGFwdGVyLmNsYW1wVGltZSh0aW1lLCBkYXRhLm1pblRpbWUsIGRhdGEubWF4VGltZSkpO1xyXG4gICAgY29uc3QgbG9jYWxlRGF0YSA9IHZhbHVlLmxvY2FsZURhdGEoKTtcclxuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXQgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KCdMVFMnKTtcclxuICAgIHRoaXMuaG91ckNsb2NrID0gL2hoPy9nLnRlc3QoZGlzcGxheUZvcm1hdCkgPyAxMiA6IDI0O1xyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdGhpcy51bml0cyA9IGRhdGEudW5pdHMgfHwgWydob3VyJywgJ21pbnV0ZSddO1xyXG4gICAgdGhpcy5taW5UaW1lID0gZGF0YS5taW5UaW1lID8gdGhpcy5fdGltZUFkYXB0ZXIudG9Nb21lbnQoZGF0YS5taW5UaW1lKSA6IG51bGw7XHJcbiAgICB0aGlzLm1heFRpbWUgPSBkYXRhLm1heFRpbWUgPyB0aGlzLl90aW1lQWRhcHRlci50b01vbWVudChkYXRhLm1heFRpbWUpIDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiB1bml0IG9mIHRpbWUuXHJcbiAgICogQHBhcmFtIHVuaXQgVGhlIHVuaXQgb2YgdGltZSB0byBxdWVyeS5cclxuICAgKiBAcmV0dXJucyBUaGUgcmV0cmlldmVkIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCh1bml0OiB1bml0T2ZUaW1lLkFsbCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5nZXQodW5pdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gdW5pdCBvZiB0aW1lLlxyXG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRpbWUgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAqL1xyXG4gIHNldCh1bml0OiB1bml0T2ZUaW1lLkFsbCwgdmFsdWU6IG51bWJlcikge1xyXG4gICAgdGhpcy52YWx1ZS5zZXQodW5pdCwgdmFsdWUpO1xyXG4gICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMudmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHRoZSBnaXZlbiB1bml0IG9mIHRpbWUuXHJcbiAgICogQHBhcmFtIHVuaXQgVGhlIHVuaXQgb2YgdGltZSB0byBxdWVyeS5cclxuICAgKiBAcmV0dXJucyBUaGUgbWluaW11bSB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRNaW4odW5pdDogdW5pdE9mVGltZS5BbGwpOiBudW1iZXIgfCBudWxsIHtcclxuICAgIGxldCBtaW4gPSBudWxsO1xyXG4gICAgaWYgKHRoaXMubWluVGltZSAmJiB0aGlzLnZhbHVlLmlzU2FtZSh0aGlzLm1pblRpbWUsICdkYXknKSkge1xyXG4gICAgICBpZiAodGhpcy5nZXRQcmV2KHVuaXQpLmlzQmVmb3JlKHRoaXMubWluVGltZSkpIHtcclxuICAgICAgICBtaW4gPSB0aGlzLnZhbHVlLmdldCh1bml0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5nZXROZXh0KHVuaXQpLmlzQmVmb3JlKHRoaXMubWluVGltZSkpIHtcclxuICAgICAgICBtaW4gPSB0aGlzLm1pblRpbWUuZ2V0KHVuaXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWluO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlIG9mIHRoZSBnaXZlbiB1bml0IG9mIHRpbWUuXHJcbiAgICogQHBhcmFtIHVuaXQgVGhlIHVuaXQgb2YgdGltZSB0byBxdWVyeS5cclxuICAgKiBAcmV0dXJucyBUaGUgbWF4aW11bSB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRNYXgodW5pdDogdW5pdE9mVGltZS5BbGwpOiBudW1iZXIgfCBudWxsIHtcclxuICAgIGxldCBtYXggPSBudWxsO1xyXG4gICAgaWYgKHRoaXMubWF4VGltZSAmJiB0aGlzLnZhbHVlLmlzU2FtZSh0aGlzLm1heFRpbWUsICdkYXknKSkge1xyXG4gICAgICBpZiAodGhpcy5nZXROZXh0KHVuaXQpLmlzQWZ0ZXIodGhpcy5tYXhUaW1lKSkge1xyXG4gICAgICAgIG1heCA9IHRoaXMudmFsdWUuZ2V0KHVuaXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmdldFByZXYodW5pdCkuaXNBZnRlcih0aGlzLm1heFRpbWUpKSB7XHJcbiAgICAgICAgbWF4ID0gdGhpcy5tYXhUaW1lLmdldCh1bml0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHZhbHVlIGFmdGVyIG1vdmluZyB1cCB0aGUgZ2l2ZW4gdW5pdCBvZiB0aW1lLlxyXG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRpbWUgdG8gbW92ZS5cclxuICAgKiBAcmV0dXJucyBUaGUgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldFByZXYodW5pdDogdW5pdE9mVGltZS5BbGwpOiBNb21lbnQge1xyXG4gICAgY29uc3QgcHJldiA9IHRoaXMudmFsdWUuY2xvbmUoKS5zdWJ0cmFjdCgxIGFzIER1cmF0aW9uSW5wdXRBcmcxLCB1bml0IGFzIER1cmF0aW9uSW5wdXRBcmcyKTtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlLmNsb25lKCkuc2V0KHVuaXQsIHByZXYuZ2V0KHVuaXQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHZhbHVlIGFmdGVyIG1vdmluZyBkb3duIHRoZSBnaXZlbiB1bml0IG9mIHRpbWUuXHJcbiAgICogQHBhcmFtIHVuaXQgVGhlIHVuaXQgb2YgdGltZSB0byBtb3ZlLlxyXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0TmV4dCh1bml0OiB1bml0T2ZUaW1lLkFsbCk6IE1vbWVudCB7XHJcbiAgICBjb25zdCBuZXh0ID0gdGhpcy52YWx1ZS5jbG9uZSgpLmFkZCgxIGFzIER1cmF0aW9uSW5wdXRBcmcxLCB1bml0IGFzIER1cmF0aW9uSW5wdXRBcmcyKTtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlLmNsb25lKCkuc2V0KHVuaXQsIG5leHQuZ2V0KHVuaXQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHZhbHVlIGJlZm9yZSBtaWRkYXkuXHJcbiAgICovXHJcbiAgZ2V0QU0oKTogTW9tZW50IHtcclxuICAgIGlmICh0aGlzLnZhbHVlLmhvdXIoKSA+PSAxMikge1xyXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZS5jbG9uZSgpLnN1YnRyYWN0KDEyLCAnaG91cicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhZnRlciBtaWRkYXkuXHJcbiAgICovXHJcbiAgZ2V0UE0oKTogTW9tZW50IHtcclxuICAgIGlmICh0aGlzLnZhbHVlLmhvdXIoKSA8IDEyKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLmNsb25lKCkuYWRkKDEyLCAnaG91cicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBzZWxlY3RhYmxlLlxyXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZC4gT3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiAgICovXHJcbiAgaXNWYWxpZCh2YWx1ZTogTW9tZW50KTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBiZWZvcmVNaW4gPSB0aGlzLm1pblRpbWUgJiYgdmFsdWUuaXNCZWZvcmUodGhpcy5taW5UaW1lKTtcclxuICAgIGNvbnN0IGFmdGVyTWF4ID0gdGhpcy5tYXhUaW1lICYmIHZhbHVlLmlzQWZ0ZXIodGhpcy5tYXhUaW1lKTtcclxuICAgIHJldHVybiAhKGJlZm9yZU1pbiB8fCBhZnRlck1heCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuLyoqIENvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgdGhlIHRpbWUgc2VsZWN0IHBvcHVwLiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ21hdC10aW1lLXNlbGVjdCcsXHJcbiAgdGVtcGxhdGU6ICcnLFxyXG4gIGV4cG9ydEFzOiAnbWF0VGltZVNlbGVjdCcsXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWF0VGltZVNlbGVjdENvbXBvbmVudDxEPiBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQ2FuQ29sb3Ige1xyXG5cclxuICAvKiogU3Vic2NyaXB0aW9uIHRvIHZhbHVlIGNoYW5nZXMgaW4gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gKi9cclxuICBwcml2YXRlIF9pbnB1dFN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcclxuXHJcbiAgcHJpdmF0ZSBfc3RhcnRBdDogRCB8IG51bGw7XHJcbiAgcHJpdmF0ZSBfY29sb3I6IFRoZW1lUGFsZXR0ZTtcclxuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbjtcclxuICBwcml2YXRlIF9zZWxlY3RlZDogRDtcclxuICBwcml2YXRlIF9vcGVuZWQgPSBmYWxzZTtcclxuXHJcbiAgcHJpdmF0ZSBfZGlzYWJsZWRDaGFuZ2U6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xyXG4gIHByaXZhdGUgX3NlbGVjdGVkQ2hhbmdlOiBTdWJqZWN0PEQ+ID0gbmV3IFN1YmplY3Q8RD4oKTtcclxuXHJcbiAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IHdoZW4gdGhlIHRpbWUgc2VsZWN0IGlzIG9wZW5lZCBhcyBhIHBvcHVwLiAqL1xyXG4gIHByaXZhdGUgX3BvcHVwUmVmOiBPdmVybGF5UmVmO1xyXG4gIC8qKiBBIHBvcnRhbCBjb250YWluaW5nIHRoZSBwb3B1cCBmb3IgdGhpcyB0aW1lIHNlbGVjdC4gKi9cclxuICBwcml2YXRlIF9wb3B1cENvbXBvbmVudFBvcnRhbDogQ29tcG9uZW50UG9ydGFsPE1hdFRpbWVTZWxlY3RDb250ZW50Q29tcG9uZW50PEQ+PjtcclxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQgaW5zdGFudGlhdGVkIGluIHBvcHVwIG1vZGUuICovXHJcbiAgcHJpdmF0ZSBfcG9wdXBDb21wb25lbnRSZWY6IENvbXBvbmVudFJlZjxNYXRUaW1lU2VsZWN0Q29udGVudENvbXBvbmVudDxEPj47XHJcbiAgLyoqIFRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSB0aW1lIHNlbGVjdCB3YXMgb3BlbmVkLiAqL1xyXG4gIHByaXZhdGUgX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3BlbjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfc2Nyb2xsU3RyYXRlZ3k6ICgpID0+IFNjcm9sbFN0cmF0ZWd5O1xyXG5cclxuICAvKiogVGhlIGlucHV0IGVsZW1lbnQgdGhpcyB0aW1lIHNlbGVjdCBpcyBhc3NvY2lhdGVkIHdpdGguICovXHJcbiAgX3RpbWVTZWxlY3RJbnB1dDogTWF0VGltZVNlbGVjdElucHV0RGlyZWN0aXZlPEQ+O1xyXG5cclxuICAvKiogRW1pdHMgd2hlbiB0aGUgdGltZSBzZWxlY3QgaGFzIGJlZW4gb3BlbmVkLiAqL1xyXG4gIEBPdXRwdXQoJ29wZW4nKSBvcGVuU3RyZWFtOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHRpbWUgc2VsZWN0IGhhcyBiZWVuIGNsb3NlZC4gKi9cclxuICBAT3V0cHV0KCdjbG9zZScpIGNsb3NlU3RyZWFtOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG4gIC8qKiBUaGUgaWQgZm9yIHRoZSB0aW1lIHNlbGVjdCBwb3B1cC4gKi9cclxuICBpZCA9IGBtYXQtdGltZS1zZWxlY3QtJHt0aW1lU2VsZWN0VWlkKyt9YDtcclxuXHJcbiAgLyoqIFRoZSBpbml0aWFsIHRpbWUgb2YgdGhlIHRpbWUgc2VsZWN0LiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IHN0YXJ0QXQoKTogRCB8IG51bGwgeyByZXR1cm4gdGhpcy5fc3RhcnRBdCB8fCAodGhpcy5fdGltZVNlbGVjdElucHV0ID8gdGhpcy5fdGltZVNlbGVjdElucHV0LnZhbHVlIDogbnVsbCk7IH1cclxuICBzZXQgc3RhcnRBdCh2YWx1ZTogRCB8IG51bGwpIHsgdGhpcy5fc3RhcnRBdCA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aGlzLl90aW1lQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSkpOyB9XHJcblxyXG4gIC8qKiBUaGUgY29sb3IgcGFsZXR0ZSB0byB1c2Ugb24gdGhlIHRpbWUgc2VsZWN0IHBvcHVwLiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IGNvbG9yKCk6IFRoZW1lUGFsZXR0ZSB7IHJldHVybiB0aGlzLl9jb2xvciB8fCAodGhpcy5fdGltZVNlbGVjdElucHV0ID8gdGhpcy5fdGltZVNlbGVjdElucHV0LmdldFRoZW1lUGFsZXR0ZSgpIDogdW5kZWZpbmVkKTsgfVxyXG4gIHNldCBjb2xvcih2YWx1ZTogVGhlbWVQYWxldHRlKSB7IHRoaXMuX2NvbG9yID0gdmFsdWU7IH1cclxuXHJcbiAgLyoqIFdoZXRoZXIgdGhlIHRpbWUgc2VsZWN0IHBvcC11cCBzaG91bGQgZGlzYWJsZWQuICovXHJcbiAgQElucHV0KClcclxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgIT09IHVuZGVmaW5lZCA/IHRoaXMuX2Rpc2FibGVkIDogKHRoaXMuX3RpbWVTZWxlY3RJbnB1dCA/IHRoaXMuX3RpbWVTZWxlY3RJbnB1dC5kaXNhYmxlZCA6IGZhbHNlKTtcclxuICB9XHJcbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICBjb25zdCBkaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XHJcbiAgICBpZiAodGhpcy5fZGlzYWJsZWQgIT09IGRpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMuX2Rpc2FibGVkID0gZGlzYWJsZWQ7XHJcbiAgICAgIHRoaXMuX2Rpc2FibGVkQ2hhbmdlLm5leHQoZGlzYWJsZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGltZS4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBzZWxlY3RlZCgpOiBEIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XHJcbiAgc2V0IHNlbGVjdGVkKHZhbHVlOiBEKSB7IHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7IH1cclxuXHJcbiAgLyoqIFdoZXRoZXIgdGhlIHRpbWUgc2VsZWN0IGlzIG9wZW5lZC4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBvcGVuZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9vcGVuZWQ7IH1cclxuICBzZXQgb3BlbmVkKHZhbHVlOiBib29sZWFuKSB7IHZhbHVlID8gdGhpcy5vcGVuKCkgOiBjbG9zZSgpOyB9XHJcblxyXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSB0aW1lIHNlbGVjdCBkaXNhYmxlZCBzdGF0ZSBoYXMgYmVlbiBjaGFuZ2VkLiAqL1xyXG4gIGdldCBkaXNhYmxlZENoYW5nZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpOyB9XHJcbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHRpbWUgc2VsZWN0IHNlbGVjdGVkIHRpbWUgaGFzIGJlZW4gY2hhbmdlZC4gKi9cclxuICBnZXQgc2VsZWN0ZWRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxEPiB7IHJldHVybiB0aGlzLl9zZWxlY3RlZENoYW5nZS5hc09ic2VydmFibGUoKTsgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3RvcixcclxuICAgICAgICAgICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcclxuICAgICAgICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoTUFUX1RJTUVfU0VMRUNUX1NDUk9MTF9TVFJBVEVHWSkgc2Nyb2xsU3RyYXRlZ3k6IGFueSxcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF90aW1lQWRhcHRlcjogVGltZUFkYXB0ZXI8RD4sXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eSxcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XHJcbiAgICBpZiAoIXRoaXMuX3RpbWVBZGFwdGVyKSB7XHJcbiAgICAgIHRocm93IGNyZWF0ZU1pc3NpbmdUaW1lSW1wbEVycm9yKCdUaW1lQWRhcHRlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5ID0gc2Nyb2xsU3RyYXRlZ3k7XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIHRoaXMuX2lucHV0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5jb21wbGV0ZSgpO1xyXG5cclxuICAgIGlmICh0aGlzLl9wb3B1cFJlZikge1xyXG4gICAgICB0aGlzLl9wb3B1cFJlZi5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX3BvcHVwQ29tcG9uZW50UmVmID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdHMgdGhlIGdpdmVuIHRpbWUuXHJcbiAgICogQHBhcmFtIHRpbWUgVGhlIGRhdGUgdGltZSB0byBzZWxlY3QuXHJcbiAgICovXHJcbiAgc2VsZWN0KHRpbWU6IEQpIHtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5zZWxlY3RlZDtcclxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdGltZUFkYXB0ZXIuY2xvbmUodGltZSk7XHJcbiAgICB0aGlzLnNlbGVjdGVkID0gdmFsdWU7XHJcbiAgICBpZiAoIXRoaXMuX3RpbWVBZGFwdGVyLnNhbWVUaW1lKG9sZFZhbHVlLCB2YWx1ZSkpIHtcclxuICAgICAgdGhpcy5fc2VsZWN0ZWRDaGFuZ2UubmV4dCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBpbnB1dCB3aXRoIHRoaXMgdGltZSBzZWxlY3QuXHJcbiAgICogQHBhcmFtIGlucHV0IFRoZSB0aW1lIHNlbGVjdCBpbnB1dCB0byByZWdpc3RlciB3aXRoIHRoaXMgdGltZSBzZWxlY3QuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJJbnB1dChpbnB1dDogTWF0VGltZVNlbGVjdElucHV0RGlyZWN0aXZlPEQ+KSB7XHJcbiAgICBpZiAodGhpcy5fdGltZVNlbGVjdElucHV0KSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdBIE1hdFRpbWVTZWxlY3QgY2FuIG9ubHkgYmUgYXNzb2NpYXRlZCB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdGltZVNlbGVjdElucHV0ID0gaW5wdXQ7XHJcbiAgICB0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbiA9IHRoaXMuX3RpbWVTZWxlY3RJbnB1dC52YWx1ZUNoYW5nZS5zdWJzY3JpYmUoKHZhbHVlOiBEIHwgbnVsbCkgPT4gdGhpcy5zZWxlY3RlZCA9IHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKiBPcGVuIHRoZSB0aW1lIHNlbGVjdC4gKi9cclxuICBvcGVuKCkge1xyXG4gICAgaWYgKHRoaXMuX29wZW5lZCB8fCB0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5fdGltZVNlbGVjdElucHV0KSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdBdHRlbXB0ZWQgdG8gb3BlbiBhbiBNYXRUaW1lU2VsZWN0IHdpdGggbm8gYXNzb2NpYXRlZCBpbnB1dC4nKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xyXG4gICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4gPSB0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX29wZW5Bc1BvcHVwKCk7XHJcbiAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5vcGVuU3RyZWFtLmVtaXQoKTtcclxuICB9XHJcblxyXG4gIC8qKiBDbG9zZSB0aGUgdGltZSBzZWxlY3QuICovXHJcbiAgY2xvc2UoKSB7XHJcbiAgICBpZiAoIXRoaXMuX29wZW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fcG9wdXBSZWYgJiYgdGhpcy5fcG9wdXBSZWYuaGFzQXR0YWNoZWQoKSkge1xyXG4gICAgICB0aGlzLl9wb3B1cFJlZi5kZXRhY2goKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9wb3B1cENvbXBvbmVudFBvcnRhbCAmJiB0aGlzLl9wb3B1cENvbXBvbmVudFBvcnRhbC5pc0F0dGFjaGVkKSB7XHJcbiAgICAgIHRoaXMuX3BvcHVwQ29tcG9uZW50UG9ydGFsLmRldGFjaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbXBsZXRlQ2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgIC8vIFRoZSBgX29wZW5lZGAgY291bGQndmUgYmVlbiByZXNldCBhbHJlYWR5IGlmXHJcbiAgICAgIC8vIHdlIGdvdCB0d28gZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24uXHJcbiAgICAgIGlmICh0aGlzLl9vcGVuZWQpIHtcclxuICAgICAgICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNsb3NlU3RyZWFtLmVtaXQoKTtcclxuICAgICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4gPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4gJiYgdHlwZW9mIHRoaXMuX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3Blbi5mb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBCZWNhdXNlIElFIG1vdmVzIGZvY3VzIGFzeW5jaHJvbm91c2x5LCB3ZSBjYW4ndCBjb3VudCBvbiBpdCBiZWluZyByZXN0b3JlZCBiZWZvcmUgd2UndmVcclxuICAgICAgLy8gbWFya2VkIHRoZSB0aW1lIHNlbGVjdCBhcyBjbG9zZWQuIElmIHRoZSBldmVudCBmaXJlcyBvdXQgb2Ygc2VxdWVuY2UgYW5kIHRoZSBlbGVtZW50IHRoYXRcclxuICAgICAgLy8gd2UncmUgcmVmb2N1c2luZyBvcGVucyB0aGUgdGltZSBzZWxlY3Qgb24gZm9jdXMsIHRoZSB1c2VyIGNvdWxkIGJlIHN0dWNrIHdpdGggbm90IGJlaW5nXHJcbiAgICAgIC8vIGFibGUgdG8gY2xvc2UgdGhlIHNlbGVjdCBwYW5lbCBhdCBhbGwuIFdlIHdvcmsgYXJvdW5kIGl0IGJ5IG1ha2luZyB0aGUgbG9naWMsIHRoYXQgbWFya3NcclxuICAgICAgLy8gdGhlIHRpbWUgc2VsZWN0IGFzIGNsb3NlZCwgYXN5bmMgYXMgd2VsbC5cclxuICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuLmZvY3VzKCk7XHJcbiAgICAgIHNldFRpbWVvdXQoY29tcGxldGVDbG9zZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb21wbGV0ZUNsb3NlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogT3BlbiB0aGUgdGltZSBzZWxlY3QgYXMgYSBwb3B1cC4gKi9cclxuICBwcml2YXRlIF9vcGVuQXNQb3B1cCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3BvcHVwQ29tcG9uZW50UG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbDxNYXRUaW1lU2VsZWN0Q29udGVudENvbXBvbmVudDxEPj4oXHJcbiAgICAgIE1hdFRpbWVTZWxlY3RDb250ZW50Q29tcG9uZW50LFxyXG4gICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLFxyXG4gICAgICB0aGlzLl9jcmVhdGVJbmplY3RvcigpXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghdGhpcy5fcG9wdXBSZWYpIHtcclxuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX3BvcHVwUmVmLmhhc0F0dGFjaGVkKCkpIHtcclxuICAgICAgdGhpcy5fcG9wdXBDb21wb25lbnRSZWYgPSB0aGlzLl9wb3B1cFJlZi5hdHRhY2godGhpcy5fcG9wdXBDb21wb25lbnRQb3J0YWwpO1xyXG4gICAgICB0aGlzLl9wb3B1cENvbXBvbmVudFJlZi5pbnN0YW5jZS52YWx1ZUNoYW5nZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgKHZhbHVlOiBNb21lbnQpID0+IHRoaXMuc2VsZWN0KHRoaXMuX3RpbWVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlLnRvSVNPU3RyaW5nKCkpKVxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLl9zZXRDb2xvcigpO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbiBvbmNlIHRoZSBzZWxlY3QgcGFuZWwgaGFzIHJlbmRlcmVkLlxyXG4gICAgICB0aGlzLl9uZ1pvbmUub25TdGFibGUuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX3BvcHVwUmVmLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIENyZWF0ZSBhIHBvcnRhbCBpbmplY3RvciB0byBpbmplY3QgdGltZSBzZWxlY3QgaW5pdGlhbCBkYXRhLiAqL1xyXG4gIHByaXZhdGUgX2NyZWF0ZUluamVjdG9yKCk6IFBvcnRhbEluamVjdG9yIHtcclxuICAgIGNvbnN0IGRhdGE6IE1hdFRpbWVTZWxlY3REYXRhPEQ+ID0ge1xyXG4gICAgICB2YWx1ZTogdGhpcy5zdGFydEF0LFxyXG4gICAgICBtaW5UaW1lOiB0aGlzLl90aW1lU2VsZWN0SW5wdXQgJiYgdGhpcy5fdGltZVNlbGVjdElucHV0Lm1pbixcclxuICAgICAgbWF4VGltZTogdGhpcy5fdGltZVNlbGVjdElucHV0ICYmIHRoaXMuX3RpbWVTZWxlY3RJbnB1dC5tYXhcclxuICAgIH07XHJcbiAgICBjb25zdCBpbmplY3RvclRva2VucyA9IG5ldyBXZWFrTWFwPGFueSwgYW55PihbXHJcbiAgICAgIFtNQVRfVElNRV9TRUxFQ1RfREFUQSwgZGF0YV1cclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIG5ldyBQb3J0YWxJbmplY3Rvcih0aGlzLl9pbmplY3RvciwgaW5qZWN0b3JUb2tlbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENyZWF0ZSB0aGUgcG9wdXAuICovXHJcbiAgcHJpdmF0ZSBfY3JlYXRlUG9wdXAoKTogdm9pZCB7XHJcbiAgICBjb25zdCBvdmVybGF5Q29uZmlnID0gbmV3IE92ZXJsYXlDb25maWcoe1xyXG4gICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLl9jcmVhdGVQb3B1cFBvc2l0aW9uU3RyYXRlZ3koKSxcclxuICAgICAgaGFzQmFja2Ryb3A6IHRydWUsXHJcbiAgICAgIGJhY2tkcm9wQ2xhc3M6ICdtYXQtb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCcsXHJcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5fZGlyLFxyXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fc2Nyb2xsU3RyYXRlZ3koKSxcclxuICAgICAgcGFuZWxDbGFzczogJ21hdC10aW1lLXNlbGVjdC1wb3B1cCcsXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9wb3B1cFJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKG92ZXJsYXlDb25maWcpO1xyXG4gICAgdGhpcy5fcG9wdXBSZWYub3ZlcmxheUVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xyXG5cclxuICAgIG1lcmdlKFxyXG4gICAgICB0aGlzLl9wb3B1cFJlZi5iYWNrZHJvcENsaWNrKCksXHJcbiAgICAgIHRoaXMuX3BvcHVwUmVmLmRldGFjaG1lbnRzKCksXHJcbiAgICAgIHRoaXMuX3BvcHVwUmVmLmtleWRvd25FdmVudHMoKS5waXBlKGZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgLy8gQ2xvc2luZyBvbiBhbHQgKyB1cCBpcyBvbmx5IHZhbGlkIHdoZW4gdGhlcmUncyBhbiBpbnB1dCBhc3NvY2lhdGVkIHdpdGggdGhlIHRpbWUgc2VsZWN0LlxyXG4gICAgICAgIHJldHVybiBldmVudC5rZXlDb2RlID09PSBFU0NBUEUgfHxcclxuICAgICAgICAgICh0aGlzLl90aW1lU2VsZWN0SW5wdXQgJiYgZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09IFVQX0FSUk9XKTtcclxuICAgICAgfSkpXHJcbiAgICApLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENyZWF0ZSB0aGUgcG9wdXAgcG9zaXRpb24gc3RyYXRlZ3kuICovXHJcbiAgcHJpdmF0ZSBfY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5KCk6IFBvc2l0aW9uU3RyYXRlZ3kge1xyXG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxyXG4gICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyh0aGlzLl90aW1lU2VsZWN0SW5wdXQuZ2V0Q29ubmVjdGVkT3ZlcmxheU9yaWdpbigpKVxyXG4gICAgICAud2l0aFRyYW5zZm9ybU9yaWdpbk9uKCcubWF0LXRpbWUtc2VsZWN0LWNvbnRlbnQnKVxyXG4gICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcclxuICAgICAgLndpdGhWaWV3cG9ydE1hcmdpbig4KVxyXG4gICAgICAud2l0aExvY2tlZFBvc2l0aW9uKClcclxuICAgICAgLndpdGhQb3NpdGlvbnMoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIG9yaWdpblg6ICdzdGFydCcsXHJcbiAgICAgICAgICBvcmlnaW5ZOiAnYm90dG9tJyxcclxuICAgICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxyXG4gICAgICAgICAgb3ZlcmxheVk6ICd0b3AnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxyXG4gICAgICAgICAgb3JpZ2luWTogJ3RvcCcsXHJcbiAgICAgICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcclxuICAgICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgb3JpZ2luWDogJ2VuZCcsXHJcbiAgICAgICAgICBvcmlnaW5ZOiAnYm90dG9tJyxcclxuICAgICAgICAgIG92ZXJsYXlYOiAnZW5kJyxcclxuICAgICAgICAgIG92ZXJsYXlZOiAndG9wJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgb3JpZ2luWDogJ2VuZCcsXHJcbiAgICAgICAgICBvcmlnaW5ZOiAndG9wJyxcclxuICAgICAgICAgIG92ZXJsYXlYOiAnZW5kJyxcclxuICAgICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJ1xyXG4gICAgICAgIH1cclxuICAgICAgXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMgVGhlIGdpdmVuIG9iamVjdCBpZiBpdCBpcyBib3RoIGEgZGF0ZSBpbnN0YW5jZSBhbmQgdmFsaWQsIG90aGVyd2lzZSBudWxsLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldFZhbGlkRGF0ZU9yTnVsbChvYmo6IGFueSk6IEQgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLl90aW1lQWRhcHRlci5pc0RhdGVJbnN0YW5jZShvYmopICYmIHRoaXMuX3RpbWVBZGFwdGVyLmlzVmFsaWQob2JqKSA/IG9iaiA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogUGFzc2VzIHRoZSBjdXJyZW50IHRoZW1lIGNvbG9yIGFsb25nIHRvIHRoZSB0aW1lIHNlbGVjdCBvdmVybGF5LiAqL1xyXG4gIHByaXZhdGUgX3NldENvbG9yKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX3BvcHVwQ29tcG9uZW50UmVmKSB7XHJcbiAgICAgIHRoaXMuX3BvcHVwQ29tcG9uZW50UmVmLmluc3RhbmNlLmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiJdfQ==