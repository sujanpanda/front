/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, forwardRef, HostBinding, HostListener, Inject, Input, Optional, Output } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { DOWN_ARROW } from '@angular/cdk/keycodes';
import { MAT_INPUT_VALUE_ACCESSOR, MatFormField } from '@angular/material';
import { Subject, Subscription } from 'rxjs';
import { TimeAdapter } from './time-adapter.service';
import { MAT_TIME_FORMATS } from './time-formats';
import { MatTimeSelectComponent } from './time-select.component';
/**
 * An event used for time select input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use MatTimeSelectInputEvent instead.
 * @template D
 */
export class MatTimeSelectInputEvent {
    /**
     * @param {?} target
     * @param {?} targetElement
     */
    constructor(target, targetElement) {
        this.target = target;
        this.targetElement = targetElement;
        this.value = this.target.value;
    }
}
if (false) {
    /**
     * The new value for the target time select input.
     * @type {?}
     */
    MatTimeSelectInputEvent.prototype.value;
    /**
     * Reference to the time select input component that emitted the event.
     * @type {?}
     */
    MatTimeSelectInputEvent.prototype.target;
    /**
     * Reference to the native input element associated with the time select input.
     * @type {?}
     */
    MatTimeSelectInputEvent.prototype.targetElement;
}
/**
 * Directive used to connect an input to a MatTimeSelectComponent.
 * @template D
 */
export class MatTimeSelectInputDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _timeAdapter
     * @param {?} _timeFormats
     * @param {?} _formField
     */
    constructor(_elementRef, _timeAdapter, _timeFormats, _formField) {
        this._elementRef = _elementRef;
        this._timeAdapter = _timeAdapter;
        this._timeFormats = _timeFormats;
        this._formField = _formField;
        this._timeSelectSubscription = Subscription.EMPTY;
        this._localeSubscription = Subscription.EMPTY;
        this._valueChange = new Subject();
        this._disabledChange = new Subject();
        /**
         * Emits when a `change` event is fired on this `<input>`.
         */
        this.timeChange = new EventEmitter();
        /**
         * Emits when an `input` event is fired on this `<input>`.
         */
        this.timeInput = new EventEmitter();
        /**
         * Emits when the value changes (either due to user input or programmatic change).
         */
        this.valueChange = this._valueChange.asObservable();
        /**
         * Emits when the disabled state has changed.
         */
        this.disabledChange = this._disabledChange.asObservable();
        this._onChange = () => { };
        this._onTouched = () => { };
        this._onValidatorChange = () => { };
        this._parseValidator = () => {
            return this._lastValueValid ? null : { 'matTimeSelectParse': { 'text': this._elementRef.nativeElement.value } };
        };
        this._minValidator = (control) => {
            /** @type {?} */
            const value = this._getValidDateOrNull(this._timeAdapter.deserialize(control.value));
            return !this.min || !value || this._timeAdapter.compareTime(this.min, value) <= 0 ?
                null : { 'matTimeSelectMin': { 'min': this.min, 'actual': value } };
        };
        this._maxValidator = (control) => {
            /** @type {?} */
            const value = this._getValidDateOrNull(this._timeAdapter.deserialize(control.value));
            return !this.max || !value || this._timeAdapter.compareTime(this.max, value) >= 0 ?
                null : { 'matTimeSelectMax': { 'max': this.max, 'actual': value } };
        };
        this._validator = Validators.compose([
            this._parseValidator,
            this._minValidator,
            this._maxValidator
        ]);
        this._localeSubscription = this._timeAdapter.localeChanges.subscribe(() => this.value = this.value);
    }
    /**
     * The time select that this input is associated with.
     * @param {?} value
     * @return {?}
     */
    set matTimeSelect(value) {
        if (!value) {
            return;
        }
        this._timeSelect = value;
        this._timeSelect.registerInput(this);
        this._timeSelectSubscription.unsubscribe();
        this._timeSelectSubscription = this._timeSelect.selectedChange.subscribe((selected) => {
            this.value = selected;
            this._onChange(selected);
            this._onTouched();
            this.timeInput.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
            this.timeChange.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
        });
    }
    /**
     * The value of the input.
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        value = this._timeAdapter.deserialize(value);
        this._lastValueValid = !value || this._timeAdapter.isValid(value);
        value = this._getValidDateOrNull(value);
        /** @type {?} */
        const oldValue = this._value;
        this._value = value;
        this._formatValue(value);
        if (!this._timeAdapter.sameTime(oldValue, value)) {
            this._valueChange.next(value);
        }
    }
    /**
     * The minimum valid date time.
     * @return {?}
     */
    get min() { return this._min; }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
        this._onValidatorChange();
    }
    /**
     * The maximum valid date time.
     * @return {?}
     */
    get max() { return this._max; }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
        this._onValidatorChange();
    }
    /**
     * Whether the time select input is disabled.
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const disabled = coerceBooleanProperty(value);
        /** @type {?} */
        const element = this._elementRef.nativeElement;
        if (this.disabled !== disabled) {
            this._disabled = disabled;
            this._disabledChange.next(disabled);
        }
        if (disabled && element.blur) {
            element.blur();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get _ariaHasPopup() { return true; }
    /**
     * \@docs-private
     * @return {?}
     */
    get _ariaOwns() { return (this._timeSelect && this._timeSelect.opened && !!this._timeSelect.id) || null; }
    /**
     * \@docs-private
     * @return {?}
     */
    get _minTime() { return this.min ? this._timeAdapter.toIso8601(this.min) : null; }
    /**
     * \@docs-private
     * @return {?}
     */
    get _maxTime() { return this.max ? this._timeAdapter.toIso8601(this.max) : null; }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._timeSelectSubscription.unsubscribe();
        this._localeSubscription.unsubscribe();
        this._valueChange.complete();
        this._disabledChange.complete();
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        return this._validator ? this._validator(control) : null;
    }
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this._onValidatorChange = fn;
    }
    /**
     * Handle keydown event.
     * @param {?} event The event object.
     * @return {?}
     */
    onKeydown(event) {
        /** @type {?} */
        const isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;
        if (this._timeSelect && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
            this._timeSelect.open();
            event.preventDefault();
        }
    }
    /**
     * Handle input event.
     * @param {?} value The current value of the input.
     * @return {?}
     */
    onInput(value) {
        /** @type {?} */
        let time = this._timeAdapter.parse(value, this._timeFormats.parse.timeInput);
        this._lastValueValid = !time || this._timeAdapter.isValid(time);
        time = this._getValidDateOrNull(time);
        if (!this._timeAdapter.sameTime(this._value, time)) {
            this._value = time;
            this._onChange(time);
            this._valueChange.next(time);
            this.timeInput.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
        }
    }
    /**
     * Handle change event.
     * @return {?}
     */
    onChange() {
        this.timeChange.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
    }
    /**
     * Handle blur event.
     * @return {?}
     */
    onBlur() {
        if (this.value) {
            this._formatValue(this.value);
        }
        this._onTouched();
    }
    /**
     * Returns the palette used by the input's form field, if any.
     * @return {?}
     */
    getThemePalette() {
        return this._formField ? this._formField.color : undefined;
    }
    /**
     * Gets the element that the time select popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    getConnectedOverlayOrigin() {
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
    }
    /**
     * Formats a value and sets it on the input element.
     * @private
     * @param {?} value
     * @return {?}
     */
    _formatValue(value) {
        this._elementRef.nativeElement.value = value ? this._timeAdapter.format(value, this._timeFormats.display.timeInput) : '';
    }
    /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    _getValidDateOrNull(obj) {
        return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
    }
}
MatTimeSelectInputDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[matTimeSelect]',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => MatTimeSelectInputDirective), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatTimeSelectInputDirective), multi: true },
                    { provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: MatTimeSelectInputDirective }
                ],
                exportAs: 'matTimeSelectInput'
            },] }
];
/** @nocollapse */
MatTimeSelectInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: TimeAdapter, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TIME_FORMATS,] }] },
    { type: MatFormField, decorators: [{ type: Optional }] }
];
MatTimeSelectInputDirective.propDecorators = {
    timeChange: [{ type: Output }],
    timeInput: [{ type: Output }],
    matTimeSelect: [{ type: Input }],
    value: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    disabled: [{ type: HostBinding }, { type: Input }],
    _ariaHasPopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    _ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
    _minTime: [{ type: HostBinding, args: ['attr.min',] }],
    _maxTime: [{ type: HostBinding, args: ['attr.max',] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    onChange: [{ type: HostListener, args: ['change',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeSelectSubscription;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._localeSubscription;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeSelect;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._value;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._min;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._max;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._valueChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._disabledChange;
    /**
     * The form control validator for whether the input parses.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._parseValidator;
    /**
     * The form control validator for the min date time.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._minValidator;
    /**
     * The form control validator for the max date time.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._maxValidator;
    /**
     * The combined form control validator for this input.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._validator;
    /**
     * Whether the last value set on the input was valid.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._lastValueValid;
    /**
     * Emits when a `change` event is fired on this `<input>`.
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.timeChange;
    /**
     * Emits when an `input` event is fired on this `<input>`.
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.timeInput;
    /**
     * Emits when the value changes (either due to user input or programmatic change).
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.valueChange;
    /**
     * Emits when the disabled state has changed.
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.disabledChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._onChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._onValidatorChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeAdapter;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeFormats;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._formField;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1zZWxlY3QtaW5wdXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hdGVyaWFsLXRpbWUtc2VsZWN0LyIsInNvdXJjZXMiOlsibGliL3RpbWUtc2VsZWN0LWlucHV0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFVBQVUsRUFDVixXQUFXLEVBQ1gsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBRUwsUUFBUSxFQUNSLE1BQU0sRUFDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBR0wsYUFBYSxFQUNiLGlCQUFpQixFQUlqQixVQUFVLEVBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDakQsT0FBTyxFQUFDLHdCQUF3QixFQUFFLFlBQVksRUFBZSxNQUFNLG1CQUFtQixDQUFDO0FBQ3ZGLE9BQU8sRUFBYSxPQUFPLEVBQUUsWUFBWSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ3ZELE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsZ0JBQWdCLEVBQWlCLE1BQU0sZ0JBQWdCLENBQUM7QUFDaEUsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0seUJBQXlCLENBQUM7Ozs7Ozs7QUFPL0QsTUFBTSxPQUFPLHVCQUF1Qjs7Ozs7SUFLbEMsWUFFUyxNQUFzQyxFQUV0QyxhQUEwQjtRQUYxQixXQUFNLEdBQU4sTUFBTSxDQUFnQztRQUV0QyxrQkFBYSxHQUFiLGFBQWEsQ0FBYTtRQUNqQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2pDLENBQUM7Q0FFRjs7Ozs7O0lBVkMsd0NB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Ozs7OztJQUNoRCxtREFBMEU7Ozs7O0lBQzFFLGlEQUE0QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIGZvcndhcmRSZWYsXHJcbiAgSG9zdEJpbmRpbmcsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIEluamVjdCxcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3B0aW9uYWwsXHJcbiAgT3V0cHV0XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgQWJzdHJhY3RDb250cm9sLFxyXG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxyXG4gIE5HX1ZBTElEQVRPUlMsXHJcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgVmFsaWRhdGlvbkVycm9ycyxcclxuICBWYWxpZGF0b3IsXHJcbiAgVmFsaWRhdG9yRm4sXHJcbiAgVmFsaWRhdG9yc1xyXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHtjb2VyY2VCb29sZWFuUHJvcGVydHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7RE9XTl9BUlJPV30gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcclxuaW1wb3J0IHtNQVRfSU5QVVRfVkFMVUVfQUNDRVNTT1IsIE1hdEZvcm1GaWVsZCwgVGhlbWVQYWxldHRlfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtUaW1lQWRhcHRlcn0gZnJvbSAnLi90aW1lLWFkYXB0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7TUFUX1RJTUVfRk9STUFUUywgTWF0VGltZUZvcm1hdHN9IGZyb20gJy4vdGltZS1mb3JtYXRzJztcclxuaW1wb3J0IHtNYXRUaW1lU2VsZWN0Q29tcG9uZW50fSBmcm9tICcuL3RpbWUtc2VsZWN0LmNvbXBvbmVudCc7XHJcblxyXG4vKipcclxuICogQW4gZXZlbnQgdXNlZCBmb3IgdGltZSBzZWxlY3QgaW5wdXQgYW5kIGNoYW5nZSBldmVudHMuIFdlIGRvbid0IGFsd2F5cyBoYXZlIGFjY2VzcyB0byBhIG5hdGl2ZVxyXG4gKiBpbnB1dCBvciBjaGFuZ2UgZXZlbnQgYmVjYXVzZSB0aGUgZXZlbnQgbWF5IGhhdmUgYmVlbiB0cmlnZ2VyZWQgYnkgdGhlIHVzZXIgY2xpY2tpbmcgb24gdGhlXHJcbiAqIGNhbGVuZGFyIHBvcHVwLiBGb3IgY29uc2lzdGVuY3ksIHdlIGFsd2F5cyB1c2UgTWF0VGltZVNlbGVjdElucHV0RXZlbnQgaW5zdGVhZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYXRUaW1lU2VsZWN0SW5wdXRFdmVudDxEPiB7XHJcblxyXG4gIC8qKiBUaGUgbmV3IHZhbHVlIGZvciB0aGUgdGFyZ2V0IHRpbWUgc2VsZWN0IGlucHV0LiAqL1xyXG4gIHZhbHVlOiBEO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHRpbWUgc2VsZWN0IGlucHV0IGNvbXBvbmVudCB0aGF0IGVtaXR0ZWQgdGhlIGV2ZW50LiAqL1xyXG4gICAgcHVibGljIHRhcmdldDogTWF0VGltZVNlbGVjdElucHV0RGlyZWN0aXZlPEQ+LFxyXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aW1lIHNlbGVjdCBpbnB1dC4gKi9cclxuICAgIHB1YmxpYyB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudGFyZ2V0LnZhbHVlO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbi8qKiBEaXJlY3RpdmUgdXNlZCB0byBjb25uZWN0IGFuIGlucHV0IHRvIGEgTWF0VGltZVNlbGVjdENvbXBvbmVudC4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdpbnB1dFttYXRUaW1lU2VsZWN0XScsXHJcbiAgcHJvdmlkZXJzOiBbXHJcbiAgICB7cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hdFRpbWVTZWxlY3RJbnB1dERpcmVjdGl2ZSksIG11bHRpOiB0cnVlfSxcclxuICAgIHtwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNYXRUaW1lU2VsZWN0SW5wdXREaXJlY3RpdmUpLCBtdWx0aTogdHJ1ZX0sXHJcbiAgICB7cHJvdmlkZTogTUFUX0lOUFVUX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogTWF0VGltZVNlbGVjdElucHV0RGlyZWN0aXZlfVxyXG4gIF0sXHJcbiAgZXhwb3J0QXM6ICdtYXRUaW1lU2VsZWN0SW5wdXQnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXRUaW1lU2VsZWN0SW5wdXREaXJlY3RpdmU8RD4gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xyXG5cclxuICBwcml2YXRlIF90aW1lU2VsZWN0U3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG4gIHByaXZhdGUgX2xvY2FsZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICBwcml2YXRlIF90aW1lU2VsZWN0OiBNYXRUaW1lU2VsZWN0Q29tcG9uZW50PEQ+O1xyXG5cclxuICBwcml2YXRlIF92YWx1ZTogRDtcclxuICBwcml2YXRlIF9taW46IEQ7XHJcbiAgcHJpdmF0ZSBfbWF4OiBEO1xyXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuO1xyXG5cclxuICBwcml2YXRlIF92YWx1ZUNoYW5nZTogU3ViamVjdDxEIHwgbnVsbD4gPSBuZXcgU3ViamVjdDxEIHwgbnVsbD4oKTtcclxuICBwcml2YXRlIF9kaXNhYmxlZENoYW5nZTogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XHJcblxyXG4gIC8qKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3Igd2hldGhlciB0aGUgaW5wdXQgcGFyc2VzLiAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3BhcnNlVmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtaW4gZGF0ZSB0aW1lLiAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX21pblZhbGlkYXRvcjogVmFsaWRhdG9yRm47XHJcbiAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgbWF4IGRhdGUgdGltZS4gKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IF9tYXhWYWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG4gIC8qKiBUaGUgY29tYmluZWQgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhpcyBpbnB1dC4gKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IF92YWxpZGF0b3I6IFZhbGlkYXRvckZuIHwgbnVsbDtcclxuXHJcbiAgLyoqIFdoZXRoZXIgdGhlIGxhc3QgdmFsdWUgc2V0IG9uIHRoZSBpbnB1dCB3YXMgdmFsaWQuICovXHJcbiAgcHJpdmF0ZSBfbGFzdFZhbHVlVmFsaWQ6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBFbWl0cyB3aGVuIGEgYGNoYW5nZWAgZXZlbnQgaXMgZmlyZWQgb24gdGhpcyBgPGlucHV0PmAuICovXHJcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHRpbWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXRUaW1lU2VsZWN0SW5wdXRFdmVudDxEPj4gPSBuZXcgRXZlbnRFbWl0dGVyPE1hdFRpbWVTZWxlY3RJbnB1dEV2ZW50PEQ+PigpO1xyXG4gIC8qKiBFbWl0cyB3aGVuIGFuIGBpbnB1dGAgZXZlbnQgaXMgZmlyZWQgb24gdGhpcyBgPGlucHV0PmAuICovXHJcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHRpbWVJbnB1dDogRXZlbnRFbWl0dGVyPE1hdFRpbWVTZWxlY3RJbnB1dEV2ZW50PEQ+PiA9IG5ldyBFdmVudEVtaXR0ZXI8TWF0VGltZVNlbGVjdElucHV0RXZlbnQ8RD4+KCk7XHJcblxyXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChlaXRoZXIgZHVlIHRvIHVzZXIgaW5wdXQgb3IgcHJvZ3JhbW1hdGljIGNoYW5nZSkuICovXHJcbiAgdmFsdWVDaGFuZ2U6IE9ic2VydmFibGU8RCB8IG51bGw+ID0gdGhpcy5fdmFsdWVDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XHJcbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGRpc2FibGVkIHN0YXRlIGhhcyBjaGFuZ2VkLiAqL1xyXG4gIGRpc2FibGVkQ2hhbmdlOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5fZGlzYWJsZWRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XHJcblxyXG4gIHByaXZhdGUgX29uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHt9O1xyXG4gIHByaXZhdGUgX29uVG91Y2hlZDogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xyXG4gIHByaXZhdGUgX29uVmFsaWRhdG9yQ2hhbmdlOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XHJcblxyXG4gIC8qKiBUaGUgdGltZSBzZWxlY3QgdGhhdCB0aGlzIGlucHV0IGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cclxuICBASW5wdXQoKVxyXG4gIHNldCBtYXRUaW1lU2VsZWN0KHZhbHVlOiBNYXRUaW1lU2VsZWN0Q29tcG9uZW50PEQ+KSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl90aW1lU2VsZWN0ID0gdmFsdWU7XHJcbiAgICB0aGlzLl90aW1lU2VsZWN0LnJlZ2lzdGVySW5wdXQodGhpcyk7XHJcbiAgICB0aGlzLl90aW1lU2VsZWN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgdGhpcy5fdGltZVNlbGVjdFN1YnNjcmlwdGlvbiA9IHRoaXMuX3RpbWVTZWxlY3Quc2VsZWN0ZWRDaGFuZ2Uuc3Vic2NyaWJlKChzZWxlY3RlZDogRCkgPT4ge1xyXG4gICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWQ7XHJcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHNlbGVjdGVkKTtcclxuICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XHJcbiAgICAgIHRoaXMudGltZUlucHV0LmVtaXQobmV3IE1hdFRpbWVTZWxlY3RJbnB1dEV2ZW50KHRoaXMsIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpO1xyXG4gICAgICB0aGlzLnRpbWVDaGFuZ2UuZW1pdChuZXcgTWF0VGltZVNlbGVjdElucHV0RXZlbnQodGhpcywgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBUaGUgdmFsdWUgb2YgdGhlIGlucHV0LiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IHZhbHVlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XHJcbiAgc2V0IHZhbHVlKHZhbHVlOiBEIHwgbnVsbCkge1xyXG4gICAgdmFsdWUgPSB0aGlzLl90aW1lQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSk7XHJcbiAgICB0aGlzLl9sYXN0VmFsdWVWYWxpZCA9ICF2YWx1ZSB8fCB0aGlzLl90aW1lQWRhcHRlci5pc1ZhbGlkKHZhbHVlKTtcclxuICAgIHZhbHVlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHZhbHVlKTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fdmFsdWU7XHJcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgdGhpcy5fZm9ybWF0VmFsdWUodmFsdWUpO1xyXG5cclxuICAgIGlmICghdGhpcy5fdGltZUFkYXB0ZXIuc2FtZVRpbWUob2xkVmFsdWUsIHZhbHVlKSkge1xyXG4gICAgICB0aGlzLl92YWx1ZUNoYW5nZS5uZXh0KHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBUaGUgbWluaW11bSB2YWxpZCBkYXRlIHRpbWUuICovXHJcbiAgQElucHV0KClcclxuICBnZXQgbWluKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21pbjsgfVxyXG4gIHNldCBtaW4odmFsdWU6IEQgfCBudWxsKSB7XHJcbiAgICB0aGlzLl9taW4gPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fdGltZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcclxuICAgIHRoaXMuX29uVmFsaWRhdG9yQ2hhbmdlKCk7XHJcbiAgfVxyXG5cclxuICAvKiogVGhlIG1heGltdW0gdmFsaWQgZGF0ZSB0aW1lLiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IG1heCgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl9tYXg7IH1cclxuICBzZXQgbWF4KHZhbHVlOiBEIHwgbnVsbCkge1xyXG4gICAgdGhpcy5fbWF4ID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX3RpbWVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XHJcbiAgICB0aGlzLl9vblZhbGlkYXRvckNoYW5nZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFdoZXRoZXIgdGhlIHRpbWUgc2VsZWN0IGlucHV0IGlzIGRpc2FibGVkLiAqL1xyXG4gIEBIb3N0QmluZGluZygpXHJcbiAgQElucHV0KClcclxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfVxyXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgY29uc3QgZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xyXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgIGlmICh0aGlzLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5uZXh0KGRpc2FibGVkKTtcclxuICAgIH1cclxuICAgIGlmIChkaXNhYmxlZCAmJiBlbGVtZW50LmJsdXIpIHtcclxuICAgICAgZWxlbWVudC5ibHVyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWhhc3BvcHVwJylcclxuICBnZXQgX2FyaWFIYXNQb3B1cCgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1vd25zJylcclxuICBnZXQgX2FyaWFPd25zKCk6IGJvb2xlYW4geyByZXR1cm4gKHRoaXMuX3RpbWVTZWxlY3QgJiYgdGhpcy5fdGltZVNlbGVjdC5vcGVuZWQgJiYgISF0aGlzLl90aW1lU2VsZWN0LmlkKSB8fCBudWxsOyB9XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLm1pbicpXHJcbiAgZ2V0IF9taW5UaW1lKCk6IHN0cmluZyB8IG51bGwgeyByZXR1cm4gdGhpcy5taW4gPyB0aGlzLl90aW1lQWRhcHRlci50b0lzbzg2MDEodGhpcy5taW4pIDogbnVsbDsgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIEBIb3N0QmluZGluZygnYXR0ci5tYXgnKVxyXG4gIGdldCBfbWF4VGltZSgpOiBzdHJpbmcgfCBudWxsIHsgcmV0dXJuIHRoaXMubWF4ID8gdGhpcy5fdGltZUFkYXB0ZXIudG9Jc284NjAxKHRoaXMubWF4KSA6IG51bGw7IH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MSW5wdXRFbGVtZW50PixcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF90aW1lQWRhcHRlcjogVGltZUFkYXB0ZXI8RD4sXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRfVElNRV9GT1JNQVRTKSBwcml2YXRlIF90aW1lRm9ybWF0czogTWF0VGltZUZvcm1hdHMsXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZm9ybUZpZWxkOiBNYXRGb3JtRmllbGQpIHtcclxuICAgIHRoaXMuX3BhcnNlVmFsaWRhdG9yID0gKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2xhc3RWYWx1ZVZhbGlkID8gbnVsbCA6IHsnbWF0VGltZVNlbGVjdFBhcnNlJzogeyd0ZXh0JzogdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlfX07XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX21pblZhbGlkYXRvciA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX3RpbWVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUpKTtcclxuICAgICAgcmV0dXJuICF0aGlzLm1pbiB8fCAhdmFsdWUgfHwgdGhpcy5fdGltZUFkYXB0ZXIuY29tcGFyZVRpbWUodGhpcy5taW4sIHZhbHVlKSA8PSAwID9cclxuICAgICAgICBudWxsIDogeydtYXRUaW1lU2VsZWN0TWluJzogeydtaW4nOiB0aGlzLm1pbiwgJ2FjdHVhbCc6IHZhbHVlfX07XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX21heFZhbGlkYXRvciA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX3RpbWVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUpKTtcclxuICAgICAgcmV0dXJuICF0aGlzLm1heCB8fCAhdmFsdWUgfHwgdGhpcy5fdGltZUFkYXB0ZXIuY29tcGFyZVRpbWUodGhpcy5tYXgsIHZhbHVlKSA+PSAwID9cclxuICAgICAgICBudWxsIDogeydtYXRUaW1lU2VsZWN0TWF4JzogeydtYXgnOiB0aGlzLm1heCwgJ2FjdHVhbCc6IHZhbHVlfX07XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbXHJcbiAgICAgIHRoaXMuX3BhcnNlVmFsaWRhdG9yLFxyXG4gICAgICB0aGlzLl9taW5WYWxpZGF0b3IsXHJcbiAgICAgIHRoaXMuX21heFZhbGlkYXRvclxyXG4gICAgXSk7XHJcblxyXG4gICAgdGhpcy5fbG9jYWxlU3Vic2NyaXB0aW9uID0gdGhpcy5fdGltZUFkYXB0ZXIubG9jYWxlQ2hhbmdlcy5zdWJzY3JpYmUoXHJcbiAgICAgICgpID0+IHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl90aW1lU2VsZWN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB0aGlzLl9sb2NhbGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cclxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXHJcbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xyXG4gIH1cclxuXHJcbiAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cclxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcclxuICB9XHJcblxyXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXHJcbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvciA/IHRoaXMuX3ZhbGlkYXRvcihjb250cm9sKSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgIHRoaXMuX29uVmFsaWRhdG9yQ2hhbmdlID0gZm47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUga2V5ZG93biBldmVudC5cclxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdC5cclxuICAgKi9cclxuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcclxuICBvbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgIGNvbnN0IGlzQWx0RG93bkFycm93ID0gZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09IERPV05fQVJST1c7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RpbWVTZWxlY3QgJiYgaXNBbHREb3duQXJyb3cgJiYgIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5yZWFkT25seSkge1xyXG4gICAgICB0aGlzLl90aW1lU2VsZWN0Lm9wZW4oKTtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBpbnB1dCBldmVudC5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlxyXG4gICAqL1xyXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pXHJcbiAgb25JbnB1dCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgdGltZSA9IHRoaXMuX3RpbWVBZGFwdGVyLnBhcnNlKHZhbHVlLCB0aGlzLl90aW1lRm9ybWF0cy5wYXJzZS50aW1lSW5wdXQpO1xyXG4gICAgdGhpcy5fbGFzdFZhbHVlVmFsaWQgPSAhdGltZSB8fCB0aGlzLl90aW1lQWRhcHRlci5pc1ZhbGlkKHRpbWUpO1xyXG4gICAgdGltZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aW1lKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3RpbWVBZGFwdGVyLnNhbWVUaW1lKHRoaXMuX3ZhbHVlLCB0aW1lKSkge1xyXG4gICAgICB0aGlzLl92YWx1ZSA9IHRpbWU7XHJcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHRpbWUpO1xyXG4gICAgICB0aGlzLl92YWx1ZUNoYW5nZS5uZXh0KHRpbWUpO1xyXG4gICAgICB0aGlzLnRpbWVJbnB1dC5lbWl0KG5ldyBNYXRUaW1lU2VsZWN0SW5wdXRFdmVudCh0aGlzLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBjaGFuZ2UgZXZlbnQuXHJcbiAgICovXHJcbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJylcclxuICBvbkNoYW5nZSgpIHtcclxuICAgIHRoaXMudGltZUNoYW5nZS5lbWl0KG5ldyBNYXRUaW1lU2VsZWN0SW5wdXRFdmVudCh0aGlzLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBibHVyIGV2ZW50LlxyXG4gICAqL1xyXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxyXG4gIG9uQmx1cigpIHtcclxuICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgIHRoaXMuX2Zvcm1hdFZhbHVlKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fb25Ub3VjaGVkKCk7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJucyB0aGUgcGFsZXR0ZSB1c2VkIGJ5IHRoZSBpbnB1dCdzIGZvcm0gZmllbGQsIGlmIGFueS4gKi9cclxuICBnZXRUaGVtZVBhbGV0dGUoKTogVGhlbWVQYWxldHRlIHtcclxuICAgIHJldHVybiB0aGlzLl9mb3JtRmllbGQgPyB0aGlzLl9mb3JtRmllbGQuY29sb3IgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBlbGVtZW50IHRoYXQgdGhlIHRpbWUgc2VsZWN0IHBvcHVwIHNob3VsZCBiZSBjb25uZWN0ZWQgdG8uXHJcbiAgICogQHJldHVybiBUaGUgZWxlbWVudCB0byBjb25uZWN0IHRoZSBwb3B1cCB0by5cclxuICAgKi9cclxuICBnZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCk6IEVsZW1lbnRSZWYge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Zvcm1GaWVsZCA/IHRoaXMuX2Zvcm1GaWVsZC5nZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCkgOiB0aGlzLl9lbGVtZW50UmVmO1xyXG4gIH1cclxuXHJcbiAgLyoqIEZvcm1hdHMgYSB2YWx1ZSBhbmQgc2V0cyBpdCBvbiB0aGUgaW5wdXQgZWxlbWVudC4gKi9cclxuICBwcml2YXRlIF9mb3JtYXRWYWx1ZSh2YWx1ZTogRCB8IG51bGwpIHtcclxuICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlID8gdGhpcy5fdGltZUFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aGlzLl90aW1lRm9ybWF0cy5kaXNwbGF5LnRpbWVJbnB1dCkgOiAnJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyBUaGUgZ2l2ZW4gb2JqZWN0IGlmIGl0IGlzIGJvdGggYSBkYXRlIGluc3RhbmNlIGFuZCB2YWxpZCwgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0VmFsaWREYXRlT3JOdWxsKG9iajogYW55KTogRCB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVBZGFwdGVyLmlzRGF0ZUluc3RhbmNlKG9iaikgJiYgdGhpcy5fdGltZUFkYXB0ZXIuaXNWYWxpZChvYmopID8gb2JqIDogbnVsbDtcclxuICB9XHJcblxyXG59XHJcbiJdfQ==