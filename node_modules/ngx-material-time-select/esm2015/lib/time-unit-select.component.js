/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Inject, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { TimeAdapter } from './time-adapter.service';
import { MAT_TIME_FORMATS } from './time-formats';
/**
 * Component used to select a value of a unit of time.
 * @template D
 */
export class MatTimeUnitSelectComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _timeAdapter
     * @param {?} _timeFormats
     */
    constructor(_changeDetectorRef, _timeAdapter, _timeFormats) {
        this._changeDetectorRef = _changeDetectorRef;
        this._timeAdapter = _timeAdapter;
        this._timeFormats = _timeFormats;
        /**
         * The list of all values of the time select.
         */
        this.options = [];
        /**
         * Emits when selected value has been changed. Output to enable support for two-way binding on `[(value)]`.
         */
        this.valueChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const unit = this.unit;
        /** @type {?} */
        const time = this._timeAdapter.createTime();
        /** @type {?} */
        const moment = this._timeAdapter.toMoment(time);
        /** @type {?} */
        const start = moment.clone().startOf('day');
        /** @type {?} */
        const end = moment.clone().endOf('day');
        /** @type {?} */
        const min = start.get(unit);
        /** @type {?} */
        const max = end.get(unit);
        /** @type {?} */
        const localeData = moment.localeData();
        /** @type {?} */
        const displayFormat = localeData.longDateFormat('LTS');
        /** @type {?} */
        const unitFormat = unit === 'hour' ?
            displayFormat.match(/hh?|HH?/g)[0] : unit === 'minute' ?
            displayFormat.match(/mm?/g)[0] : displayFormat.match(/ss?/g)[0];
        moment.set(unit, this.value);
        moment.subtract((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        for (let value = min; value <= max; value++) {
            moment.add((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
            this.options.push({ value: moment.get(unit), label: moment.format(unitFormat) });
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const element = this.panel.nativeElement;
        this._originTop = parseFloat(getComputedStyle(element).top);
        element.addEventListener('transitionend', () => {
            element.style.removeProperty('transition');
        });
        setTimeout(() => this.move(this.options.length / 2));
    }
    /**
     * Select the previous option.
     * @return {?}
     */
    prev() {
        this.move(-1);
    }
    /**
     * Select the next option.
     * @return {?}
     */
    next() {
        this.move(+1);
    }
    /**
     * Select the option moving by the given amount of step.
     * @param {?} step The amount of step to move.
     * @return {?}
     */
    move(step) {
        /** @type {?} */
        const element = this.panel.nativeElement;
        /** @type {?} */
        const option = element.querySelector('mat-time-unit-option');
        /** @type {?} */
        const optionHeight = parseFloat(getComputedStyle(option).height);
        /** @type {?} */
        const currentTop = parseFloat(getComputedStyle(element).top);
        /** @type {?} */
        const targetTop = currentTop + (step * optionHeight);
        /** @type {?} */
        const y = this._originTop - targetTop;
        element.style.top = `${targetTop}px`;
        if (step < 0) {
            // Move last option to the top
            for (let i = 0; i > step; i--) {
                this.options.unshift(this.options.pop());
            }
        }
        else if (step > 0) {
            // Move first option to the bottom
            for (let i = 0; i < step; i++) {
                this.options.push(this.options.shift());
            }
        }
        this.value = this.options[(this.options.length / 2)].value;
        this.valueChange.emit(this.value);
        element.style.transition = 'transform 0.5s';
        element.style.transform = `translateY(${y}px)`;
    }
    /**
     * Gets the previous option value.
     * @return {?}
     */
    getPrev() {
        return this.options[(this.options.length / 2) - 1].value;
    }
    /**
     * Gets the next option value.
     * @return {?}
     */
    getNext() {
        return this.options[(this.options.length / 2) + 1].value;
    }
    /**
     * Whether the given value is valid.
     * @param {?} value The value to check.
     * @return {?}
     */
    isValid(value) {
        return (this.min === null || value >= this.min) && (this.max === null || value <= this.max);
    }
}
MatTimeUnitSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-unit-select',
                template: "<div class=\"mat-time-unit-select-carousel\">\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-prev\" mat-icon-button aria-label=\"Previous\" [disabled]=\"!isValid(getPrev())\" (click)=\"prev()\">\r\n    <mat-icon>keyboard_arrow_up</mat-icon>\r\n  </button>\r\n  <div class=\"mat-time-unit-select-mask\">\r\n    <div #panel class=\"mat-time-unit-select-panel\">\r\n      <mat-time-unit-option *ngFor=\"let option of options\" [value]=\"option.value\" [disabled]=\"!isValid(option.value)\"> {{ option.label }} </mat-time-unit-option>\r\n    </div>\r\n  </div>\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-next\" mat-icon-button aria-label=\"Next\" [disabled]=\"!isValid(getNext())\" (click)=\"next()\">\r\n    <mat-icon>keyboard_arrow_down</mat-icon>\r\n  </button>\r\n</div>\r\n",
                exportAs: 'matTimeSelect',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["mat-time-unit-select{display:block;height:100%}mat-time-unit-select .mat-time-unit-select-carousel{display:flex;flex-direction:column;align-items:center;height:100%}mat-time-unit-select .mat-time-unit-select-mask{flex:auto;max-height:120px;width:100%;overflow:hidden}"]
            }] }
];
/** @nocollapse */
MatTimeUnitSelectComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: TimeAdapter },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_TIME_FORMATS,] }] }
];
MatTimeUnitSelectComponent.propDecorators = {
    value: [{ type: Input }],
    unit: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    valueChange: [{ type: Output }],
    panel: [{ type: ViewChild, args: ['panel',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._originTop;
    /**
     * The currently selected value.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.value;
    /**
     * The unit of time of the time select.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.unit;
    /**
     * The minimum selectable value.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.min;
    /**
     * The maximum selectable value.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.max;
    /**
     * The list of all values of the time select.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.options;
    /**
     * Emits when selected value has been changed. Output to enable support for two-way binding on `[(value)]`.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.valueChange;
    /**
     * The panel element containing all time select options.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.panel;
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._timeAdapter;
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._timeFormats;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS11bml0LXNlbGVjdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbWF0ZXJpYWwtdGltZS1zZWxlY3QvIiwic291cmNlcyI6WyJsaWIvdGltZS11bml0LXNlbGVjdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBRUwsTUFBTSxFQUNOLFNBQVMsRUFDVCxpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQ25ELE9BQU8sRUFBQyxnQkFBZ0IsRUFBaUIsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFXaEUsTUFBTSxPQUFPLDBCQUEwQjs7Ozs7O0lBc0JyQyxZQUFvQixrQkFBcUMsRUFDckMsWUFBNEIsRUFDRixZQUE0QjtRQUZ0RCx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBQ3JDLGlCQUFZLEdBQVosWUFBWSxDQUFnQjtRQUNGLGlCQUFZLEdBQVosWUFBWSxDQUFnQjs7OztRQVYxRSxZQUFPLEdBQXFDLEVBQUUsQ0FBQzs7OztRQUdyQyxnQkFBVyxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO0lBT0ssQ0FBQzs7OztJQUUvRSxRQUFROztjQUNBLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSTs7Y0FDaEIsSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFOztjQUNyQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDOztjQUN6QyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7O2NBQ3JDLEdBQUcsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsS0FB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QUMsS0FBSyxDQUFDO0lBQzNELENBQUM7Ozs7OztJQU1ELE9BQU8sQ0FBQyxLQUFhO1FBQ25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5RixDQUFDOzs7WUEvSEYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxzQkFBc0I7Z0JBQ2hDLGswQkFBZ0Q7Z0JBRWhELFFBQVEsRUFBRSxlQUFlO2dCQUN6QixhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O2FBQ2hEOzs7O1lBdkJDLGlCQUFpQjtZQVlYLFdBQVc7NENBb0NKLE1BQU0sU0FBQyxnQkFBZ0I7OztvQkFuQm5DLEtBQUs7bUJBRUwsS0FBSztrQkFFTCxLQUFLO2tCQUVMLEtBQUs7MEJBTUwsTUFBTTtvQkFHTixTQUFTLFNBQUMsT0FBTzs7Ozs7OztJQWxCbEIsZ0RBQTJCOzs7OztJQUczQiwyQ0FBdUI7Ozs7O0lBRXZCLDBDQUE4Qjs7Ozs7SUFFOUIseUNBQTRCOzs7OztJQUU1Qix5Q0FBNEI7Ozs7O0lBRzVCLDZDQUErQzs7Ozs7SUFHL0MsaURBQXlFOzs7OztJQUd6RSwyQ0FBbUQ7Ozs7O0lBRXZDLHdEQUE2Qzs7Ozs7SUFDN0Msa0RBQW9DOzs7OztJQUNwQyxrREFBOEQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIEFmdGVyVmlld0luaXQsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgQ29tcG9uZW50LFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEluamVjdCxcclxuICBJbnB1dCxcclxuICBPbkluaXQsXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDaGlsZCxcclxuICBWaWV3RW5jYXBzdWxhdGlvblxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0R1cmF0aW9uSW5wdXRBcmcxLCBEdXJhdGlvbklucHV0QXJnMiwgdW5pdE9mVGltZX0gZnJvbSAnbW9tZW50JztcclxuaW1wb3J0IHtUaW1lQWRhcHRlcn0gZnJvbSAnLi90aW1lLWFkYXB0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7TUFUX1RJTUVfRk9STUFUUywgTWF0VGltZUZvcm1hdHN9IGZyb20gJy4vdGltZS1mb3JtYXRzJztcclxuXHJcbi8qKiBDb21wb25lbnQgdXNlZCB0byBzZWxlY3QgYSB2YWx1ZSBvZiBhIHVuaXQgb2YgdGltZS4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdtYXQtdGltZS11bml0LXNlbGVjdCcsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL3RpbWUtdW5pdC1zZWxlY3QuY29tcG9uZW50Lmh0bWwnLFxyXG4gIHN0eWxlVXJsczogWycuL3RpbWUtdW5pdC1zZWxlY3QuY29tcG9uZW50LnNjc3MnXSxcclxuICBleHBvcnRBczogJ21hdFRpbWVTZWxlY3QnLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hdFRpbWVVbml0U2VsZWN0Q29tcG9uZW50PEQ+IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25Jbml0IHtcclxuXHJcbiAgcHJpdmF0ZSBfb3JpZ2luVG9wOiBudW1iZXI7XHJcblxyXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlLiAqL1xyXG4gIEBJbnB1dCgpIHZhbHVlOiBudW1iZXI7XHJcbiAgLyoqIFRoZSB1bml0IG9mIHRpbWUgb2YgdGhlIHRpbWUgc2VsZWN0LiAqL1xyXG4gIEBJbnB1dCgpIHVuaXQ6IHVuaXRPZlRpbWUuQWxsO1xyXG4gIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIHZhbHVlLiAqL1xyXG4gIEBJbnB1dCgpIG1pbjogbnVtYmVyIHwgbnVsbDtcclxuICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSB2YWx1ZS4gKi9cclxuICBASW5wdXQoKSBtYXg6IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8qKiBUaGUgbGlzdCBvZiBhbGwgdmFsdWVzIG9mIHRoZSB0aW1lIHNlbGVjdC4gKi9cclxuICBvcHRpb25zOiB7dmFsdWU6IG51bWJlcjsgbGFiZWw6IHN0cmluZ31bXSA9IFtdO1xyXG5cclxuICAvKiogRW1pdHMgd2hlbiBzZWxlY3RlZCB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLiBPdXRwdXQgdG8gZW5hYmxlIHN1cHBvcnQgZm9yIHR3by13YXkgYmluZGluZyBvbiBgWyh2YWx1ZSldYC4gKi9cclxuICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XHJcblxyXG4gIC8qKiBUaGUgcGFuZWwgZWxlbWVudCBjb250YWluaW5nIGFsbCB0aW1lIHNlbGVjdCBvcHRpb25zLiAqL1xyXG4gIEBWaWV3Q2hpbGQoJ3BhbmVsJykgcGFuZWw6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfdGltZUFkYXB0ZXI6IFRpbWVBZGFwdGVyPEQ+LFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoTUFUX1RJTUVfRk9STUFUUykgcHJpdmF0ZSBfdGltZUZvcm1hdHM6IE1hdFRpbWVGb3JtYXRzKSB7IH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICBjb25zdCB1bml0ID0gdGhpcy51bml0O1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX3RpbWVBZGFwdGVyLmNyZWF0ZVRpbWUoKTtcclxuICAgIGNvbnN0IG1vbWVudCA9IHRoaXMuX3RpbWVBZGFwdGVyLnRvTW9tZW50KHRpbWUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBtb21lbnQuY2xvbmUoKS5zdGFydE9mKCdkYXknKTtcclxuICAgIGNvbnN0IGVuZCA9IG1vbWVudC5jbG9uZSgpLmVuZE9mKCdkYXknKTtcclxuICAgIGNvbnN0IG1pbiA9IHN0YXJ0LmdldCh1bml0KTtcclxuICAgIGNvbnN0IG1heCA9IGVuZC5nZXQodW5pdCk7XHJcbiAgICBjb25zdCBsb2NhbGVEYXRhID0gbW9tZW50LmxvY2FsZURhdGEoKTtcclxuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXQgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KCdMVFMnKTtcclxuICAgIGNvbnN0IHVuaXRGb3JtYXQgPSB1bml0ID09PSAnaG91cicgP1xyXG4gICAgICBkaXNwbGF5Rm9ybWF0Lm1hdGNoKC9oaD98SEg/L2cpWzBdIDogdW5pdCA9PT0gJ21pbnV0ZScgP1xyXG4gICAgICAgIGRpc3BsYXlGb3JtYXQubWF0Y2goL21tPy9nKVswXSA6IGRpc3BsYXlGb3JtYXQubWF0Y2goL3NzPy9nKVswXTtcclxuICAgIG1vbWVudC5zZXQodW5pdCwgdGhpcy52YWx1ZSk7XHJcbiAgICBtb21lbnQuc3VidHJhY3QoMSBhcyBEdXJhdGlvbklucHV0QXJnMSwgdW5pdCBhcyBEdXJhdGlvbklucHV0QXJnMik7XHJcbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XHJcbiAgICAgIG1vbWVudC5hZGQoMSBhcyBEdXJhdGlvbklucHV0QXJnMSwgdW5pdCBhcyBEdXJhdGlvbklucHV0QXJnMik7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5wdXNoKHt2YWx1ZTogbW9tZW50LmdldCh1bml0KSwgbGFiZWw6IG1vbWVudC5mb3JtYXQodW5pdEZvcm1hdCl9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnBhbmVsLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB0aGlzLl9vcmlnaW5Ub3AgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudG9wKTtcclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsICgpID0+IHtcclxuICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xyXG4gICAgfSk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubW92ZSh0aGlzLm9wdGlvbnMubGVuZ3RoIC8gMikpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNlbGVjdCB0aGUgcHJldmlvdXMgb3B0aW9uLiAqL1xyXG4gIHByZXYoKSB7XHJcbiAgICB0aGlzLm1vdmUoLTEpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNlbGVjdCB0aGUgbmV4dCBvcHRpb24uICovXHJcbiAgbmV4dCgpIHtcclxuICAgIHRoaXMubW92ZSgrMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3QgdGhlIG9wdGlvbiBtb3ZpbmcgYnkgdGhlIGdpdmVuIGFtb3VudCBvZiBzdGVwLlxyXG4gICAqIEBwYXJhbSBzdGVwIFRoZSBhbW91bnQgb2Ygc3RlcCB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIG1vdmUoc3RlcDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50O1xyXG4gICAgY29uc3Qgb3B0aW9uID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdtYXQtdGltZS11bml0LW9wdGlvbicpO1xyXG4gICAgY29uc3Qgb3B0aW9uSGVpZ2h0ID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKG9wdGlvbikuaGVpZ2h0KTtcclxuICAgIGNvbnN0IGN1cnJlbnRUb3AgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudG9wKTtcclxuICAgIGNvbnN0IHRhcmdldFRvcCA9IGN1cnJlbnRUb3AgKyAoc3RlcCAqIG9wdGlvbkhlaWdodCk7XHJcbiAgICBjb25zdCB5ID0gdGhpcy5fb3JpZ2luVG9wIC0gdGFyZ2V0VG9wO1xyXG5cclxuICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7dGFyZ2V0VG9wfXB4YDtcclxuXHJcbiAgICBpZiAoc3RlcCA8IDApIHtcclxuICAgICAgLy8gTW92ZSBsYXN0IG9wdGlvbiB0byB0aGUgdG9wXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpID4gc3RlcDsgaS0tKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnVuc2hpZnQodGhpcy5vcHRpb25zLnBvcCgpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzdGVwID4gMCkge1xyXG4gICAgICAvLyBNb3ZlIGZpcnN0IG9wdGlvbiB0byB0aGUgYm90dG9tXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnB1c2godGhpcy5vcHRpb25zLnNoaWZ0KCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9uc1sodGhpcy5vcHRpb25zLmxlbmd0aCAvIDIpXS52YWx1ZTtcclxuICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcclxuXHJcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSAndHJhbnNmb3JtIDAuNXMnO1xyXG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke3l9cHgpYDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHByZXZpb3VzIG9wdGlvbiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRQcmV2KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zWyh0aGlzLm9wdGlvbnMubGVuZ3RoIC8gMikgLSAxXS52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG5leHQgb3B0aW9uIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldE5leHQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnNbKHRoaXMub3B0aW9ucy5sZW5ndGggLyAyKSArIDFdLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQuXHJcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgKi9cclxuICBpc1ZhbGlkKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAodGhpcy5taW4gPT09IG51bGwgfHwgdmFsdWUgPj0gdGhpcy5taW4pICYmICh0aGlzLm1heCA9PT0gbnVsbCB8fCB2YWx1ZSA8PSB0aGlzLm1heCk7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=