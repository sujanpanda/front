/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, HostBinding, HostListener, Input, ViewChild, ViewEncapsulation } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { MatButton } from '@angular/material';
import { merge, of, Subscription } from 'rxjs';
import { MatTimeSelectIntl } from './time-select-intl.service';
import { MatTimeSelectComponent } from './time-select.component';
/**
 * Can be used to override the icon of a `matTimeSelectToggle`.
 */
export class MatTimeSelectToggleIconDirective {
}
MatTimeSelectToggleIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[matTimeSelectToggleIcon]'
            },] }
];
/**
 * @template D
 */
export class MatTimeSelectToggleComponent {
    /**
     * @param {?} _intl
     * @param {?} _changeDetectorRef
     * @param {?} defaultTabIndex
     */
    constructor(_intl, _changeDetectorRef, defaultTabIndex) {
        this._intl = _intl;
        this._changeDetectorRef = _changeDetectorRef;
        this._stateChanges = Subscription.EMPTY;
        /** @type {?} */
        const parsedTabIndex = parseInt(defaultTabIndex, 10);
        this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
    }
    /**
     * Whether the toggle button is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled === undefined ? this.timeSelect.disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    /**
     * Whether ripples on the toggle should be disabled.
     * @return {?}
     */
    get disableRipple() {
        return this._disableRipple;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableRipple(value) {
        this._disableRipple = coerceBooleanProperty(value);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get class() { return 'mat-time-select-toggle'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get tabindex() { return '-1'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get active() { return this.timeSelect && this.timeSelect.opened; }
    /**
     * \@docs-private
     * @return {?}
     */
    get accent() { return this.timeSelect && this.timeSelect.color === 'accent'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get warn() { return this.timeSelect && this.timeSelect.color === 'warn'; }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._watchStateChanges();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.timeSelect) {
            this._watchStateChanges();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.unsubscribe();
    }
    /**
     * Handle focus event.
     * @return {?}
     */
    onFocus() {
        this.button.focus();
    }
    /**
     * Open the time select.
     * @param {?} event The triggered event to open the time select.
     * @return {?}
     */
    open(event) {
        if (this.timeSelect && !this.disabled) {
            this.timeSelect.open();
            event.stopPropagation();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _watchStateChanges() {
        /** @type {?} */
        const timeSelectDisabled = this.timeSelect ? this.timeSelect.disabledChange : of();
        /** @type {?} */
        const inputDisabled = this.timeSelect && this.timeSelect._timeSelectInput ?
            this.timeSelect._timeSelectInput.disabledChange : of();
        /** @type {?} */
        const timeSelectToggled = this.timeSelect ?
            merge(this.timeSelect.openStream, this.timeSelect.closeStream) :
            of();
        this._stateChanges.unsubscribe();
        this._stateChanges = merge(this._intl.changes, timeSelectDisabled, inputDisabled, timeSelectToggled).subscribe(() => this._changeDetectorRef.markForCheck());
    }
}
MatTimeSelectToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-select-toggle',
                template: "<button\r\n  #button\r\n  mat-icon-button\r\n  type=\"button\"\r\n  aria-haspopup=\"true\"\r\n  [attr.aria-label]=\"_intl.openTimeSelectLabel\"\r\n  [attr.tabindex]=\"disabled ? -1 : tabIndex\"\r\n  [disabled]=\"disabled\"\r\n  [disableRipple]=\"disableRipple\"\r\n  (click)=\"open($event)\">\r\n\r\n  <svg\r\n    *ngIf=\"!customIcon\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    class=\"mat-time-select-toggle-default-icon\"\r\n    viewBox=\"0 0 24 24\"\r\n    width=\"24px\"\r\n    height=\"24px\"\r\n    fill=\"currentColor\"\r\n    focusable=\"false\">\r\n    <path d=\"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z\"/>\r\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\r\n    <path d=\"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z\"/>\r\n  </svg>\r\n\r\n  <ng-content select=\"[matTimeSelectToggleIcon]\"></ng-content>\r\n</button>\r\n",
                exportAs: 'matTimeSelectToggle',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-time-select-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-time-select-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-time-select-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-time-select-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-time-select-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-time-select-toggle-default-icon{margin:auto}"]
            }] }
];
/** @nocollapse */
MatTimeSelectToggleComponent.ctorParameters = () => [
    { type: MatTimeSelectIntl },
    { type: ChangeDetectorRef },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] }
];
MatTimeSelectToggleComponent.propDecorators = {
    timeSelect: [{ type: Input, args: ['for',] }],
    tabIndex: [{ type: Input }],
    customIcon: [{ type: ContentChild, args: [MatTimeSelectToggleIconDirective,] }],
    button: [{ type: ViewChild, args: ['button',] }],
    disabled: [{ type: Input }],
    disableRipple: [{ type: Input }],
    class: [{ type: HostBinding, args: ['class',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    active: [{ type: HostBinding, args: ['class.mat-time-select-toggle-active',] }],
    accent: [{ type: HostBinding, args: ['class.mat-accent',] }],
    warn: [{ type: HostBinding, args: ['class.mat-warn',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectToggleComponent.prototype._stateChanges;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectToggleComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectToggleComponent.prototype._disableRipple;
    /**
     * Time select instance that the button will toggle.
     * @type {?}
     */
    MatTimeSelectToggleComponent.prototype.timeSelect;
    /**
     * Tabindex for the toggle.
     * @type {?}
     */
    MatTimeSelectToggleComponent.prototype.tabIndex;
    /**
     * Custom icon set by the consumer.
     * @type {?}
     */
    MatTimeSelectToggleComponent.prototype.customIcon;
    /**
     * Underlying button element.
     * @type {?}
     */
    MatTimeSelectToggleComponent.prototype.button;
    /** @type {?} */
    MatTimeSelectToggleComponent.prototype._intl;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectToggleComponent.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1zZWxlY3QtdG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1tYXRlcmlhbC10aW1lLXNlbGVjdC8iLCJzb3VyY2VzIjpbImxpYi90aW1lLXNlbGVjdC10b2dnbGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBRUwsU0FBUyxFQUNULHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBSUwsU0FBUyxFQUNULGlCQUFpQixFQUNsQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDNUMsT0FBTyxFQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsWUFBWSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQzdELE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLHlCQUF5QixDQUFDOzs7O0FBTS9ELE1BQU0sT0FBTyxnQ0FBZ0M7OztZQUg1QyxTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDJCQUEyQjthQUN0Qzs7Ozs7QUFXRCxNQUFNLE9BQU8sNEJBQTRCOzs7Ozs7SUF1RHZDLFlBQW1CLEtBQXdCLEVBQ3ZCLGtCQUFxQyxFQUN0QixlQUF1QjtRQUZ2QyxVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQUN2Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBdERqRCxrQkFBYSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUM7O2NBd0RuQyxjQUFjLEdBQUcsUUFBUSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUM7UUFDcEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLGNBQWMsSUFBSSxjQUFjLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ25GLENBQUM7Ozs7O0lBMUNELElBQ0ksUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ2xGLENBQUM7Ozs7O0lBQ0QsSUFBSSxRQUFRLENBQUMsS0FBYztRQUN6QixJQUFJLENBQUMsU0FBUyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hELENBQUM7Ozs7O0lBR0QsSUFDSSxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7Ozs7O0lBQ0QsSUFBSSxhQUFhLENBQUMsS0FBYztRQUM5QixJQUFJLENBQUMsY0FBYyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JELENBQUM7Ozs7O0lBR0QsSUFDSSxLQUFLLEtBQWEsT0FBTyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBR3hELElBQ0ksUUFBUSxLQUFhLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQzs7Ozs7SUFHdkMsSUFDSSxNQUFNLEtBQWMsT0FBTyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzs7Ozs7SUFHM0UsSUFDSSxNQUFNLEtBQWMsT0FBTyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBR3ZGLElBQ0ksSUFBSSxLQUFjLE9BQU8sSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDOzs7O0lBU25GLGtCQUFrQjtRQUNoQixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUM1QixDQUFDOzs7OztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7U0FDM0I7SUFDSCxDQUFDOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbkMsQ0FBQzs7Ozs7SUFJRCxPQUFPO1FBQ0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN0QixDQUFDOzs7Ozs7SUFNRCxJQUFJLENBQUMsS0FBWTtRQUNmLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDckMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDekI7SUFDSCxDQUFDOzs7OztJQUVPLGtCQUFrQjs7Y0FDbEIsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTs7Y0FDNUUsYUFBYSxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3pFLElBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7O2NBQ2xELGlCQUFpQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN6QyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ2hFLEVBQUUsRUFBRTtRQUVOLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDakMsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUNsQixrQkFBa0IsRUFDbEIsYUFBYSxFQUNiLGlCQUFpQixDQUNsQixDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDOzs7WUFwSEYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSx3QkFBd0I7Z0JBQ2xDLHc3QkFBa0Q7Z0JBRWxELFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7YUFDaEQ7Ozs7WUFoQk8saUJBQWlCO1lBaEJ2QixpQkFBaUI7eUNBMEZKLFNBQVMsU0FBQyxVQUFVOzs7eUJBakRoQyxLQUFLLFNBQUMsS0FBSzt1QkFFWCxLQUFLO3lCQUdMLFlBQVksU0FBQyxnQ0FBZ0M7cUJBRTdDLFNBQVMsU0FBQyxRQUFRO3VCQUdsQixLQUFLOzRCQVNMLEtBQUs7b0JBU0wsV0FBVyxTQUFDLE9BQU87dUJBSW5CLFdBQVcsU0FBQyxlQUFlO3FCQUkzQixXQUFXLFNBQUMscUNBQXFDO3FCQUlqRCxXQUFXLFNBQUMsa0JBQWtCO21CQUk5QixXQUFXLFNBQUMsZ0JBQWdCO3NCQXlCNUIsWUFBWSxTQUFDLE9BQU87Ozs7Ozs7SUEzRXJCLHFEQUEyQzs7Ozs7SUFFM0MsaURBQTJCOzs7OztJQUMzQixzREFBZ0M7Ozs7O0lBR2hDLGtEQUFvRDs7Ozs7SUFFcEQsZ0RBQWlDOzs7OztJQUdqQyxrREFBNkY7Ozs7O0lBRTdGLDhDQUF1Qzs7SUF3QzNCLDZDQUErQjs7Ozs7SUFDL0IsMERBQTZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBBZnRlckNvbnRlbnRJbml0LFxyXG4gIEF0dHJpYnV0ZSxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgQ29udGVudENoaWxkLFxyXG4gIERpcmVjdGl2ZSxcclxuICBIb3N0QmluZGluZyxcclxuICBIb3N0TGlzdGVuZXIsXHJcbiAgSW5wdXQsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIE9uRGVzdHJveSxcclxuICBTaW1wbGVDaGFuZ2VzLFxyXG4gIFZpZXdDaGlsZCxcclxuICBWaWV3RW5jYXBzdWxhdGlvblxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge2NvZXJjZUJvb2xlYW5Qcm9wZXJ0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHtNYXRCdXR0b259IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcclxuaW1wb3J0IHttZXJnZSwgb2YsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7TWF0VGltZVNlbGVjdEludGx9IGZyb20gJy4vdGltZS1zZWxlY3QtaW50bC5zZXJ2aWNlJztcclxuaW1wb3J0IHtNYXRUaW1lU2VsZWN0Q29tcG9uZW50fSBmcm9tICcuL3RpbWUtc2VsZWN0LmNvbXBvbmVudCc7XHJcblxyXG4vKiogQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGljb24gb2YgYSBgbWF0VGltZVNlbGVjdFRvZ2dsZWAuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW21hdFRpbWVTZWxlY3RUb2dnbGVJY29uXSdcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hdFRpbWVTZWxlY3RUb2dnbGVJY29uRGlyZWN0aXZlIHt9XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ21hdC10aW1lLXNlbGVjdC10b2dnbGUnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi90aW1lLXNlbGVjdC10b2dnbGUuY29tcG9uZW50Lmh0bWwnLFxyXG4gIHN0eWxlVXJsczogWycuL3RpbWUtc2VsZWN0LXRvZ2dsZS5jb21wb25lbnQuc2NzcyddLFxyXG4gIGV4cG9ydEFzOiAnbWF0VGltZVNlbGVjdFRvZ2dsZScsXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWF0VGltZVNlbGVjdFRvZ2dsZUNvbXBvbmVudDxEPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGVDaGFuZ2VzID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbjtcclxuICBwcml2YXRlIF9kaXNhYmxlUmlwcGxlOiBib29sZWFuO1xyXG5cclxuICAvKiogVGltZSBzZWxlY3QgaW5zdGFuY2UgdGhhdCB0aGUgYnV0dG9uIHdpbGwgdG9nZ2xlLiAqL1xyXG4gIEBJbnB1dCgnZm9yJykgdGltZVNlbGVjdDogTWF0VGltZVNlbGVjdENvbXBvbmVudDxEPjtcclxuICAvKiogVGFiaW5kZXggZm9yIHRoZSB0b2dnbGUuICovXHJcbiAgQElucHV0KCkgdGFiSW5kZXg6IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8qKiBDdXN0b20gaWNvbiBzZXQgYnkgdGhlIGNvbnN1bWVyLiAqL1xyXG4gIEBDb250ZW50Q2hpbGQoTWF0VGltZVNlbGVjdFRvZ2dsZUljb25EaXJlY3RpdmUpIGN1c3RvbUljb246IE1hdFRpbWVTZWxlY3RUb2dnbGVJY29uRGlyZWN0aXZlO1xyXG4gIC8qKiBVbmRlcmx5aW5nIGJ1dHRvbiBlbGVtZW50LiAqL1xyXG4gIEBWaWV3Q2hpbGQoJ2J1dHRvbicpIGJ1dHRvbjogTWF0QnV0dG9uO1xyXG5cclxuICAvKiogV2hldGhlciB0aGUgdG9nZ2xlIGJ1dHRvbiBpcyBkaXNhYmxlZC4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZCA9PT0gdW5kZWZpbmVkID8gdGhpcy50aW1lU2VsZWN0LmRpc2FibGVkIDogdGhpcy5fZGlzYWJsZWQ7XHJcbiAgfVxyXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFdoZXRoZXIgcmlwcGxlcyBvbiB0aGUgdG9nZ2xlIHNob3VsZCBiZSBkaXNhYmxlZC4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBkaXNhYmxlUmlwcGxlKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7XHJcbiAgfVxyXG4gIHNldCBkaXNhYmxlUmlwcGxlKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXHJcbiAgZ2V0IGNsYXNzKCk6IHN0cmluZyB7IHJldHVybiAnbWF0LXRpbWUtc2VsZWN0LXRvZ2dsZSc7IH1cclxuXHJcbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxyXG4gIGdldCB0YWJpbmRleCgpOiBzdHJpbmcgeyByZXR1cm4gJy0xJzsgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIEBIb3N0QmluZGluZygnY2xhc3MubWF0LXRpbWUtc2VsZWN0LXRvZ2dsZS1hY3RpdmUnKVxyXG4gIGdldCBhY3RpdmUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLnRpbWVTZWxlY3QgJiYgdGhpcy50aW1lU2VsZWN0Lm9wZW5lZDsgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIEBIb3N0QmluZGluZygnY2xhc3MubWF0LWFjY2VudCcpXHJcbiAgZ2V0IGFjY2VudCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMudGltZVNlbGVjdCAmJiB0aGlzLnRpbWVTZWxlY3QuY29sb3IgPT09ICdhY2NlbnQnOyB9XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5tYXQtd2FybicpXHJcbiAgZ2V0IHdhcm4oKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLnRpbWVTZWxlY3QgJiYgdGhpcy50aW1lU2VsZWN0LmNvbG9yID09PSAnd2Fybic7IH1cclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIF9pbnRsOiBNYXRUaW1lU2VsZWN0SW50bCxcclxuICAgICAgICAgICAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgICAgICAgQEF0dHJpYnV0ZSgndGFiaW5kZXgnKSBkZWZhdWx0VGFiSW5kZXg6IHN0cmluZykge1xyXG4gICAgY29uc3QgcGFyc2VkVGFiSW5kZXggPSBwYXJzZUludChkZWZhdWx0VGFiSW5kZXgsIDEwKTtcclxuICAgIHRoaXMudGFiSW5kZXggPSAocGFyc2VkVGFiSW5kZXggfHwgcGFyc2VkVGFiSW5kZXggPT09IDApID8gcGFyc2VkVGFiSW5kZXggOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgdGhpcy5fd2F0Y2hTdGF0ZUNoYW5nZXMoKTtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgIGlmIChjaGFuZ2VzLnRpbWVTZWxlY3QpIHtcclxuICAgICAgdGhpcy5fd2F0Y2hTdGF0ZUNoYW5nZXMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VzLnVuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG5cclxuICAvKiogSGFuZGxlIGZvY3VzIGV2ZW50LiAqL1xyXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcclxuICBvbkZvY3VzKCkge1xyXG4gICAgdGhpcy5idXR0b24uZm9jdXMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wZW4gdGhlIHRpbWUgc2VsZWN0LlxyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgdHJpZ2dlcmVkIGV2ZW50IHRvIG9wZW4gdGhlIHRpbWUgc2VsZWN0LlxyXG4gICAqL1xyXG4gIG9wZW4oZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy50aW1lU2VsZWN0ICYmICF0aGlzLmRpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMudGltZVNlbGVjdC5vcGVuKCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfd2F0Y2hTdGF0ZUNoYW5nZXMoKSB7XHJcbiAgICBjb25zdCB0aW1lU2VsZWN0RGlzYWJsZWQgPSB0aGlzLnRpbWVTZWxlY3QgPyB0aGlzLnRpbWVTZWxlY3QuZGlzYWJsZWRDaGFuZ2UgOiBvZigpO1xyXG4gICAgY29uc3QgaW5wdXREaXNhYmxlZCA9IHRoaXMudGltZVNlbGVjdCAmJiB0aGlzLnRpbWVTZWxlY3QuX3RpbWVTZWxlY3RJbnB1dCA/XHJcbiAgICAgIHRoaXMudGltZVNlbGVjdC5fdGltZVNlbGVjdElucHV0LmRpc2FibGVkQ2hhbmdlIDogb2YoKTtcclxuICAgIGNvbnN0IHRpbWVTZWxlY3RUb2dnbGVkID0gdGhpcy50aW1lU2VsZWN0ID9cclxuICAgICAgbWVyZ2UodGhpcy50aW1lU2VsZWN0Lm9wZW5TdHJlYW0sIHRoaXMudGltZVNlbGVjdC5jbG9zZVN0cmVhbSkgOlxyXG4gICAgICBvZigpO1xyXG5cclxuICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5fc3RhdGVDaGFuZ2VzID0gbWVyZ2UoXHJcbiAgICAgIHRoaXMuX2ludGwuY2hhbmdlcyxcclxuICAgICAgdGltZVNlbGVjdERpc2FibGVkLFxyXG4gICAgICBpbnB1dERpc2FibGVkLFxyXG4gICAgICB0aW1lU2VsZWN0VG9nZ2xlZFxyXG4gICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCkpO1xyXG4gIH1cclxuXHJcbn1cclxuIl19