(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/bidi'), require('rxjs/operators'), require('@angular/forms'), require('@angular/cdk/keycodes'), require('@angular/cdk/coercion'), require('rxjs'), require('@angular/common'), require('@angular/cdk/a11y'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('moment'), require('@angular/core'), require('@angular/material')) :
    typeof define === 'function' && define.amd ? define('ngx-material-time-select', ['exports', '@angular/cdk/bidi', 'rxjs/operators', '@angular/forms', '@angular/cdk/keycodes', '@angular/cdk/coercion', 'rxjs', '@angular/common', '@angular/cdk/a11y', '@angular/cdk/overlay', '@angular/cdk/portal', 'moment', '@angular/core', '@angular/material'], factory) :
    (factory((global['ngx-material-time-select'] = {}),global.ng.cdk.bidi,global.rxjs.operators,global.ng.forms,global.ng.cdk.keycodes,global.ng.cdk.coercion,global.rxjs,global.ng.common,global.ng.cdk.a11y,global.ng.cdk.overlay,global.ng.cdk.portal,global._moment,global.ng.core,global.ng.material));
}(this, (function (exports,bidi,operators,forms,keycodes,coercion,rxjs,common,a11y,overlay,portal,_moment,core,material) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Adapts date object to be usable as a date time by cdk-based components that work with dates.
     * @abstract
     * @template D
     */
    var /**
     * Adapts date object to be usable as a date time by cdk-based components that work with dates.
     * @abstract
     * @template D
     */ TimeAdapter = /** @class */ (function (_super) {
        __extends(TimeAdapter, _super);
        function TimeAdapter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Compares two date times.
         * @param first The first date to compare.
         * @param second The second date to compare.
         * @returns 0 if the date times are equal, a number less than 0 if the first date time is earlier,
         *     a number greater than 0 if the first date time is later.
         */
        /**
         * Compares two date times.
         * @param {?} first The first date to compare.
         * @param {?} second The second date to compare.
         * @return {?} 0 if the date times are equal, a number less than 0 if the first date time is earlier,
         *     a number greater than 0 if the first date time is later.
         */
        TimeAdapter.prototype.compareTime = /**
         * Compares two date times.
         * @param {?} first The first date to compare.
         * @param {?} second The second date to compare.
         * @return {?} 0 if the date times are equal, a number less than 0 if the first date time is earlier,
         *     a number greater than 0 if the first date time is later.
         */
            function (first, second) {
                return this.compareDate(first, second) ||
                    this.getHour(first) - this.getHour(second) ||
                    this.getMinute(first) - this.getMinute(second) ||
                    this.getSecond(first) - this.getSecond(second);
            };
        /**
         * Checks if two date times are equal.
         * @param first The first date to check.
         * @param second The second date to check.
         * @returns Whether the two date times are equal.
         *     Null dates are considered equal to other null dates.
         */
        /**
         * Checks if two date times are equal.
         * @param {?} first The first date to check.
         * @param {?} second The second date to check.
         * @return {?} Whether the two date times are equal.
         *     Null dates are considered equal to other null dates.
         */
        TimeAdapter.prototype.sameTime = /**
         * Checks if two date times are equal.
         * @param {?} first The first date to check.
         * @param {?} second The second date to check.
         * @return {?} Whether the two date times are equal.
         *     Null dates are considered equal to other null dates.
         */
            function (first, second) {
                if (first && second) {
                    /** @type {?} */
                    var firstValid = this.isValid(first);
                    /** @type {?} */
                    var secondValid = this.isValid(second);
                    if (firstValid && secondValid) {
                        return !this.compareTime(first, second);
                    }
                    return firstValid === secondValid;
                }
                return first === second;
            };
        /**
         * Clamp the given date between min and max date times.
         * @param date The date to clamp.
         * @param min The minimum value to allow. If null or omitted no min is enforced.
         * @param max The maximum value to allow. If null or omitted no max is enforced.
         * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,
         *     otherwise `date`.
         */
        /**
         * Clamp the given date between min and max date times.
         * @param {?} date The date to clamp.
         * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
         * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
         * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
         *     otherwise `date`.
         */
        TimeAdapter.prototype.clampTime = /**
         * Clamp the given date between min and max date times.
         * @param {?} date The date to clamp.
         * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
         * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
         * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
         *     otherwise `date`.
         */
            function (date, min, max) {
                if (min && this.compareTime(date, min) < 0) {
                    return min;
                }
                if (max && this.compareTime(date, max) > 0) {
                    return max;
                }
                return date;
            };
        return TimeAdapter;
    }(material.DateAdapter));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAT_TIME_FORMATS = new core.InjectionToken('mat-time-formats');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * TimeSelect data that requires internationalization.
     */
    var MatTimeSelectIntl = /** @class */ (function () {
        function MatTimeSelectIntl() {
            /**
             * Stream that emits whenever the labels here are changed. Use this to notify
             * components if the labels have changed after initialization.
             */
            this.changes = new rxjs.Subject();
            /**
             * A label for the button used to open the time select popup (used by screen readers).
             */
            this.openTimeSelectLabel = 'Open time select';
            /**
             * A label for the a.m. button toggle (used by screen readers).
             */
            this.amLabel = 'AM';
            /**
             * A label for the p.m. button toggle (used by screen readers).
             */
            this.pmLabel = 'PM';
        }
        MatTimeSelectIntl.decorators = [
            { type: core.Injectable }
        ];
        return MatTimeSelectIntl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Component used to select a value of a unit of time.
     * @template D
     */
    var MatTimeUnitSelectComponent = /** @class */ (function () {
        function MatTimeUnitSelectComponent(_changeDetectorRef, _timeAdapter, _timeFormats) {
            this._changeDetectorRef = _changeDetectorRef;
            this._timeAdapter = _timeAdapter;
            this._timeFormats = _timeFormats;
            /**
             * The list of all values of the time select.
             */
            this.options = [];
            /**
             * Emits when selected value has been changed. Output to enable support for two-way binding on `[(value)]`.
             */
            this.valueChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var unit = this.unit;
                /** @type {?} */
                var time = this._timeAdapter.createTime();
                /** @type {?} */
                var moment = this._timeAdapter.toMoment(time);
                /** @type {?} */
                var start = moment.clone().startOf('day');
                /** @type {?} */
                var end = moment.clone().endOf('day');
                /** @type {?} */
                var min = start.get(unit);
                /** @type {?} */
                var max = end.get(unit);
                /** @type {?} */
                var localeData = moment.localeData();
                /** @type {?} */
                var displayFormat = localeData.longDateFormat('LTS');
                /** @type {?} */
                var unitFormat = unit === 'hour' ?
                    displayFormat.match(/hh?|HH?/g)[0] : unit === 'minute' ?
                    displayFormat.match(/mm?/g)[0] : displayFormat.match(/ss?/g)[0];
                moment.set(unit, this.value);
                moment.subtract(( /** @type {?} */(1)), ( /** @type {?} */(unit)));
                for (var value = min; value <= max; value++) {
                    moment.add(( /** @type {?} */(1)), ( /** @type {?} */(unit)));
                    this.options.push({ value: moment.get(unit), label: moment.format(unitFormat) });
                }
            };
        /**
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var element = this.panel.nativeElement;
                this._originTop = parseFloat(getComputedStyle(element).top);
                element.addEventListener('transitionend', function () {
                    element.style.removeProperty('transition');
                });
                setTimeout(function () { return _this.move(_this.options.length / 2); });
            };
        /** Select the previous option. */
        /**
         * Select the previous option.
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.prev = /**
         * Select the previous option.
         * @return {?}
         */
            function () {
                this.move(-1);
            };
        /** Select the next option. */
        /**
         * Select the next option.
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.next = /**
         * Select the next option.
         * @return {?}
         */
            function () {
                this.move(+1);
            };
        /**
         * Select the option moving by the given amount of step.
         * @param step The amount of step to move.
         */
        /**
         * Select the option moving by the given amount of step.
         * @param {?} step The amount of step to move.
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.move = /**
         * Select the option moving by the given amount of step.
         * @param {?} step The amount of step to move.
         * @return {?}
         */
            function (step) {
                /** @type {?} */
                var element = this.panel.nativeElement;
                /** @type {?} */
                var option = element.querySelector('mat-time-unit-option');
                /** @type {?} */
                var optionHeight = parseFloat(getComputedStyle(option).height);
                /** @type {?} */
                var currentTop = parseFloat(getComputedStyle(element).top);
                /** @type {?} */
                var targetTop = currentTop + (step * optionHeight);
                /** @type {?} */
                var y = this._originTop - targetTop;
                element.style.top = targetTop + "px";
                if (step < 0) {
                    // Move last option to the top
                    for (var i = 0; i > step; i--) {
                        this.options.unshift(this.options.pop());
                    }
                }
                else if (step > 0) {
                    // Move first option to the bottom
                    for (var i = 0; i < step; i++) {
                        this.options.push(this.options.shift());
                    }
                }
                this.value = this.options[(this.options.length / 2)].value;
                this.valueChange.emit(this.value);
                element.style.transition = 'transform 0.5s';
                element.style.transform = "translateY(" + y + "px)";
            };
        /**
         * Gets the previous option value.
         */
        /**
         * Gets the previous option value.
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.getPrev = /**
         * Gets the previous option value.
         * @return {?}
         */
            function () {
                return this.options[(this.options.length / 2) - 1].value;
            };
        /**
         * Gets the next option value.
         */
        /**
         * Gets the next option value.
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.getNext = /**
         * Gets the next option value.
         * @return {?}
         */
            function () {
                return this.options[(this.options.length / 2) + 1].value;
            };
        /**
         * Whether the given value is valid.
         * @param value The value to check.
         */
        /**
         * Whether the given value is valid.
         * @param {?} value The value to check.
         * @return {?}
         */
        MatTimeUnitSelectComponent.prototype.isValid = /**
         * Whether the given value is valid.
         * @param {?} value The value to check.
         * @return {?}
         */
            function (value) {
                return (this.min === null || value >= this.min) && (this.max === null || value <= this.max);
            };
        MatTimeUnitSelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'mat-time-unit-select',
                        template: "<div class=\"mat-time-unit-select-carousel\">\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-prev\" mat-icon-button aria-label=\"Previous\" [disabled]=\"!isValid(getPrev())\" (click)=\"prev()\">\r\n    <mat-icon>keyboard_arrow_up</mat-icon>\r\n  </button>\r\n  <div class=\"mat-time-unit-select-mask\">\r\n    <div #panel class=\"mat-time-unit-select-panel\">\r\n      <mat-time-unit-option *ngFor=\"let option of options\" [value]=\"option.value\" [disabled]=\"!isValid(option.value)\"> {{ option.label }} </mat-time-unit-option>\r\n    </div>\r\n  </div>\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-next\" mat-icon-button aria-label=\"Next\" [disabled]=\"!isValid(getNext())\" (click)=\"next()\">\r\n    <mat-icon>keyboard_arrow_down</mat-icon>\r\n  </button>\r\n</div>\r\n",
                        exportAs: 'matTimeSelect',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: ["mat-time-unit-select{display:block;height:100%}mat-time-unit-select .mat-time-unit-select-carousel{display:flex;flex-direction:column;align-items:center;height:100%}mat-time-unit-select .mat-time-unit-select-mask{flex:auto;max-height:120px;width:100%;overflow:hidden}"]
                    }] }
        ];
        /** @nocollapse */
        MatTimeUnitSelectComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef },
                { type: TimeAdapter },
                { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TIME_FORMATS,] }] }
            ];
        };
        MatTimeUnitSelectComponent.propDecorators = {
            value: [{ type: core.Input }],
            unit: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            panel: [{ type: core.ViewChild, args: ['panel',] }]
        };
        return MatTimeUnitSelectComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MatTimeUnitOptionBase = /** @class */ (function () {
        function MatTimeUnitOptionBase() {
        }
        return MatTimeUnitOptionBase;
    }());
    /** @type {?} */
    var _MatTimeUnitOptionMixinBase = material.mixinDisableRipple(MatTimeUnitOptionBase);
    /**
     * Single time option inside a `<mat-time-unit-select>` element
     * @template D
     */
    var MatTimeUnitOptionComponent = /** @class */ (function (_super) {
        __extends(MatTimeUnitOptionComponent, _super);
        function MatTimeUnitOptionComponent(_elementRef, _changeDetectorRef, timeUnitSelect) {
            var _this = _super.call(this) || this;
            _this._elementRef = _elementRef;
            _this._changeDetectorRef = _changeDetectorRef;
            _this.timeUnitSelect = timeUnitSelect;
            _this._disabled = false;
            _this._selected = false;
            /**
             * \@docs-private
             */
            _this.class = 'mat-time-unit-option';
            /**
             * \@docs-private
             */
            _this.role = 'option';
            /**
             * \@docs-private
             */
            _this.tabindex = -1;
            return _this;
        }
        Object.defineProperty(MatTimeUnitOptionComponent.prototype, "selected", {
            /** Whether or not the option is currently selected. */
            get: /**
             * Whether or not the option is currently selected.
             * @return {?}
             */ function () { return this._selected; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var selected = coercion.coerceBooleanProperty(value);
                if (this._selected !== selected) {
                    this._selected = selected;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeUnitOptionComponent.prototype, "disabled", {
            /** Whether the option is disabled. */
            get: /**
             * Whether the option is disabled.
             * @return {?}
             */ function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var disabled = coercion.coerceBooleanProperty(value);
                if (this._disabled !== disabled) {
                    this._disabled = disabled;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeUnitOptionComponent.prototype, "ariaDisabled", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return this.disabled.toString(); },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatTimeUnitOptionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.timeUnitSelect.valueChange.subscribe(function (value) { return _this.selected = _this.value === value; });
            };
        /** Gets the label to be used when determining whether the option should be focused. */
        /**
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
        MatTimeUnitOptionComponent.prototype.getLabel = /**
         * Gets the label to be used when determining whether the option should be focused.
         * @return {?}
         */
            function () {
                return this._text ? (this._text.nativeElement.textContent || '').trim() : '';
            };
        /** Gets the host DOM element. */
        /**
         * Gets the host DOM element.
         * @return {?}
         */
        MatTimeUnitOptionComponent.prototype._getHostElement = /**
         * Gets the host DOM element.
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement;
            };
        /** Whether ripples for the option are disabled. */
        /**
         * Whether ripples for the option are disabled.
         * @return {?}
         */
        MatTimeUnitOptionComponent.prototype._isRippleDisabled = /**
         * Whether ripples for the option are disabled.
         * @return {?}
         */
            function () {
                return this.disabled || this.disableRipple;
            };
        /** Handle click on the option. */
        /**
         * Handle click on the option.
         * @return {?}
         */
        MatTimeUnitOptionComponent.prototype._onClick = /**
         * Handle click on the option.
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.timeUnitSelect.move(this.value - this.timeUnitSelect.value);
                }
            };
        MatTimeUnitOptionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'mat-time-unit-option',
                        template: "<div class=\"mat-time-unit-option-content\">\r\n  <div mat-ripple\r\n       class=\"mat-time-unit-option-ripple\"\r\n       [matRippleTrigger]=\"_getHostElement()\"\r\n       [matRippleDisabled]=\"_isRippleDisabled()\"></div>\r\n  <div #text class=\"mat-time-unit-option-text\">\r\n    <ng-content></ng-content>\r\n  </div>\r\n</div>\r\n",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".mat-time-unit-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;-webkit-transform:scale(1,1);transform:scale(1,1);transition:transform .5s;transition:transform .5s,-webkit-transform .5s}.mat-time-unit-option .mat-time-unit-option-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-time-unit-option .mat-time-unit-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-time-unit-option .mat-time-unit-option-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0;text-align:center}.mat-time-unit-option .mat-time-unit-option-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-time-unit-option .mat-time-unit-option-text:empty{display:none}.mat-time-unit-option:not(.mat-time-unit-option-disabled){cursor:pointer;outline:0}.mat-time-unit-option.mat-time-unit-option-selected:not(.mat-time-unit-option-disabled),.mat-time-unit-separator{-webkit-transform:scale(1.5,1.5);transform:scale(1.5,1.5)}"]
                    }] }
        ];
        /** @nocollapse */
        MatTimeUnitOptionComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef },
                { type: MatTimeUnitSelectComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatTimeUnitSelectComponent; }),] }] }
            ];
        };
        MatTimeUnitOptionComponent.propDecorators = {
            value: [{ type: core.Input }],
            disableRipple: [{ type: core.Input }],
            _text: [{ type: core.ViewChild, args: ['text',] }],
            class: [{ type: core.HostBinding, args: ['class',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            tabindex: [{ type: core.HostBinding, args: ['attr.tabindex',] }],
            selected: [{ type: core.Input }, { type: core.HostBinding, args: ['class.mat-time-unit-option-selected',] }],
            disabled: [{ type: core.Input }, { type: core.HostBinding, args: ['class.mat-time-unit-option-disabled',] }],
            ariaDisabled: [{ type: core.HostBinding, args: ['attr.aria-disabled',] }],
            _onClick: [{ type: core.HostListener, args: ['click',] }]
        };
        return MatTimeUnitOptionComponent;
    }(_MatTimeUnitOptionMixinBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@docs-private
     * @param {?} provider
     * @return {?}
     */
    function createMissingTimeImplError(provider) {
        return Error("MatTimeSelectComponent: No provider found for " + provider + ". You must import one of the following " +
            "modules at your application root: MatNativeTimeModule, MatMomentTimeModule, or provide a " +
            "custom implementation.");
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Used to generate a unique ID for each time select instance.
     * @type {?}
     */
    var timeSelectUid = 0;
    /**
     * Injection token used to initialize the time select data.
     * @type {?}
     */
    var MAT_TIME_SELECT_DATA = new core.InjectionToken('mat-time-select-data');
    /**
     * Injection token that determines the scroll handling while the time select is opened.
     * @type {?}
     */
    var MAT_TIME_SELECT_SCROLL_STRATEGY = new core.InjectionToken('mat-time-select-scroll-strategy');
    /**
     * \@docs-private
     * @param {?} overlay
     * @return {?}
     */
    function MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY(overlay$$1) {
        return function () { return overlay$$1.scrollStrategies.reposition(); };
    }
    /**
     * \@docs-private
     * @type {?}
     */
    var MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER = {
        provide: MAT_TIME_SELECT_SCROLL_STRATEGY,
        deps: [overlay.Overlay],
        useFactory: MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY
    };
    /**
     * \@docs-private
     */
    var /**
     * \@docs-private
     */ MatTimeSelectContentBase = /** @class */ (function () {
        function MatTimeSelectContentBase(_elementRef) {
            this._elementRef = _elementRef;
        }
        return MatTimeSelectContentBase;
    }());
    /** @type {?} */
    var _MatTimeSelectContentMixinBase = material.mixinColor(MatTimeSelectContentBase);
    /**
     * Component used as the content for the time select popup.
     * \@docs-private
     * @template D
     */
    var MatTimeSelectContentComponent = /** @class */ (function (_super) {
        __extends(MatTimeSelectContentComponent, _super);
        function MatTimeSelectContentComponent(elementRef, _intl, _timeAdapter, data) {
            var _this = _super.call(this, elementRef) || this;
            _this._intl = _intl;
            _this._timeAdapter = _timeAdapter;
            /**
             * Emits when the time select content selected time has been changed.
             */
            _this.valueChange = new core.EventEmitter();
            /**
             * \@docs-private
             */
            _this.class = 'mat-time-select-content';
            if (!_this._timeAdapter) {
                throw createMissingTimeImplError('TimeAdapter');
            }
            /** @type {?} */
            var time = _this._timeAdapter.isDateInstance(data.value) && _this._timeAdapter.isValid(data.value) ?
                _this._timeAdapter.clone(data.value) : _this._timeAdapter.now();
            /** @type {?} */
            var value = _this._timeAdapter.toMoment(_this._timeAdapter.clampTime(time, data.minTime, data.maxTime));
            /** @type {?} */
            var localeData = value.localeData();
            /** @type {?} */
            var displayFormat = localeData.longDateFormat('LTS');
            _this.hourClock = /hh?/g.test(displayFormat) ? 12 : 24;
            _this.value = value;
            _this.units = data.units || ['hour', 'minute'];
            _this.minTime = data.minTime ? _this._timeAdapter.toMoment(data.minTime) : null;
            _this.maxTime = data.maxTime ? _this._timeAdapter.toMoment(data.maxTime) : null;
            return _this;
        }
        Object.defineProperty(MatTimeSelectContentComponent.prototype, "amPm", {
            /**
             * The time period of the currently selected time of the time select content. Possible values: `am` when selected time hour is less
             * than 12; `pm` when selected time hour is greater than or equal to 12.
             */
            get: /**
             * The time period of the currently selected time of the time select content. Possible values: `am` when selected time hour is less
             * than 12; `pm` when selected time hour is greater than or equal to 12.
             * @return {?}
             */ function () { return this.value ? (this.value.hour() < 12 ? 'am' : 'pm') : null; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.timeUnitSelectComponents) {
                    this.timeUnitSelectComponents.toArray()
                        .filter(function (timeSelect) { return timeSelect.unit === 'hour'; })
                        .forEach(function (timeSelect) { return timeSelect.move(value === 'am' ? -12 : 12); });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the value of the given unit of time.
         * @param unit The unit of time to query.
         * @returns The retrieved value.
         */
        /**
         * Gets the value of the given unit of time.
         * @param {?} unit The unit of time to query.
         * @return {?} The retrieved value.
         */
        MatTimeSelectContentComponent.prototype.get = /**
         * Gets the value of the given unit of time.
         * @param {?} unit The unit of time to query.
         * @return {?} The retrieved value.
         */
            function (unit) {
                return this.value.get(unit);
            };
        /**
         * Sets the value of the given unit of time.
         * @param unit The unit of time to update.
         * @param value The value to set.
         */
        /**
         * Sets the value of the given unit of time.
         * @param {?} unit The unit of time to update.
         * @param {?} value The value to set.
         * @return {?}
         */
        MatTimeSelectContentComponent.prototype.set = /**
         * Sets the value of the given unit of time.
         * @param {?} unit The unit of time to update.
         * @param {?} value The value to set.
         * @return {?}
         */
            function (unit, value) {
                this.value.set(unit, value);
                this.valueChange.emit(this.value);
            };
        /**
         * Gets the minimum allowed value of the given unit of time.
         * @param unit The unit of time to query.
         * @returns The minimum value.
         */
        /**
         * Gets the minimum allowed value of the given unit of time.
         * @param {?} unit The unit of time to query.
         * @return {?} The minimum value.
         */
        MatTimeSelectContentComponent.prototype.getMin = /**
         * Gets the minimum allowed value of the given unit of time.
         * @param {?} unit The unit of time to query.
         * @return {?} The minimum value.
         */
            function (unit) {
                /** @type {?} */
                var min = null;
                if (this.minTime && this.value.isSame(this.minTime, 'day')) {
                    if (this.getPrev(unit).isBefore(this.minTime)) {
                        min = this.value.get(unit);
                    }
                    if (this.getNext(unit).isBefore(this.minTime)) {
                        min = this.minTime.get(unit);
                    }
                }
                return min;
            };
        /**
         * Gets the maximum allowed value of the given unit of time.
         * @param unit The unit of time to query.
         * @returns The maximum value.
         */
        /**
         * Gets the maximum allowed value of the given unit of time.
         * @param {?} unit The unit of time to query.
         * @return {?} The maximum value.
         */
        MatTimeSelectContentComponent.prototype.getMax = /**
         * Gets the maximum allowed value of the given unit of time.
         * @param {?} unit The unit of time to query.
         * @return {?} The maximum value.
         */
            function (unit) {
                /** @type {?} */
                var max = null;
                if (this.maxTime && this.value.isSame(this.maxTime, 'day')) {
                    if (this.getNext(unit).isAfter(this.maxTime)) {
                        max = this.value.get(unit);
                    }
                    if (this.getPrev(unit).isAfter(this.maxTime)) {
                        max = this.maxTime.get(unit);
                    }
                }
                return max;
            };
        /**
         * Gets the value after moving up the given unit of time.
         * @param unit The unit of time to move.
         * @returns The new value.
         */
        /**
         * Gets the value after moving up the given unit of time.
         * @param {?} unit The unit of time to move.
         * @return {?} The new value.
         */
        MatTimeSelectContentComponent.prototype.getPrev = /**
         * Gets the value after moving up the given unit of time.
         * @param {?} unit The unit of time to move.
         * @return {?} The new value.
         */
            function (unit) {
                /** @type {?} */
                var prev = this.value.clone().subtract(( /** @type {?} */(1)), ( /** @type {?} */(unit)));
                return this.value.clone().set(unit, prev.get(unit));
            };
        /**
         * Gets the value after moving down the given unit of time.
         * @param unit The unit of time to move.
         * @returns The new value.
         */
        /**
         * Gets the value after moving down the given unit of time.
         * @param {?} unit The unit of time to move.
         * @return {?} The new value.
         */
        MatTimeSelectContentComponent.prototype.getNext = /**
         * Gets the value after moving down the given unit of time.
         * @param {?} unit The unit of time to move.
         * @return {?} The new value.
         */
            function (unit) {
                /** @type {?} */
                var next = this.value.clone().add(( /** @type {?} */(1)), ( /** @type {?} */(unit)));
                return this.value.clone().set(unit, next.get(unit));
            };
        /**
         * Gets the value before midday.
         */
        /**
         * Gets the value before midday.
         * @return {?}
         */
        MatTimeSelectContentComponent.prototype.getAM = /**
         * Gets the value before midday.
         * @return {?}
         */
            function () {
                if (this.value.hour() >= 12) {
                    return this.value.clone().subtract(12, 'hour');
                }
                return this.value;
            };
        /**
         * Gets the value after midday.
         */
        /**
         * Gets the value after midday.
         * @return {?}
         */
        MatTimeSelectContentComponent.prototype.getPM = /**
         * Gets the value after midday.
         * @return {?}
         */
            function () {
                if (this.value.hour() < 12) {
                    return this.value.clone().add(12, 'hour');
                }
                return this.value;
            };
        /**
         * Whether the given value is selectable.
         * @param value The value to check.
         * @returns `true` if the value is valid. Otherwise `false`.
         */
        /**
         * Whether the given value is selectable.
         * @param {?} value The value to check.
         * @return {?} `true` if the value is valid. Otherwise `false`.
         */
        MatTimeSelectContentComponent.prototype.isValid = /**
         * Whether the given value is selectable.
         * @param {?} value The value to check.
         * @return {?} `true` if the value is valid. Otherwise `false`.
         */
            function (value) {
                /** @type {?} */
                var beforeMin = this.minTime && value.isBefore(this.minTime);
                /** @type {?} */
                var afterMax = this.maxTime && value.isAfter(this.maxTime);
                return !(beforeMin || afterMax);
            };
        MatTimeSelectContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'mat-time-select-content',
                        template: "<table class=\"mat-time-select-table mat-{{ color }}\">\r\n  <tr>\r\n    <ng-container *ngFor=\"let unit of units; first as first\">\r\n      <td *ngIf=\"!first\" class=\"mat-time-select-column mat-time-select-separator\">\r\n        <div class=\"mat-time-unit-separator\">\r\n          <span class=\"mat-time-unit-separator-text\">:</span>\r\n        </div>\r\n      </td>\r\n      <td class=\"mat-time-select-column mat-time-select-{{ unit }}\">\r\n        <mat-time-unit-select\r\n          [min]=\"getMin(unit)\"\r\n          [max]=\"getMax(unit)\"\r\n          [unit]=\"unit\"\r\n          [value]=\"get(unit)\"\r\n          (valueChange)=\"set(unit, $event)\">\r\n        </mat-time-unit-select>\r\n      </td>\r\n    </ng-container>\r\n  </tr>\r\n  <tr *ngIf=\"hourClock === 12\">\r\n    <td class=\"mat-time-ampm\" [colSpan]=\"(units.length * 2) - 1\">\r\n      <mat-button-toggle-group [value]=\"amPm\" (change)=\"amPm = $event.value\">\r\n        <mat-button-toggle value=\"am\" [disabled]=\"!isValid(getAM())\">{{ _intl.amLabel }}</mat-button-toggle>\r\n        <mat-button-toggle value=\"pm\" [disabled]=\"!isValid(getPM())\">{{ _intl.pmLabel }}</mat-button-toggle>\r\n      </mat-button-toggle-group>\r\n    </td>\r\n  </tr>\r\n</table>\r\n",
                        exportAs: 'matTimeSelectContent',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".mat-time-select-content{display:block;border-radius:4px}.mat-time-select-content .mat-time-select-table{border-collapse:collapse}.mat-time-select-content .mat-time-select-column{width:80px;padding:0}.mat-time-select-content .mat-time-select-column .mat-time-unit-select-panel{position:relative}.mat-time-select-content .mat-time-select-hour .mat-time-unit-select-panel{top:-440px}.mat-time-select-content .mat-time-select-minute .mat-time-unit-select-panel,.mat-time-select-content .mat-time-select-second .mat-time-unit-select-panel{top:-1160px}.mat-time-select-content .mat-time-select-separator{text-align:center}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;height:40px;width:100%}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator-text{width:100%}.mat-time-select-content .mat-time-ampm{text-align:center}"]
                    }] }
        ];
        /** @nocollapse */
        MatTimeSelectContentComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: MatTimeSelectIntl },
                { type: TimeAdapter, decorators: [{ type: core.Optional }] },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_TIME_SELECT_DATA,] }] }
            ];
        };
        MatTimeSelectContentComponent.propDecorators = {
            color: [{ type: core.Input }],
            units: [{ type: core.Input }],
            value: [{ type: core.Input }],
            minTime: [{ type: core.Input }],
            maxTime: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            timeUnitSelectComponents: [{ type: core.ViewChildren, args: [MatTimeUnitSelectComponent,] }],
            class: [{ type: core.HostBinding, args: ['class',] }]
        };
        return MatTimeSelectContentComponent;
    }(_MatTimeSelectContentMixinBase));
    /**
     * Component responsible for managing the time select popup.
     * @template D
     */
    var MatTimeSelectComponent = /** @class */ (function () {
        function MatTimeSelectComponent(_overlay, _injector, _ngZone, _viewContainerRef, scrollStrategy, _timeAdapter, _dir, _document) {
            this._overlay = _overlay;
            this._injector = _injector;
            this._ngZone = _ngZone;
            this._viewContainerRef = _viewContainerRef;
            this._timeAdapter = _timeAdapter;
            this._dir = _dir;
            this._document = _document;
            /**
             * Subscription to value changes in the associated input element.
             */
            this._inputSubscription = rxjs.Subscription.EMPTY;
            this._opened = false;
            this._disabledChange = new rxjs.Subject();
            this._selectedChange = new rxjs.Subject();
            /**
             * The element that was focused before the time select was opened.
             */
            this._focusedElementBeforeOpen = null;
            /**
             * Emits when the time select has been opened.
             */
            this.openStream = new core.EventEmitter();
            /**
             * Emits when the time select has been closed.
             */
            this.closeStream = new core.EventEmitter();
            /**
             * The id for the time select popup.
             */
            this.id = "mat-time-select-" + timeSelectUid++;
            if (!this._timeAdapter) {
                throw createMissingTimeImplError('TimeAdapter');
            }
            this._scrollStrategy = scrollStrategy;
        }
        Object.defineProperty(MatTimeSelectComponent.prototype, "startAt", {
            /** The initial time of the time select. */
            get: /**
             * The initial time of the time select.
             * @return {?}
             */ function () { return this._startAt || (this._timeSelectInput ? this._timeSelectInput.value : null); },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this._startAt = this._getValidDateOrNull(this._timeAdapter.deserialize(value)); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectComponent.prototype, "color", {
            /** The color palette to use on the time select popup. */
            get: /**
             * The color palette to use on the time select popup.
             * @return {?}
             */ function () { return this._color || (this._timeSelectInput ? this._timeSelectInput.getThemePalette() : undefined); },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this._color = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectComponent.prototype, "disabled", {
            /** Whether the time select pop-up should disabled. */
            get: /**
             * Whether the time select pop-up should disabled.
             * @return {?}
             */ function () {
                return this._disabled !== undefined ? this._disabled : (this._timeSelectInput ? this._timeSelectInput.disabled : false);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var disabled = coercion.coerceBooleanProperty(value);
                if (this._disabled !== disabled) {
                    this._disabled = disabled;
                    this._disabledChange.next(disabled);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectComponent.prototype, "selected", {
            /** The currently selected time. */
            get: /**
             * The currently selected time.
             * @return {?}
             */ function () { return this._selected; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { this._selected = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectComponent.prototype, "opened", {
            /** Whether the time select is opened. */
            get: /**
             * Whether the time select is opened.
             * @return {?}
             */ function () { return this._opened; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) { value ? this.open() : close(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectComponent.prototype, "disabledChange", {
            /** Emits when the time select disabled state has been changed. */
            get: /**
             * Emits when the time select disabled state has been changed.
             * @return {?}
             */ function () { return this._disabledChange.asObservable(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectComponent.prototype, "selectedChange", {
            /** Emits when the time select selected time has been changed. */
            get: /**
             * Emits when the time select selected time has been changed.
             * @return {?}
             */ function () { return this._selectedChange.asObservable(); },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatTimeSelectComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.close();
                this._inputSubscription.unsubscribe();
                this._disabledChange.complete();
                if (this._popupRef) {
                    this._popupRef.dispose();
                    this._popupComponentRef = null;
                }
            };
        /**
         * Selects the given time.
         * @param time The date time to select.
         */
        /**
         * Selects the given time.
         * @param {?} time The date time to select.
         * @return {?}
         */
        MatTimeSelectComponent.prototype.select = /**
         * Selects the given time.
         * @param {?} time The date time to select.
         * @return {?}
         */
            function (time) {
                /** @type {?} */
                var oldValue = this.selected;
                /** @type {?} */
                var value = this._timeAdapter.clone(time);
                this.selected = value;
                if (!this._timeAdapter.sameTime(oldValue, value)) {
                    this._selectedChange.next(value);
                }
            };
        /**
         * Register an input with this time select.
         * @param input The time select input to register with this time select.
         */
        /**
         * Register an input with this time select.
         * @param {?} input The time select input to register with this time select.
         * @return {?}
         */
        MatTimeSelectComponent.prototype.registerInput = /**
         * Register an input with this time select.
         * @param {?} input The time select input to register with this time select.
         * @return {?}
         */
            function (input) {
                var _this = this;
                if (this._timeSelectInput) {
                    throw Error('A MatTimeSelect can only be associated with a single input.');
                }
                this._timeSelectInput = input;
                this._inputSubscription = this._timeSelectInput.valueChange.subscribe(function (value) { return _this.selected = value; });
            };
        /** Open the time select. */
        /**
         * Open the time select.
         * @return {?}
         */
        MatTimeSelectComponent.prototype.open = /**
         * Open the time select.
         * @return {?}
         */
            function () {
                if (this._opened || this.disabled) {
                    return;
                }
                if (!this._timeSelectInput) {
                    throw Error('Attempted to open an MatTimeSelect with no associated input.');
                }
                if (this._document) {
                    this._focusedElementBeforeOpen = this._document.activeElement;
                }
                this._openAsPopup();
                this._opened = true;
                this.openStream.emit();
            };
        /** Close the time select. */
        /**
         * Close the time select.
         * @return {?}
         */
        MatTimeSelectComponent.prototype.close = /**
         * Close the time select.
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this._opened) {
                    return;
                }
                if (this._popupRef && this._popupRef.hasAttached()) {
                    this._popupRef.detach();
                }
                if (this._popupComponentPortal && this._popupComponentPortal.isAttached) {
                    this._popupComponentPortal.detach();
                }
                /** @type {?} */
                var completeClose = function () {
                    // The `_opened` could've been reset already if
                    // we got two events in quick succession.
                    if (_this._opened) {
                        _this._opened = false;
                        _this.closeStream.emit();
                        _this._focusedElementBeforeOpen = null;
                    }
                };
                if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {
                    // Because IE moves focus asynchronously, we can't count on it being restored before we've
                    // marked the time select as closed. If the event fires out of sequence and the element that
                    // we're refocusing opens the time select on focus, the user could be stuck with not being
                    // able to close the select panel at all. We work around it by making the logic, that marks
                    // the time select as closed, async as well.
                    this._focusedElementBeforeOpen.focus();
                    setTimeout(completeClose);
                }
                else {
                    completeClose();
                }
            };
        /** Open the time select as a popup. */
        /**
         * Open the time select as a popup.
         * @private
         * @return {?}
         */
        MatTimeSelectComponent.prototype._openAsPopup = /**
         * Open the time select as a popup.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this._popupComponentPortal = new portal.ComponentPortal(MatTimeSelectContentComponent, this._viewContainerRef, this._createInjector());
                if (!this._popupRef) {
                    this._createPopup();
                }
                if (!this._popupRef.hasAttached()) {
                    this._popupComponentRef = this._popupRef.attach(this._popupComponentPortal);
                    this._popupComponentRef.instance.valueChange.subscribe(function (value) { return _this.select(_this._timeAdapter.deserialize(value.toISOString())); });
                    this._setColor();
                    // Update the position once the select panel has rendered.
                    this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                        _this._popupRef.updatePosition();
                    });
                }
            };
        /** Create a portal injector to inject time select initial data. */
        /**
         * Create a portal injector to inject time select initial data.
         * @private
         * @return {?}
         */
        MatTimeSelectComponent.prototype._createInjector = /**
         * Create a portal injector to inject time select initial data.
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var data = {
                    value: this.startAt,
                    minTime: this._timeSelectInput && this._timeSelectInput.min,
                    maxTime: this._timeSelectInput && this._timeSelectInput.max
                };
                /** @type {?} */
                var injectorTokens = new WeakMap([
                    [MAT_TIME_SELECT_DATA, data]
                ]);
                return new portal.PortalInjector(this._injector, injectorTokens);
            };
        /** Create the popup. */
        /**
         * Create the popup.
         * @private
         * @return {?}
         */
        MatTimeSelectComponent.prototype._createPopup = /**
         * Create the popup.
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var overlayConfig = new overlay.OverlayConfig({
                    positionStrategy: this._createPopupPositionStrategy(),
                    hasBackdrop: true,
                    backdropClass: 'mat-overlay-transparent-backdrop',
                    direction: this._dir,
                    scrollStrategy: this._scrollStrategy(),
                    panelClass: 'mat-time-select-popup',
                });
                this._popupRef = this._overlay.create(overlayConfig);
                this._popupRef.overlayElement.setAttribute('role', 'dialog');
                rxjs.merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(operators.filter(function (event) {
                    // Closing on alt + up is only valid when there's an input associated with the time select.
                    return event.keyCode === keycodes.ESCAPE ||
                        (_this._timeSelectInput && event.altKey && event.keyCode === keycodes.UP_ARROW);
                }))).subscribe(function () { return _this.close(); });
            };
        /** Create the popup position strategy. */
        /**
         * Create the popup position strategy.
         * @private
         * @return {?}
         */
        MatTimeSelectComponent.prototype._createPopupPositionStrategy = /**
         * Create the popup position strategy.
         * @private
         * @return {?}
         */
            function () {
                return this._overlay.position()
                    .flexibleConnectedTo(this._timeSelectInput.getConnectedOverlayOrigin())
                    .withTransformOriginOn('.mat-time-select-content')
                    .withFlexibleDimensions(false)
                    .withViewportMargin(8)
                    .withLockedPosition()
                    .withPositions([
                    {
                        originX: 'start',
                        originY: 'bottom',
                        overlayX: 'start',
                        overlayY: 'top'
                    },
                    {
                        originX: 'start',
                        originY: 'top',
                        overlayX: 'start',
                        overlayY: 'bottom'
                    },
                    {
                        originX: 'end',
                        originY: 'bottom',
                        overlayX: 'end',
                        overlayY: 'top'
                    },
                    {
                        originX: 'end',
                        originY: 'top',
                        overlayX: 'end',
                        overlayY: 'bottom'
                    }
                ]);
            };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        /**
         * @private
         * @param {?} obj The object to check.
         * @return {?} The given object if it is both a date instance and valid, otherwise null.
         */
        MatTimeSelectComponent.prototype._getValidDateOrNull = /**
         * @private
         * @param {?} obj The object to check.
         * @return {?} The given object if it is both a date instance and valid, otherwise null.
         */
            function (obj) {
                return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
            };
        /** Passes the current theme color along to the time select overlay. */
        /**
         * Passes the current theme color along to the time select overlay.
         * @private
         * @return {?}
         */
        MatTimeSelectComponent.prototype._setColor = /**
         * Passes the current theme color along to the time select overlay.
         * @private
         * @return {?}
         */
            function () {
                if (this._popupComponentRef) {
                    this._popupComponentRef.instance.color = this.color;
                }
            };
        MatTimeSelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'mat-time-select',
                        template: '',
                        exportAs: 'matTimeSelect',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        MatTimeSelectComponent.ctorParameters = function () {
            return [
                { type: overlay.Overlay },
                { type: core.Injector },
                { type: core.NgZone },
                { type: core.ViewContainerRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TIME_SELECT_SCROLL_STRATEGY,] }] },
                { type: TimeAdapter, decorators: [{ type: core.Optional }] },
                { type: bidi.Directionality, decorators: [{ type: core.Optional }] },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        MatTimeSelectComponent.propDecorators = {
            openStream: [{ type: core.Output, args: ['open',] }],
            closeStream: [{ type: core.Output, args: ['close',] }],
            startAt: [{ type: core.Input }],
            color: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            opened: [{ type: core.Input }]
        };
        return MatTimeSelectComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * An event used for time select input and change events. We don't always have access to a native
     * input or change event because the event may have been triggered by the user clicking on the
     * calendar popup. For consistency, we always use MatTimeSelectInputEvent instead.
     * @template D
     */
    var /**
     * An event used for time select input and change events. We don't always have access to a native
     * input or change event because the event may have been triggered by the user clicking on the
     * calendar popup. For consistency, we always use MatTimeSelectInputEvent instead.
     * @template D
     */ MatTimeSelectInputEvent = /** @class */ (function () {
        function MatTimeSelectInputEvent(target, targetElement) {
            this.target = target;
            this.targetElement = targetElement;
            this.value = this.target.value;
        }
        return MatTimeSelectInputEvent;
    }());
    /**
     * Directive used to connect an input to a MatTimeSelectComponent.
     * @template D
     */
    var MatTimeSelectInputDirective = /** @class */ (function () {
        function MatTimeSelectInputDirective(_elementRef, _timeAdapter, _timeFormats, _formField) {
            var _this = this;
            this._elementRef = _elementRef;
            this._timeAdapter = _timeAdapter;
            this._timeFormats = _timeFormats;
            this._formField = _formField;
            this._timeSelectSubscription = rxjs.Subscription.EMPTY;
            this._localeSubscription = rxjs.Subscription.EMPTY;
            this._valueChange = new rxjs.Subject();
            this._disabledChange = new rxjs.Subject();
            /**
             * Emits when a `change` event is fired on this `<input>`.
             */
            this.timeChange = new core.EventEmitter();
            /**
             * Emits when an `input` event is fired on this `<input>`.
             */
            this.timeInput = new core.EventEmitter();
            /**
             * Emits when the value changes (either due to user input or programmatic change).
             */
            this.valueChange = this._valueChange.asObservable();
            /**
             * Emits when the disabled state has changed.
             */
            this.disabledChange = this._disabledChange.asObservable();
            this._onChange = function () { };
            this._onTouched = function () { };
            this._onValidatorChange = function () { };
            this._parseValidator = function () {
                return _this._lastValueValid ? null : { 'matTimeSelectParse': { 'text': _this._elementRef.nativeElement.value } };
            };
            this._minValidator = function (control) {
                /** @type {?} */
                var value = _this._getValidDateOrNull(_this._timeAdapter.deserialize(control.value));
                return !_this.min || !value || _this._timeAdapter.compareTime(_this.min, value) <= 0 ?
                    null : { 'matTimeSelectMin': { 'min': _this.min, 'actual': value } };
            };
            this._maxValidator = function (control) {
                /** @type {?} */
                var value = _this._getValidDateOrNull(_this._timeAdapter.deserialize(control.value));
                return !_this.max || !value || _this._timeAdapter.compareTime(_this.max, value) >= 0 ?
                    null : { 'matTimeSelectMax': { 'max': _this.max, 'actual': value } };
            };
            this._validator = forms.Validators.compose([
                this._parseValidator,
                this._minValidator,
                this._maxValidator
            ]);
            this._localeSubscription = this._timeAdapter.localeChanges.subscribe(function () { return _this.value = _this.value; });
        }
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "matTimeSelect", {
            /** The time select that this input is associated with. */
            set: /**
             * The time select that this input is associated with.
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (!value) {
                    return;
                }
                this._timeSelect = value;
                this._timeSelect.registerInput(this);
                this._timeSelectSubscription.unsubscribe();
                this._timeSelectSubscription = this._timeSelect.selectedChange.subscribe(function (selected) {
                    _this.value = selected;
                    _this._onChange(selected);
                    _this._onTouched();
                    _this.timeInput.emit(new MatTimeSelectInputEvent(_this, _this._elementRef.nativeElement));
                    _this.timeChange.emit(new MatTimeSelectInputEvent(_this, _this._elementRef.nativeElement));
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "value", {
            /** The value of the input. */
            get: /**
             * The value of the input.
             * @return {?}
             */ function () { return this._value; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = this._timeAdapter.deserialize(value);
                this._lastValueValid = !value || this._timeAdapter.isValid(value);
                value = this._getValidDateOrNull(value);
                /** @type {?} */
                var oldValue = this._value;
                this._value = value;
                this._formatValue(value);
                if (!this._timeAdapter.sameTime(oldValue, value)) {
                    this._valueChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "min", {
            /** The minimum valid date time. */
            get: /**
             * The minimum valid date time.
             * @return {?}
             */ function () { return this._min; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._min = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
                this._onValidatorChange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "max", {
            /** The maximum valid date time. */
            get: /**
             * The maximum valid date time.
             * @return {?}
             */ function () { return this._max; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._max = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
                this._onValidatorChange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "disabled", {
            /** Whether the time select input is disabled. */
            get: /**
             * Whether the time select input is disabled.
             * @return {?}
             */ function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                /** @type {?} */
                var disabled = coercion.coerceBooleanProperty(value);
                /** @type {?} */
                var element = this._elementRef.nativeElement;
                if (this.disabled !== disabled) {
                    this._disabled = disabled;
                    this._disabledChange.next(disabled);
                }
                if (disabled && element.blur) {
                    element.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "_ariaHasPopup", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "_ariaOwns", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return (this._timeSelect && this._timeSelect.opened && !!this._timeSelect.id) || null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "_minTime", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return this.min ? this._timeAdapter.toIso8601(this.min) : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectInputDirective.prototype, "_maxTime", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return this.max ? this._timeAdapter.toIso8601(this.max) : null; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._timeSelectSubscription.unsubscribe();
                this._localeSubscription.unsubscribe();
                this._valueChange.complete();
                this._disabledChange.complete();
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} value
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.writeValue =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.value = value;
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.registerOnChange =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onChange = fn;
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} fn
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.registerOnTouched =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} fn
             * @return {?}
             */
            function (fn) {
                this._onTouched = fn;
            };
        // Implemented as part of ControlValueAccessor.
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.setDisabledState =
            // Implemented as part of ControlValueAccessor.
            /**
             * @param {?} isDisabled
             * @return {?}
             */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} control
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.validate = /**
         * \@docs-private
         * @param {?} control
         * @return {?}
         */
            function (control) {
                return this._validator ? this._validator(control) : null;
            };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.registerOnValidatorChange = /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onValidatorChange = fn;
            };
        /**
         * Handle keydown event.
         * @param event The event object.
         */
        /**
         * Handle keydown event.
         * @param {?} event The event object.
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.onKeydown = /**
         * Handle keydown event.
         * @param {?} event The event object.
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var isAltDownArrow = event.altKey && event.keyCode === keycodes.DOWN_ARROW;
                if (this._timeSelect && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
                    this._timeSelect.open();
                    event.preventDefault();
                }
            };
        /**
         * Handle input event.
         * @param value The current value of the input.
         */
        /**
         * Handle input event.
         * @param {?} value The current value of the input.
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.onInput = /**
         * Handle input event.
         * @param {?} value The current value of the input.
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var time = this._timeAdapter.parse(value, this._timeFormats.parse.timeInput);
                this._lastValueValid = !time || this._timeAdapter.isValid(time);
                time = this._getValidDateOrNull(time);
                if (!this._timeAdapter.sameTime(this._value, time)) {
                    this._value = time;
                    this._onChange(time);
                    this._valueChange.next(time);
                    this.timeInput.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
                }
            };
        /**
         * Handle change event.
         */
        /**
         * Handle change event.
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.onChange = /**
         * Handle change event.
         * @return {?}
         */
            function () {
                this.timeChange.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
            };
        /**
         * Handle blur event.
         */
        /**
         * Handle blur event.
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.onBlur = /**
         * Handle blur event.
         * @return {?}
         */
            function () {
                if (this.value) {
                    this._formatValue(this.value);
                }
                this._onTouched();
            };
        /** Returns the palette used by the input's form field, if any. */
        /**
         * Returns the palette used by the input's form field, if any.
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype.getThemePalette = /**
         * Returns the palette used by the input's form field, if any.
         * @return {?}
         */
            function () {
                return this._formField ? this._formField.color : undefined;
            };
        /**
         * Gets the element that the time select popup should be connected to.
         * @return The element to connect the popup to.
         */
        /**
         * Gets the element that the time select popup should be connected to.
         * @return {?} The element to connect the popup to.
         */
        MatTimeSelectInputDirective.prototype.getConnectedOverlayOrigin = /**
         * Gets the element that the time select popup should be connected to.
         * @return {?} The element to connect the popup to.
         */
            function () {
                return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
            };
        /** Formats a value and sets it on the input element. */
        /**
         * Formats a value and sets it on the input element.
         * @private
         * @param {?} value
         * @return {?}
         */
        MatTimeSelectInputDirective.prototype._formatValue = /**
         * Formats a value and sets it on the input element.
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._elementRef.nativeElement.value = value ? this._timeAdapter.format(value, this._timeFormats.display.timeInput) : '';
            };
        /**
         * @param obj The object to check.
         * @returns The given object if it is both a date instance and valid, otherwise null.
         */
        /**
         * @private
         * @param {?} obj The object to check.
         * @return {?} The given object if it is both a date instance and valid, otherwise null.
         */
        MatTimeSelectInputDirective.prototype._getValidDateOrNull = /**
         * @private
         * @param {?} obj The object to check.
         * @return {?} The given object if it is both a date instance and valid, otherwise null.
         */
            function (obj) {
                return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
            };
        MatTimeSelectInputDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[matTimeSelect]',
                        providers: [
                            { provide: forms.NG_VALUE_ACCESSOR, useExisting: core.forwardRef(function () { return MatTimeSelectInputDirective; }), multi: true },
                            { provide: forms.NG_VALIDATORS, useExisting: core.forwardRef(function () { return MatTimeSelectInputDirective; }), multi: true },
                            { provide: material.MAT_INPUT_VALUE_ACCESSOR, useExisting: MatTimeSelectInputDirective }
                        ],
                        exportAs: 'matTimeSelectInput'
                    },] }
        ];
        /** @nocollapse */
        MatTimeSelectInputDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: TimeAdapter, decorators: [{ type: core.Optional }] },
                { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_TIME_FORMATS,] }] },
                { type: material.MatFormField, decorators: [{ type: core.Optional }] }
            ];
        };
        MatTimeSelectInputDirective.propDecorators = {
            timeChange: [{ type: core.Output }],
            timeInput: [{ type: core.Output }],
            matTimeSelect: [{ type: core.Input }],
            value: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            disabled: [{ type: core.HostBinding }, { type: core.Input }],
            _ariaHasPopup: [{ type: core.HostBinding, args: ['attr.aria-haspopup',] }],
            _ariaOwns: [{ type: core.HostBinding, args: ['attr.aria-owns',] }],
            _minTime: [{ type: core.HostBinding, args: ['attr.min',] }],
            _maxTime: [{ type: core.HostBinding, args: ['attr.max',] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            onInput: [{ type: core.HostListener, args: ['input', ['$event.target.value'],] }],
            onChange: [{ type: core.HostListener, args: ['change',] }],
            onBlur: [{ type: core.HostListener, args: ['blur',] }]
        };
        return MatTimeSelectInputDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Can be used to override the icon of a `matTimeSelectToggle`.
     */
    var MatTimeSelectToggleIconDirective = /** @class */ (function () {
        function MatTimeSelectToggleIconDirective() {
        }
        MatTimeSelectToggleIconDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[matTimeSelectToggleIcon]'
                    },] }
        ];
        return MatTimeSelectToggleIconDirective;
    }());
    /**
     * @template D
     */
    var MatTimeSelectToggleComponent = /** @class */ (function () {
        function MatTimeSelectToggleComponent(_intl, _changeDetectorRef, defaultTabIndex) {
            this._intl = _intl;
            this._changeDetectorRef = _changeDetectorRef;
            this._stateChanges = rxjs.Subscription.EMPTY;
            /** @type {?} */
            var parsedTabIndex = parseInt(defaultTabIndex, 10);
            this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
        }
        Object.defineProperty(MatTimeSelectToggleComponent.prototype, "disabled", {
            /** Whether the toggle button is disabled. */
            get: /**
             * Whether the toggle button is disabled.
             * @return {?}
             */ function () {
                return this._disabled === undefined ? this.timeSelect.disabled : this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectToggleComponent.prototype, "disableRipple", {
            /** Whether ripples on the toggle should be disabled. */
            get: /**
             * Whether ripples on the toggle should be disabled.
             * @return {?}
             */ function () {
                return this._disableRipple;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disableRipple = coercion.coerceBooleanProperty(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectToggleComponent.prototype, "class", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return 'mat-time-select-toggle'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectToggleComponent.prototype, "tabindex", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return '-1'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectToggleComponent.prototype, "active", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return this.timeSelect && this.timeSelect.opened; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectToggleComponent.prototype, "accent", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return this.timeSelect && this.timeSelect.color === 'accent'; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MatTimeSelectToggleComponent.prototype, "warn", {
            /** @docs-private */
            get: /**
             * \@docs-private
             * @return {?}
             */ function () { return this.timeSelect && this.timeSelect.color === 'warn'; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MatTimeSelectToggleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this._watchStateChanges();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        MatTimeSelectToggleComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes.timeSelect) {
                    this._watchStateChanges();
                }
            };
        /**
         * @return {?}
         */
        MatTimeSelectToggleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._stateChanges.unsubscribe();
            };
        /** Handle focus event. */
        /**
         * Handle focus event.
         * @return {?}
         */
        MatTimeSelectToggleComponent.prototype.onFocus = /**
         * Handle focus event.
         * @return {?}
         */
            function () {
                this.button.focus();
            };
        /**
         * Open the time select.
         * @param event The triggered event to open the time select.
         */
        /**
         * Open the time select.
         * @param {?} event The triggered event to open the time select.
         * @return {?}
         */
        MatTimeSelectToggleComponent.prototype.open = /**
         * Open the time select.
         * @param {?} event The triggered event to open the time select.
         * @return {?}
         */
            function (event) {
                if (this.timeSelect && !this.disabled) {
                    this.timeSelect.open();
                    event.stopPropagation();
                }
            };
        /**
         * @private
         * @return {?}
         */
        MatTimeSelectToggleComponent.prototype._watchStateChanges = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var timeSelectDisabled = this.timeSelect ? this.timeSelect.disabledChange : rxjs.of();
                /** @type {?} */
                var inputDisabled = this.timeSelect && this.timeSelect._timeSelectInput ?
                    this.timeSelect._timeSelectInput.disabledChange : rxjs.of();
                /** @type {?} */
                var timeSelectToggled = this.timeSelect ?
                    rxjs.merge(this.timeSelect.openStream, this.timeSelect.closeStream) :
                    rxjs.of();
                this._stateChanges.unsubscribe();
                this._stateChanges = rxjs.merge(this._intl.changes, timeSelectDisabled, inputDisabled, timeSelectToggled).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
            };
        MatTimeSelectToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'mat-time-select-toggle',
                        template: "<button\r\n  #button\r\n  mat-icon-button\r\n  type=\"button\"\r\n  aria-haspopup=\"true\"\r\n  [attr.aria-label]=\"_intl.openTimeSelectLabel\"\r\n  [attr.tabindex]=\"disabled ? -1 : tabIndex\"\r\n  [disabled]=\"disabled\"\r\n  [disableRipple]=\"disableRipple\"\r\n  (click)=\"open($event)\">\r\n\r\n  <svg\r\n    *ngIf=\"!customIcon\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    class=\"mat-time-select-toggle-default-icon\"\r\n    viewBox=\"0 0 24 24\"\r\n    width=\"24px\"\r\n    height=\"24px\"\r\n    fill=\"currentColor\"\r\n    focusable=\"false\">\r\n    <path d=\"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z\"/>\r\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\r\n    <path d=\"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z\"/>\r\n  </svg>\r\n\r\n  <ng-content select=\"[matTimeSelectToggleIcon]\"></ng-content>\r\n</button>\r\n",
                        exportAs: 'matTimeSelectToggle',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-time-select-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-time-select-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-time-select-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-time-select-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-time-select-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-time-select-toggle-default-icon{margin:auto}"]
                    }] }
        ];
        /** @nocollapse */
        MatTimeSelectToggleComponent.ctorParameters = function () {
            return [
                { type: MatTimeSelectIntl },
                { type: core.ChangeDetectorRef },
                { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }
            ];
        };
        MatTimeSelectToggleComponent.propDecorators = {
            timeSelect: [{ type: core.Input, args: ['for',] }],
            tabIndex: [{ type: core.Input }],
            customIcon: [{ type: core.ContentChild, args: [MatTimeSelectToggleIconDirective,] }],
            button: [{ type: core.ViewChild, args: ['button',] }],
            disabled: [{ type: core.Input }],
            disableRipple: [{ type: core.Input }],
            class: [{ type: core.HostBinding, args: ['class',] }],
            tabindex: [{ type: core.HostBinding, args: ['attr.tabindex',] }],
            active: [{ type: core.HostBinding, args: ['class.mat-time-select-toggle-active',] }],
            accent: [{ type: core.HostBinding, args: ['class.mat-accent',] }],
            warn: [{ type: core.HostBinding, args: ['class.mat-warn',] }],
            onFocus: [{ type: core.HostListener, args: ['focus',] }]
        };
        return MatTimeSelectToggleComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MatTimeSelectModule = /** @class */ (function () {
        function MatTimeSelectModule() {
        }
        MatTimeSelectModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            a11y.A11yModule,
                            portal.PortalModule,
                            material.MatButtonModule,
                            material.MatButtonToggleModule,
                            material.MatIconModule,
                            material.MatRippleModule
                        ],
                        declarations: [
                            MatTimeSelectComponent,
                            MatTimeSelectContentComponent,
                            MatTimeSelectInputDirective,
                            MatTimeSelectToggleComponent,
                            MatTimeSelectToggleIconDirective,
                            MatTimeUnitOptionComponent,
                            MatTimeUnitSelectComponent
                        ],
                        exports: [
                            MatTimeSelectComponent,
                            MatTimeSelectContentComponent,
                            MatTimeSelectInputDirective,
                            MatTimeSelectToggleComponent,
                            MatTimeSelectToggleIconDirective,
                            MatTimeUnitOptionComponent,
                            MatTimeUnitSelectComponent
                        ],
                        entryComponents: [
                            MatTimeSelectContentComponent
                        ],
                        providers: [
                            MatTimeSelectIntl,
                            MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER
                        ]
                    },] }
        ];
        return MatTimeSelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var moment = _moment;
    /**
     * Adapts the native JS Date for use with cdk-based components that work with times.
     */
    var NativeTimeAdapter = /** @class */ (function (_super) {
        __extends(NativeTimeAdapter, _super);
        function NativeTimeAdapter(locale, _dateAdapter) {
            var _this = _super.call(this) || this;
            _this._dateAdapter = _dateAdapter;
            _this.setLocale(locale);
            return _this;
        }
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getYear = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._dateAdapter.getYear(date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getMonth = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._dateAdapter.getMonth(date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getDate = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._dateAdapter.getDate(date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getDayOfWeek = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._dateAdapter.getDayOfWeek(date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getHour = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return date.getHours();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getMinute = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return date.getMinutes();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getSecond = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return date.getSeconds();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getYearName = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._dateAdapter.getYearName(date);
            };
        /**
         * @param {?} style
         * @return {?}
         */
        NativeTimeAdapter.prototype.getMonthNames = /**
         * @param {?} style
         * @return {?}
         */
            function (style) {
                return this._dateAdapter.getMonthNames(style);
            };
        /**
         * @return {?}
         */
        NativeTimeAdapter.prototype.getDateNames = /**
         * @return {?}
         */
            function () {
                return this._dateAdapter.getDateNames();
            };
        /**
         * @param {?} style
         * @return {?}
         */
        NativeTimeAdapter.prototype.getDayOfWeekNames = /**
         * @param {?} style
         * @return {?}
         */
            function (style) {
                return this._dateAdapter.getDayOfWeekNames(style);
            };
        /**
         * @return {?}
         */
        NativeTimeAdapter.prototype.getFirstDayOfWeek = /**
         * @return {?}
         */
            function () {
                return this._dateAdapter.getFirstDayOfWeek();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.getNumDaysInMonth = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._dateAdapter.getNumDaysInMonth(date);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.clone = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return new Date(date.getTime());
            };
        /**
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.createDate = /**
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
            function (year, month, date) {
                return this._dateAdapter.createDate(year, month, date);
            };
        /**
         * @param {?=} hour
         * @param {?=} minute
         * @param {?=} second
         * @return {?}
         */
        NativeTimeAdapter.prototype.createTime = /**
         * @param {?=} hour
         * @param {?=} minute
         * @param {?=} second
         * @return {?}
         */
            function (hour, minute, second) {
                if (hour === void 0) {
                    hour = 0;
                }
                if (minute === void 0) {
                    minute = 0;
                }
                if (second === void 0) {
                    second = 0;
                }
                if (hour < 0 || hour > 23) {
                    throw new Error("Invalid hour " + hour + ". Hour has to be between 0 and 23.");
                }
                if (minute < 0 || minute > 59) {
                    throw new Error("Invalid minute " + minute + ". Minute has to be between 0 and 59.");
                }
                if (second < 0 || second > 59) {
                    throw new Error("Invalid second " + second + ". Second has to be between 0 and 59.");
                }
                /** @type {?} */
                var date = new Date();
                date.setHours(hour, minute, second);
                return date;
            };
        /**
         * @return {?}
         */
        NativeTimeAdapter.prototype.today = /**
         * @return {?}
         */
            function () {
                return this.now();
            };
        /**
         * @return {?}
         */
        NativeTimeAdapter.prototype.now = /**
         * @return {?}
         */
            function () {
                return new Date(Date.now());
            };
        /**
         * @param {?} value
         * @param {?} parseFormat
         * @return {?}
         */
        NativeTimeAdapter.prototype.parse = /**
         * @param {?} value
         * @param {?} parseFormat
         * @return {?}
         */
            function (value, parseFormat) {
                return this._dateAdapter.parse(value, parseFormat);
            };
        /**
         * @param {?} date
         * @param {?} displayFormat
         * @return {?}
         */
        NativeTimeAdapter.prototype.format = /**
         * @param {?} date
         * @param {?} displayFormat
         * @return {?}
         */
            function (date, displayFormat) {
                return this._dateAdapter.format(date, displayFormat);
            };
        /**
         * @param {?} date
         * @param {?} years
         * @return {?}
         */
        NativeTimeAdapter.prototype.addCalendarYears = /**
         * @param {?} date
         * @param {?} years
         * @return {?}
         */
            function (date, years) {
                return this._dateAdapter.addCalendarYears(date, years);
            };
        /**
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
        NativeTimeAdapter.prototype.addCalendarMonths = /**
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
            function (date, months) {
                return this._dateAdapter.addCalendarMonths(date, months);
            };
        /**
         * @param {?} date
         * @param {?} days
         * @return {?}
         */
        NativeTimeAdapter.prototype.addCalendarDays = /**
         * @param {?} date
         * @param {?} days
         * @return {?}
         */
            function (date, days) {
                return this._dateAdapter.addCalendarDays(date, days);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.toIso8601 = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                /** @type {?} */
                var dateString = this._dateAdapter.toIso8601(date);
                /** @type {?} */
                var timeString = [
                    this._2digit(date.getUTCHours()),
                    this._2digit(date.getUTCMinutes()),
                    this._2digit(date.getUTCSeconds())
                ].join(':');
                return dateString + "T" + timeString + "Z";
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.toMoment = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return moment(date).locale(this.locale);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NativeTimeAdapter.prototype.deserialize = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this._dateAdapter.deserialize(value);
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        NativeTimeAdapter.prototype.isDateInstance = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                return this._dateAdapter.isDateInstance(obj);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        NativeTimeAdapter.prototype.isValid = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this._dateAdapter.isValid(date);
            };
        /**
         * @return {?}
         */
        NativeTimeAdapter.prototype.invalid = /**
         * @return {?}
         */
            function () {
                return this._dateAdapter.invalid();
            };
        /**
         * Pads a number to make it two digits.
         * @param n The number to pad.
         * @returns The padded number.
         */
        /**
         * Pads a number to make it two digits.
         * @private
         * @param {?} n The number to pad.
         * @return {?} The padded number.
         */
        NativeTimeAdapter.prototype._2digit = /**
         * Pads a number to make it two digits.
         * @private
         * @param {?} n The number to pad.
         * @return {?} The padded number.
         */
            function (n) {
                return ('00' + n).slice(-2);
            };
        NativeTimeAdapter.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NativeTimeAdapter.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_DATE_LOCALE,] }] },
                { type: material.DateAdapter, decorators: [{ type: core.Optional }] }
            ];
        };
        return NativeTimeAdapter;
    }(TimeAdapter));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAT_NATIVE_TIME_FORMATS = {
        parse: {
            timeInput: null
        },
        display: {
            timeInput: { hour: 'numeric', minute: 'numeric' },
            timeA11yLabel: { hour: 'numeric', minute: '2-digit' }
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ɵ0 = MAT_NATIVE_TIME_FORMATS;
    var MatNativeTimeModule = /** @class */ (function () {
        function MatNativeTimeModule() {
        }
        MatNativeTimeModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [
                            { provide: TimeAdapter, useClass: NativeTimeAdapter, deps: [material.MAT_DATE_LOCALE, material.DateAdapter] },
                            { provide: MAT_TIME_FORMATS, useValue: ɵ0 }
                        ]
                    },] }
        ];
        return MatNativeTimeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var moment$1 = _moment;
    /**
     * Adapts Moment.js Dates for use with Angular Material.
     */
    var MomentTimeAdapter = /** @class */ (function (_super) {
        __extends(MomentTimeAdapter, _super);
        function MomentTimeAdapter(locale, _dateAdapter) {
            var _this = _super.call(this) || this;
            _this._dateAdapter = _dateAdapter;
            _this.setLocale(locale || moment$1.locale());
            return _this;
        }
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getYear = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).year();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getMonth = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).month();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getDate = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).date();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getDayOfWeek = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).day();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getHour = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).hour();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getMinute = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).minute();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getSecond = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).second();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.clone = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return date.clone().locale(this.locale);
            };
        /**
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.createDate = /**
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
            function (year, month, date) {
                return this.clone(this._dateAdapter.createDate(year, month, date));
            };
        /**
         * @param {?=} hour
         * @param {?=} minute
         * @param {?=} second
         * @return {?}
         */
        MomentTimeAdapter.prototype.createTime = /**
         * @param {?=} hour
         * @param {?=} minute
         * @param {?=} second
         * @return {?}
         */
            function (hour, minute, second) {
                if (hour === void 0) {
                    hour = 0;
                }
                if (minute === void 0) {
                    minute = 0;
                }
                if (second === void 0) {
                    second = 0;
                }
                if (hour < 0 || hour > 23) {
                    throw new Error("Invalid hour " + hour + ". Hour has to be between 0 and 23.");
                }
                if (minute < 0 || minute > 59) {
                    throw new Error("Invalid minute " + minute + ". Minute has to be between 0 and 59.");
                }
                if (second < 0 || second > 59) {
                    throw new Error("Invalid second " + second + ". Second has to be between 0 and 59.");
                }
                return moment$1({ hour: hour, minute: minute, second: second }).locale(this.locale);
            };
        /**
         * @return {?}
         */
        MomentTimeAdapter.prototype.today = /**
         * @return {?}
         */
            function () {
                return this.now();
            };
        /**
         * @return {?}
         */
        MomentTimeAdapter.prototype.now = /**
         * @return {?}
         */
            function () {
                return moment$1().locale(this.locale);
            };
        /**
         * @param {?} value
         * @param {?} parseFormat
         * @return {?}
         */
        MomentTimeAdapter.prototype.parse = /**
         * @param {?} value
         * @param {?} parseFormat
         * @return {?}
         */
            function (value, parseFormat) {
                if (value && typeof value === 'string') {
                    return moment$1(value, parseFormat, this.locale);
                }
                return value ? moment$1(value).locale(this.locale) : null;
            };
        /**
         * @param {?} date
         * @param {?} displayFormat
         * @return {?}
         */
        MomentTimeAdapter.prototype.format = /**
         * @param {?} date
         * @param {?} displayFormat
         * @return {?}
         */
            function (date, displayFormat) {
                date = this.clone(date);
                if (!this.isValid(date)) {
                    throw new Error('MomentTimeAdapter: Cannot format invalid date.');
                }
                return date.format(displayFormat);
            };
        /**
         * @param {?} date
         * @param {?} years
         * @return {?}
         */
        MomentTimeAdapter.prototype.addCalendarYears = /**
         * @param {?} date
         * @param {?} years
         * @return {?}
         */
            function (date, years) {
                return this.clone(date).add({ years: years });
            };
        /**
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
        MomentTimeAdapter.prototype.addCalendarMonths = /**
         * @param {?} date
         * @param {?} months
         * @return {?}
         */
            function (date, months) {
                return this.clone(date).add({ months: months });
            };
        /**
         * @param {?} date
         * @param {?} days
         * @return {?}
         */
        MomentTimeAdapter.prototype.addCalendarDays = /**
         * @param {?} date
         * @param {?} days
         * @return {?}
         */
            function (date, days) {
                return this.clone(date).add({ days: days });
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.toIso8601 = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).format();
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.toMoment = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        MomentTimeAdapter.prototype.deserialize = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                /** @type {?} */
                var date;
                if (value instanceof Date) {
                    date = moment$1(value);
                }
                if (typeof value === 'string') {
                    if (!value) {
                        return null;
                    }
                    date = moment$1(value, moment$1.ISO_8601);
                }
                if (date && this.isValid(date)) {
                    return date;
                }
                return _super.prototype.deserialize.call(this, value);
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        MomentTimeAdapter.prototype.isDateInstance = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                return moment$1.isMoment(obj);
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.isValid = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return this.clone(date).isValid();
            };
        /**
         * @return {?}
         */
        MomentTimeAdapter.prototype.invalid = /**
         * @return {?}
         */
            function () {
                return moment$1.invalid();
            };
        /**
         * @return {?}
         */
        MomentTimeAdapter.prototype.getDateNames = /**
         * @return {?}
         */
            function () {
                return [];
            };
        /**
         * @param {?} style
         * @return {?}
         */
        MomentTimeAdapter.prototype.getDayOfWeekNames = /**
         * @param {?} style
         * @return {?}
         */
            function (style) {
                return [];
            };
        /**
         * @return {?}
         */
        MomentTimeAdapter.prototype.getFirstDayOfWeek = /**
         * @return {?}
         */
            function () {
                return 0;
            };
        /**
         * @param {?} style
         * @return {?}
         */
        MomentTimeAdapter.prototype.getMonthNames = /**
         * @param {?} style
         * @return {?}
         */
            function (style) {
                return [];
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getNumDaysInMonth = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return 0;
            };
        /**
         * @param {?} date
         * @return {?}
         */
        MomentTimeAdapter.prototype.getYearName = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                return '';
            };
        MomentTimeAdapter.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        MomentTimeAdapter.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_DATE_LOCALE,] }] },
                { type: material.DateAdapter, decorators: [{ type: core.Optional }] }
            ];
        };
        return MomentTimeAdapter;
    }(TimeAdapter));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var MAT_MOMENT_TIME_FORMATS = {
        parse: {
            timeInput: 'LT'
        },
        display: {
            timeInput: 'LT',
            timeA11yLabel: 'LT'
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ɵ0$1 = MAT_MOMENT_TIME_FORMATS;
    var MatMomentTimeModule = /** @class */ (function () {
        function MatMomentTimeModule() {
        }
        MatMomentTimeModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [
                            { provide: TimeAdapter, useClass: MomentTimeAdapter, deps: [material.MAT_DATE_LOCALE, material.DateAdapter] },
                            { provide: MAT_TIME_FORMATS, useValue: ɵ0$1 }
                        ]
                    },] }
        ];
        return MatMomentTimeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.TimeAdapter = TimeAdapter;
    exports.MAT_TIME_FORMATS = MAT_TIME_FORMATS;
    exports.MatTimeSelectIntl = MatTimeSelectIntl;
    exports.MatTimeUnitOptionBase = MatTimeUnitOptionBase;
    exports._MatTimeUnitOptionMixinBase = _MatTimeUnitOptionMixinBase;
    exports.MatTimeUnitOptionComponent = MatTimeUnitOptionComponent;
    exports.MatTimeUnitSelectComponent = MatTimeUnitSelectComponent;
    exports.MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY = MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY;
    exports.MAT_TIME_SELECT_DATA = MAT_TIME_SELECT_DATA;
    exports.MAT_TIME_SELECT_SCROLL_STRATEGY = MAT_TIME_SELECT_SCROLL_STRATEGY;
    exports.MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER = MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER;
    exports.MatTimeSelectContentBase = MatTimeSelectContentBase;
    exports._MatTimeSelectContentMixinBase = _MatTimeSelectContentMixinBase;
    exports.MatTimeSelectContentComponent = MatTimeSelectContentComponent;
    exports.MatTimeSelectComponent = MatTimeSelectComponent;
    exports.MatTimeSelectInputEvent = MatTimeSelectInputEvent;
    exports.MatTimeSelectInputDirective = MatTimeSelectInputDirective;
    exports.MatTimeSelectToggleIconDirective = MatTimeSelectToggleIconDirective;
    exports.MatTimeSelectToggleComponent = MatTimeSelectToggleComponent;
    exports.MatTimeSelectModule = MatTimeSelectModule;
    exports.NativeTimeAdapter = NativeTimeAdapter;
    exports.MAT_NATIVE_TIME_FORMATS = MAT_NATIVE_TIME_FORMATS;
    exports.MatNativeTimeModule = MatNativeTimeModule;
    exports.MomentTimeAdapter = MomentTimeAdapter;
    exports.MAT_MOMENT_TIME_FORMATS = MAT_MOMENT_TIME_FORMATS;
    exports.MatMomentTimeModule = MatMomentTimeModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-material-time-select.umd.js.map