/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DateAdapter } from '@angular/material';
/**
 * Adapts date object to be usable as a date time by cdk-based components that work with dates.
 * @abstract
 * @template D
 */
var /**
 * Adapts date object to be usable as a date time by cdk-based components that work with dates.
 * @abstract
 * @template D
 */
TimeAdapter = /** @class */ (function (_super) {
    tslib_1.__extends(TimeAdapter, _super);
    function TimeAdapter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Compares two date times.
     * @param first The first date to compare.
     * @param second The second date to compare.
     * @returns 0 if the date times are equal, a number less than 0 if the first date time is earlier,
     *     a number greater than 0 if the first date time is later.
     */
    /**
     * Compares two date times.
     * @param {?} first The first date to compare.
     * @param {?} second The second date to compare.
     * @return {?} 0 if the date times are equal, a number less than 0 if the first date time is earlier,
     *     a number greater than 0 if the first date time is later.
     */
    TimeAdapter.prototype.compareTime = /**
     * Compares two date times.
     * @param {?} first The first date to compare.
     * @param {?} second The second date to compare.
     * @return {?} 0 if the date times are equal, a number less than 0 if the first date time is earlier,
     *     a number greater than 0 if the first date time is later.
     */
    function (first, second) {
        return this.compareDate(first, second) ||
            this.getHour(first) - this.getHour(second) ||
            this.getMinute(first) - this.getMinute(second) ||
            this.getSecond(first) - this.getSecond(second);
    };
    /**
     * Checks if two date times are equal.
     * @param first The first date to check.
     * @param second The second date to check.
     * @returns Whether the two date times are equal.
     *     Null dates are considered equal to other null dates.
     */
    /**
     * Checks if two date times are equal.
     * @param {?} first The first date to check.
     * @param {?} second The second date to check.
     * @return {?} Whether the two date times are equal.
     *     Null dates are considered equal to other null dates.
     */
    TimeAdapter.prototype.sameTime = /**
     * Checks if two date times are equal.
     * @param {?} first The first date to check.
     * @param {?} second The second date to check.
     * @return {?} Whether the two date times are equal.
     *     Null dates are considered equal to other null dates.
     */
    function (first, second) {
        if (first && second) {
            /** @type {?} */
            var firstValid = this.isValid(first);
            /** @type {?} */
            var secondValid = this.isValid(second);
            if (firstValid && secondValid) {
                return !this.compareTime(first, second);
            }
            return firstValid === secondValid;
        }
        return first === second;
    };
    /**
     * Clamp the given date between min and max date times.
     * @param date The date to clamp.
     * @param min The minimum value to allow. If null or omitted no min is enforced.
     * @param max The maximum value to allow. If null or omitted no max is enforced.
     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,
     *     otherwise `date`.
     */
    /**
     * Clamp the given date between min and max date times.
     * @param {?} date The date to clamp.
     * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
     * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
     * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
     *     otherwise `date`.
     */
    TimeAdapter.prototype.clampTime = /**
     * Clamp the given date between min and max date times.
     * @param {?} date The date to clamp.
     * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
     * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
     * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
     *     otherwise `date`.
     */
    function (date, min, max) {
        if (min && this.compareTime(date, min) < 0) {
            return min;
        }
        if (max && this.compareTime(date, max) > 0) {
            return max;
        }
        return date;
    };
    return TimeAdapter;
}(DateAdapter));
/**
 * Adapts date object to be usable as a date time by cdk-based components that work with dates.
 * @abstract
 * @template D
 */
export { TimeAdapter };
if (false) {
    /**
     * Gets the hour component of the given date.
     * @abstract
     * @param {?} date The date to extract the hour from.
     * @return {?} The hour component (0-indexed, 0 = midnight).
     */
    TimeAdapter.prototype.getHour = function (date) { };
    /**
     * Gets the minute component of the given date.
     * @abstract
     * @param {?} date The date to extract the minute from.
     * @return {?} The minute component (0-indexed, 0 = start of hour).
     */
    TimeAdapter.prototype.getMinute = function (date) { };
    /**
     * Gets the second component of the given date.
     * @abstract
     * @param {?} date The date to extract the second from.
     * @return {?} The second component (0-indexed, 0 = start of minute).
     */
    TimeAdapter.prototype.getSecond = function (date) { };
    /**
     * Create a date with the given hour, minute and second. Does not allow over/under-flow of the
     * hour, minute and second.
     * @abstract
     * @param {?=} hour The hour of the date. Must be an integer 0 - 23.
     * @param {?=} minute The minute of the date. Must be an integer 0 - 59.
     * @param {?=} second The second of the date. Must be an integer 0 - 59.
     * @return {?} The new date.
     */
    TimeAdapter.prototype.createTime = function (hour, minute, second) { };
    /**
     * Gets the current date.
     * @abstract
     * @return {?} The current date.
     */
    TimeAdapter.prototype.now = function () { };
    /**
     * Convert the given date to a Moment object.
     * @abstract
     * @param {?} date the date object to convert.
     * @return {?}
     */
    TimeAdapter.prototype.toMoment = function (date) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1hZGFwdGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbWF0ZXJpYWwtdGltZS1zZWxlY3QvIiwic291cmNlcyI6WyJsaWIvdGltZS1hZGFwdGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7Ozs7OztBQUk5Qzs7Ozs7O0lBQTZDLHVDQUFjO0lBQTNEOztJQWdHQSxDQUFDO0lBbkRDOzs7Ozs7T0FNRzs7Ozs7Ozs7SUFDSCxpQ0FBVzs7Ozs7OztJQUFYLFVBQVksS0FBUSxFQUFFLE1BQVM7UUFDN0IsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUM7WUFDcEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUMxQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1lBQzlDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7OztPQU1HOzs7Ozs7OztJQUNILDhCQUFROzs7Ozs7O0lBQVIsVUFBUyxLQUFlLEVBQUUsTUFBZ0I7UUFDeEMsSUFBSSxLQUFLLElBQUksTUFBTSxFQUFFOztnQkFDYixVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7O2dCQUNoQyxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7WUFDeEMsSUFBSSxVQUFVLElBQUksV0FBVyxFQUFFO2dCQUM3QixPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDekM7WUFDRCxPQUFPLFVBQVUsS0FBSyxXQUFXLENBQUM7U0FDbkM7UUFDRCxPQUFPLEtBQUssS0FBSyxNQUFNLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7Ozs7Ozs7OztJQUNILCtCQUFTOzs7Ozs7OztJQUFULFVBQVUsSUFBTyxFQUFFLEdBQWMsRUFBRSxHQUFjO1FBQy9DLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMxQyxPQUFPLEdBQUcsQ0FBQztTQUNaO1FBQ0QsSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzFDLE9BQU8sR0FBRyxDQUFDO1NBQ1o7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFSCxrQkFBQztBQUFELENBQUMsQUFoR0QsQ0FBNkMsV0FBVyxHQWdHdkQ7Ozs7Ozs7Ozs7Ozs7O0lBekZDLG9EQUFrQzs7Ozs7OztJQU9sQyxzREFBb0M7Ozs7Ozs7SUFPcEMsc0RBQW9DOzs7Ozs7Ozs7O0lBVXBDLHVFQUF3RTs7Ozs7O0lBTXhFLDRDQUFrQjs7Ozs7OztJQU1sQixxREFBbUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RhdGVBZGFwdGVyfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcbmltcG9ydCB7TW9tZW50fSBmcm9tICdtb21lbnQnO1xyXG5cclxuLyoqIEFkYXB0cyBkYXRlIG9iamVjdCB0byBiZSB1c2FibGUgYXMgYSBkYXRlIHRpbWUgYnkgY2RrLWJhc2VkIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUaW1lQWRhcHRlcjxEPiBleHRlbmRzIERhdGVBZGFwdGVyPEQ+IHtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgaG91ciBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZXh0cmFjdCB0aGUgaG91ciBmcm9tLlxyXG4gICAqIEByZXR1cm5zIFRoZSBob3VyIGNvbXBvbmVudCAoMC1pbmRleGVkLCAwID0gbWlkbmlnaHQpLlxyXG4gICAqL1xyXG4gIGFic3RyYWN0IGdldEhvdXIoZGF0ZTogRCk6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbWludXRlIGNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSBtaW51dGUgZnJvbS5cclxuICAgKiBAcmV0dXJucyBUaGUgbWludXRlIGNvbXBvbmVudCAoMC1pbmRleGVkLCAwID0gc3RhcnQgb2YgaG91cikuXHJcbiAgICovXHJcbiAgYWJzdHJhY3QgZ2V0TWludXRlKGRhdGU6IEQpOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHNlY29uZCBjb21wb25lbnQgb2YgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZXh0cmFjdCB0aGUgc2Vjb25kIGZyb20uXHJcbiAgICogQHJldHVybnMgVGhlIHNlY29uZCBjb21wb25lbnQgKDAtaW5kZXhlZCwgMCA9IHN0YXJ0IG9mIG1pbnV0ZSkuXHJcbiAgICovXHJcbiAgYWJzdHJhY3QgZ2V0U2Vjb25kKGRhdGU6IEQpOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGRhdGUgd2l0aCB0aGUgZ2l2ZW4gaG91ciwgbWludXRlIGFuZCBzZWNvbmQuIERvZXMgbm90IGFsbG93IG92ZXIvdW5kZXItZmxvdyBvZiB0aGVcclxuICAgKiBob3VyLCBtaW51dGUgYW5kIHNlY29uZC5cclxuICAgKiBAcGFyYW0gaG91ciBUaGUgaG91ciBvZiB0aGUgZGF0ZS4gTXVzdCBiZSBhbiBpbnRlZ2VyIDAgLSAyMy5cclxuICAgKiBAcGFyYW0gbWludXRlIFRoZSBtaW51dGUgb2YgdGhlIGRhdGUuIE11c3QgYmUgYW4gaW50ZWdlciAwIC0gNTkuXHJcbiAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIG9mIHRoZSBkYXRlLiBNdXN0IGJlIGFuIGludGVnZXIgMCAtIDU5LlxyXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgZGF0ZS5cclxuICAgKi9cclxuICBhYnN0cmFjdCBjcmVhdGVUaW1lKGhvdXI/OiBudW1iZXIsIG1pbnV0ZT86IG51bWJlciwgc2Vjb25kPzogbnVtYmVyKTogRDtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgY3VycmVudCBkYXRlLlxyXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGRhdGUuXHJcbiAgICovXHJcbiAgYWJzdHJhY3Qgbm93KCk6IEQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgdGhlIGdpdmVuIGRhdGUgdG8gYSBNb21lbnQgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIG9iamVjdCB0byBjb252ZXJ0LlxyXG4gICAqL1xyXG4gIGFic3RyYWN0IHRvTW9tZW50KGRhdGU6IEQpOiBNb21lbnQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBhcmVzIHR3byBkYXRlIHRpbWVzLlxyXG4gICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlLlxyXG4gICAqIEBwYXJhbSBzZWNvbmQgVGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmUuXHJcbiAgICogQHJldHVybnMgMCBpZiB0aGUgZGF0ZSB0aW1lcyBhcmUgZXF1YWwsIGEgbnVtYmVyIGxlc3MgdGhhbiAwIGlmIHRoZSBmaXJzdCBkYXRlIHRpbWUgaXMgZWFybGllcixcclxuICAgKiAgICAgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAgaWYgdGhlIGZpcnN0IGRhdGUgdGltZSBpcyBsYXRlci5cclxuICAgKi9cclxuICBjb21wYXJlVGltZShmaXJzdDogRCwgc2Vjb25kOiBEKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVEYXRlKGZpcnN0LCBzZWNvbmQpIHx8XHJcbiAgICAgIHRoaXMuZ2V0SG91cihmaXJzdCkgLSB0aGlzLmdldEhvdXIoc2Vjb25kKSB8fFxyXG4gICAgICB0aGlzLmdldE1pbnV0ZShmaXJzdCkgLSB0aGlzLmdldE1pbnV0ZShzZWNvbmQpIHx8XHJcbiAgICAgIHRoaXMuZ2V0U2Vjb25kKGZpcnN0KSAtIHRoaXMuZ2V0U2Vjb25kKHNlY29uZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdHdvIGRhdGUgdGltZXMgYXJlIGVxdWFsLlxyXG4gICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjaGVjay5cclxuICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgZGF0ZSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0d28gZGF0ZSB0aW1lcyBhcmUgZXF1YWwuXHJcbiAgICogICAgIE51bGwgZGF0ZXMgYXJlIGNvbnNpZGVyZWQgZXF1YWwgdG8gb3RoZXIgbnVsbCBkYXRlcy5cclxuICAgKi9cclxuICBzYW1lVGltZShmaXJzdDogRCB8IG51bGwsIHNlY29uZDogRCB8IG51bGwpOiBib29sZWFuIHtcclxuICAgIGlmIChmaXJzdCAmJiBzZWNvbmQpIHtcclxuICAgICAgY29uc3QgZmlyc3RWYWxpZCA9IHRoaXMuaXNWYWxpZChmaXJzdCk7XHJcbiAgICAgIGNvbnN0IHNlY29uZFZhbGlkID0gdGhpcy5pc1ZhbGlkKHNlY29uZCk7XHJcbiAgICAgIGlmIChmaXJzdFZhbGlkICYmIHNlY29uZFZhbGlkKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbXBhcmVUaW1lKGZpcnN0LCBzZWNvbmQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaXJzdFZhbGlkID09PSBzZWNvbmRWYWxpZDtcclxuICAgIH1cclxuICAgIHJldHVybiBmaXJzdCA9PT0gc2Vjb25kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXAgdGhlIGdpdmVuIGRhdGUgYmV0d2VlbiBtaW4gYW5kIG1heCBkYXRlIHRpbWVzLlxyXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGNsYW1wLlxyXG4gICAqIEBwYXJhbSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gYWxsb3cuIElmIG51bGwgb3Igb21pdHRlZCBubyBtaW4gaXMgZW5mb3JjZWQuXHJcbiAgICogQHBhcmFtIG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byBhbGxvdy4gSWYgbnVsbCBvciBvbWl0dGVkIG5vIG1heCBpcyBlbmZvcmNlZC5cclxuICAgKiBAcmV0dXJucyBgbWluYCBpZiBgZGF0ZWAgaXMgbGVzcyB0aGFuIGBtaW5gLCBgbWF4YCBpZiBkYXRlIGlzIGdyZWF0ZXIgdGhhbiBgbWF4YCxcclxuICAgKiAgICAgb3RoZXJ3aXNlIGBkYXRlYC5cclxuICAgKi9cclxuICBjbGFtcFRpbWUoZGF0ZTogRCwgbWluPzogRCB8IG51bGwsIG1heD86IEQgfCBudWxsKTogRCB7XHJcbiAgICBpZiAobWluICYmIHRoaXMuY29tcGFyZVRpbWUoZGF0ZSwgbWluKSA8IDApIHtcclxuICAgICAgcmV0dXJuIG1pbjtcclxuICAgIH1cclxuICAgIGlmIChtYXggJiYgdGhpcy5jb21wYXJlVGltZShkYXRlLCBtYXgpID4gMCkge1xyXG4gICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGU7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=