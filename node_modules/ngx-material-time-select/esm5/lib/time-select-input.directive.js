/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, forwardRef, HostBinding, HostListener, Inject, Input, Optional, Output } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { DOWN_ARROW } from '@angular/cdk/keycodes';
import { MAT_INPUT_VALUE_ACCESSOR, MatFormField } from '@angular/material';
import { Subject, Subscription } from 'rxjs';
import { TimeAdapter } from './time-adapter.service';
import { MAT_TIME_FORMATS } from './time-formats';
import { MatTimeSelectComponent } from './time-select.component';
/**
 * An event used for time select input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use MatTimeSelectInputEvent instead.
 * @template D
 */
var /**
 * An event used for time select input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use MatTimeSelectInputEvent instead.
 * @template D
 */
MatTimeSelectInputEvent = /** @class */ (function () {
    function MatTimeSelectInputEvent(target, targetElement) {
        this.target = target;
        this.targetElement = targetElement;
        this.value = this.target.value;
    }
    return MatTimeSelectInputEvent;
}());
/**
 * An event used for time select input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use MatTimeSelectInputEvent instead.
 * @template D
 */
export { MatTimeSelectInputEvent };
if (false) {
    /**
     * The new value for the target time select input.
     * @type {?}
     */
    MatTimeSelectInputEvent.prototype.value;
    /**
     * Reference to the time select input component that emitted the event.
     * @type {?}
     */
    MatTimeSelectInputEvent.prototype.target;
    /**
     * Reference to the native input element associated with the time select input.
     * @type {?}
     */
    MatTimeSelectInputEvent.prototype.targetElement;
}
/**
 * Directive used to connect an input to a MatTimeSelectComponent.
 * @template D
 */
var MatTimeSelectInputDirective = /** @class */ (function () {
    function MatTimeSelectInputDirective(_elementRef, _timeAdapter, _timeFormats, _formField) {
        var _this = this;
        this._elementRef = _elementRef;
        this._timeAdapter = _timeAdapter;
        this._timeFormats = _timeFormats;
        this._formField = _formField;
        this._timeSelectSubscription = Subscription.EMPTY;
        this._localeSubscription = Subscription.EMPTY;
        this._valueChange = new Subject();
        this._disabledChange = new Subject();
        /**
         * Emits when a `change` event is fired on this `<input>`.
         */
        this.timeChange = new EventEmitter();
        /**
         * Emits when an `input` event is fired on this `<input>`.
         */
        this.timeInput = new EventEmitter();
        /**
         * Emits when the value changes (either due to user input or programmatic change).
         */
        this.valueChange = this._valueChange.asObservable();
        /**
         * Emits when the disabled state has changed.
         */
        this.disabledChange = this._disabledChange.asObservable();
        this._onChange = function () { };
        this._onTouched = function () { };
        this._onValidatorChange = function () { };
        this._parseValidator = function () {
            return _this._lastValueValid ? null : { 'matTimeSelectParse': { 'text': _this._elementRef.nativeElement.value } };
        };
        this._minValidator = function (control) {
            /** @type {?} */
            var value = _this._getValidDateOrNull(_this._timeAdapter.deserialize(control.value));
            return !_this.min || !value || _this._timeAdapter.compareTime(_this.min, value) <= 0 ?
                null : { 'matTimeSelectMin': { 'min': _this.min, 'actual': value } };
        };
        this._maxValidator = function (control) {
            /** @type {?} */
            var value = _this._getValidDateOrNull(_this._timeAdapter.deserialize(control.value));
            return !_this.max || !value || _this._timeAdapter.compareTime(_this.max, value) >= 0 ?
                null : { 'matTimeSelectMax': { 'max': _this.max, 'actual': value } };
        };
        this._validator = Validators.compose([
            this._parseValidator,
            this._minValidator,
            this._maxValidator
        ]);
        this._localeSubscription = this._timeAdapter.localeChanges.subscribe(function () { return _this.value = _this.value; });
    }
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "matTimeSelect", {
        /** The time select that this input is associated with. */
        set: /**
         * The time select that this input is associated with.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (!value) {
                return;
            }
            this._timeSelect = value;
            this._timeSelect.registerInput(this);
            this._timeSelectSubscription.unsubscribe();
            this._timeSelectSubscription = this._timeSelect.selectedChange.subscribe(function (selected) {
                _this.value = selected;
                _this._onChange(selected);
                _this._onTouched();
                _this.timeInput.emit(new MatTimeSelectInputEvent(_this, _this._elementRef.nativeElement));
                _this.timeChange.emit(new MatTimeSelectInputEvent(_this, _this._elementRef.nativeElement));
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "value", {
        /** The value of the input. */
        get: /**
         * The value of the input.
         * @return {?}
         */
        function () { return this._value; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this._timeAdapter.deserialize(value);
            this._lastValueValid = !value || this._timeAdapter.isValid(value);
            value = this._getValidDateOrNull(value);
            /** @type {?} */
            var oldValue = this._value;
            this._value = value;
            this._formatValue(value);
            if (!this._timeAdapter.sameTime(oldValue, value)) {
                this._valueChange.next(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "min", {
        /** The minimum valid date time. */
        get: /**
         * The minimum valid date time.
         * @return {?}
         */
        function () { return this._min; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._min = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
            this._onValidatorChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "max", {
        /** The maximum valid date time. */
        get: /**
         * The maximum valid date time.
         * @return {?}
         */
        function () { return this._max; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._max = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
            this._onValidatorChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "disabled", {
        /** Whether the time select input is disabled. */
        get: /**
         * Whether the time select input is disabled.
         * @return {?}
         */
        function () { return this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var disabled = coerceBooleanProperty(value);
            /** @type {?} */
            var element = this._elementRef.nativeElement;
            if (this.disabled !== disabled) {
                this._disabled = disabled;
                this._disabledChange.next(disabled);
            }
            if (disabled && element.blur) {
                element.blur();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "_ariaHasPopup", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () { return true; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "_ariaOwns", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () { return (this._timeSelect && this._timeSelect.opened && !!this._timeSelect.id) || null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "_minTime", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () { return this.min ? this._timeAdapter.toIso8601(this.min) : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectInputDirective.prototype, "_maxTime", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () { return this.max ? this._timeAdapter.toIso8601(this.max) : null; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._timeSelectSubscription.unsubscribe();
        this._localeSubscription.unsubscribe();
        this._valueChange.complete();
        this._disabledChange.complete();
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.writeValue = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.registerOnChange = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.registerOnTouched = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    // Implemented as part of ControlValueAccessor.
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.setDisabledState = 
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} control
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.validate = /**
     * \@docs-private
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return this._validator ? this._validator(control) : null;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.registerOnValidatorChange = /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onValidatorChange = fn;
    };
    /**
     * Handle keydown event.
     * @param event The event object.
     */
    /**
     * Handle keydown event.
     * @param {?} event The event object.
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.onKeydown = /**
     * Handle keydown event.
     * @param {?} event The event object.
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;
        if (this._timeSelect && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
            this._timeSelect.open();
            event.preventDefault();
        }
    };
    /**
     * Handle input event.
     * @param value The current value of the input.
     */
    /**
     * Handle input event.
     * @param {?} value The current value of the input.
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.onInput = /**
     * Handle input event.
     * @param {?} value The current value of the input.
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var time = this._timeAdapter.parse(value, this._timeFormats.parse.timeInput);
        this._lastValueValid = !time || this._timeAdapter.isValid(time);
        time = this._getValidDateOrNull(time);
        if (!this._timeAdapter.sameTime(this._value, time)) {
            this._value = time;
            this._onChange(time);
            this._valueChange.next(time);
            this.timeInput.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
        }
    };
    /**
     * Handle change event.
     */
    /**
     * Handle change event.
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.onChange = /**
     * Handle change event.
     * @return {?}
     */
    function () {
        this.timeChange.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
    };
    /**
     * Handle blur event.
     */
    /**
     * Handle blur event.
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.onBlur = /**
     * Handle blur event.
     * @return {?}
     */
    function () {
        if (this.value) {
            this._formatValue(this.value);
        }
        this._onTouched();
    };
    /** Returns the palette used by the input's form field, if any. */
    /**
     * Returns the palette used by the input's form field, if any.
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype.getThemePalette = /**
     * Returns the palette used by the input's form field, if any.
     * @return {?}
     */
    function () {
        return this._formField ? this._formField.color : undefined;
    };
    /**
     * Gets the element that the time select popup should be connected to.
     * @return The element to connect the popup to.
     */
    /**
     * Gets the element that the time select popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    MatTimeSelectInputDirective.prototype.getConnectedOverlayOrigin = /**
     * Gets the element that the time select popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    function () {
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
    };
    /** Formats a value and sets it on the input element. */
    /**
     * Formats a value and sets it on the input element.
     * @private
     * @param {?} value
     * @return {?}
     */
    MatTimeSelectInputDirective.prototype._formatValue = /**
     * Formats a value and sets it on the input element.
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._elementRef.nativeElement.value = value ? this._timeAdapter.format(value, this._timeFormats.display.timeInput) : '';
    };
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    MatTimeSelectInputDirective.prototype._getValidDateOrNull = /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    function (obj) {
        return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
    };
    MatTimeSelectInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[matTimeSelect]',
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return MatTimeSelectInputDirective; }), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return MatTimeSelectInputDirective; }), multi: true },
                        { provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: MatTimeSelectInputDirective }
                    ],
                    exportAs: 'matTimeSelectInput'
                },] }
    ];
    /** @nocollapse */
    MatTimeSelectInputDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: TimeAdapter, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TIME_FORMATS,] }] },
        { type: MatFormField, decorators: [{ type: Optional }] }
    ]; };
    MatTimeSelectInputDirective.propDecorators = {
        timeChange: [{ type: Output }],
        timeInput: [{ type: Output }],
        matTimeSelect: [{ type: Input }],
        value: [{ type: Input }],
        min: [{ type: Input }],
        max: [{ type: Input }],
        disabled: [{ type: HostBinding }, { type: Input }],
        _ariaHasPopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
        _ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
        _minTime: [{ type: HostBinding, args: ['attr.min',] }],
        _maxTime: [{ type: HostBinding, args: ['attr.max',] }],
        onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
        onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
        onChange: [{ type: HostListener, args: ['change',] }],
        onBlur: [{ type: HostListener, args: ['blur',] }]
    };
    return MatTimeSelectInputDirective;
}());
export { MatTimeSelectInputDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeSelectSubscription;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._localeSubscription;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeSelect;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._value;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._min;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._max;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._valueChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._disabledChange;
    /**
     * The form control validator for whether the input parses.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._parseValidator;
    /**
     * The form control validator for the min date time.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._minValidator;
    /**
     * The form control validator for the max date time.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._maxValidator;
    /**
     * The combined form control validator for this input.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._validator;
    /**
     * Whether the last value set on the input was valid.
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._lastValueValid;
    /**
     * Emits when a `change` event is fired on this `<input>`.
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.timeChange;
    /**
     * Emits when an `input` event is fired on this `<input>`.
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.timeInput;
    /**
     * Emits when the value changes (either due to user input or programmatic change).
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.valueChange;
    /**
     * Emits when the disabled state has changed.
     * @type {?}
     */
    MatTimeSelectInputDirective.prototype.disabledChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._onChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._onTouched;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._onValidatorChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeAdapter;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._timeFormats;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectInputDirective.prototype._formField;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1zZWxlY3QtaW5wdXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hdGVyaWFsLXRpbWUtc2VsZWN0LyIsInNvdXJjZXMiOlsibGliL3RpbWUtc2VsZWN0LWlucHV0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFVBQVUsRUFDVixXQUFXLEVBQ1gsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBRUwsUUFBUSxFQUNSLE1BQU0sRUFDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBR0wsYUFBYSxFQUNiLGlCQUFpQixFQUlqQixVQUFVLEVBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDakQsT0FBTyxFQUFDLHdCQUF3QixFQUFFLFlBQVksRUFBZSxNQUFNLG1CQUFtQixDQUFDO0FBQ3ZGLE9BQU8sRUFBYSxPQUFPLEVBQUUsWUFBWSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ3ZELE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsZ0JBQWdCLEVBQWlCLE1BQU0sZ0JBQWdCLENBQUM7QUFDaEUsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0seUJBQXlCLENBQUM7Ozs7Ozs7QUFPL0Q7Ozs7Ozs7SUFLRSxpQ0FFUyxNQUFzQyxFQUV0QyxhQUEwQjtRQUYxQixXQUFNLEdBQU4sTUFBTSxDQUFnQztRQUV0QyxrQkFBYSxHQUFiLGFBQWEsQ0FBYTtRQUNqQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2pDLENBQUM7SUFFSCw4QkFBQztBQUFELENBQUMsQUFiRCxJQWFDOzs7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QVU7NEJBMkV0QixZQUFZLFNBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDOzBCQWNsQyxZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMscUJBQXFCLENBQUM7MkJBaUI3QyxZQUFZLFNBQUMsUUFBUTt5QkFRckIsWUFBWSxTQUFDLE1BQU07O0lBa0N0QixrQ0FBQztDQUFBLEFBdlJELElBdVJDO1NBOVFZLDJCQUEyQjs7Ozs7O0lBRXRDLDhEQUFxRDs7Ozs7SUFDckQsMERBQStEOzs7OztJQUUvRCxrREFBK0M7Ozs7O0lBRS9DLDZDQUFrQjs7Ozs7SUFDbEIsMkNBQWdCOzs7OztJQUNoQiwyQ0FBZ0I7Ozs7O0lBQ2hCLGdEQUEyQjs7Ozs7SUFFM0IsbURBQWtFOzs7OztJQUNsRSxzREFBbUU7Ozs7OztJQUduRSxzREFBOEM7Ozs7OztJQUU5QyxvREFBNEM7Ozs7OztJQUU1QyxvREFBNEM7Ozs7OztJQUU1QyxpREFBZ0Q7Ozs7OztJQUdoRCxzREFBaUM7Ozs7O0lBR2pDLGlEQUF5SDs7Ozs7SUFFekgsZ0RBQXdIOzs7OztJQUd4SCxrREFBcUU7Ozs7O0lBRXJFLHFEQUEwRTs7Ozs7SUFFMUUsZ0RBQW1EOzs7OztJQUNuRCxpREFBMEM7Ozs7O0lBQzFDLHlEQUFrRDs7Ozs7SUFzRnRDLGtEQUFpRDs7Ozs7SUFDakQsbURBQWdEOzs7OztJQUNoRCxtREFBMEU7Ozs7O0lBQzFFLGlEQUE0QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIGZvcndhcmRSZWYsXHJcbiAgSG9zdEJpbmRpbmcsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIEluamVjdCxcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3B0aW9uYWwsXHJcbiAgT3V0cHV0XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgQWJzdHJhY3RDb250cm9sLFxyXG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxyXG4gIE5HX1ZBTElEQVRPUlMsXHJcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgVmFsaWRhdGlvbkVycm9ycyxcclxuICBWYWxpZGF0b3IsXHJcbiAgVmFsaWRhdG9yRm4sXHJcbiAgVmFsaWRhdG9yc1xyXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHtjb2VyY2VCb29sZWFuUHJvcGVydHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7RE9XTl9BUlJPV30gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcclxuaW1wb3J0IHtNQVRfSU5QVVRfVkFMVUVfQUNDRVNTT1IsIE1hdEZvcm1GaWVsZCwgVGhlbWVQYWxldHRlfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtUaW1lQWRhcHRlcn0gZnJvbSAnLi90aW1lLWFkYXB0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7TUFUX1RJTUVfRk9STUFUUywgTWF0VGltZUZvcm1hdHN9IGZyb20gJy4vdGltZS1mb3JtYXRzJztcclxuaW1wb3J0IHtNYXRUaW1lU2VsZWN0Q29tcG9uZW50fSBmcm9tICcuL3RpbWUtc2VsZWN0LmNvbXBvbmVudCc7XHJcblxyXG4vKipcclxuICogQW4gZXZlbnQgdXNlZCBmb3IgdGltZSBzZWxlY3QgaW5wdXQgYW5kIGNoYW5nZSBldmVudHMuIFdlIGRvbid0IGFsd2F5cyBoYXZlIGFjY2VzcyB0byBhIG5hdGl2ZVxyXG4gKiBpbnB1dCBvciBjaGFuZ2UgZXZlbnQgYmVjYXVzZSB0aGUgZXZlbnQgbWF5IGhhdmUgYmVlbiB0cmlnZ2VyZWQgYnkgdGhlIHVzZXIgY2xpY2tpbmcgb24gdGhlXHJcbiAqIGNhbGVuZGFyIHBvcHVwLiBGb3IgY29uc2lzdGVuY3ksIHdlIGFsd2F5cyB1c2UgTWF0VGltZVNlbGVjdElucHV0RXZlbnQgaW5zdGVhZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYXRUaW1lU2VsZWN0SW5wdXRFdmVudDxEPiB7XHJcblxyXG4gIC8qKiBUaGUgbmV3IHZhbHVlIGZvciB0aGUgdGFyZ2V0IHRpbWUgc2VsZWN0IGlucHV0LiAqL1xyXG4gIHZhbHVlOiBEO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHRpbWUgc2VsZWN0IGlucHV0IGNvbXBvbmVudCB0aGF0IGVtaXR0ZWQgdGhlIGV2ZW50LiAqL1xyXG4gICAgcHVibGljIHRhcmdldDogTWF0VGltZVNlbGVjdElucHV0RGlyZWN0aXZlPEQ+LFxyXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aW1lIHNlbGVjdCBpbnB1dC4gKi9cclxuICAgIHB1YmxpYyB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMudGFyZ2V0LnZhbHVlO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbi8qKiBEaXJlY3RpdmUgdXNlZCB0byBjb25uZWN0IGFuIGlucHV0IHRvIGEgTWF0VGltZVNlbGVjdENvbXBvbmVudC4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdpbnB1dFttYXRUaW1lU2VsZWN0XScsXHJcbiAgcHJvdmlkZXJzOiBbXHJcbiAgICB7cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hdFRpbWVTZWxlY3RJbnB1dERpcmVjdGl2ZSksIG11bHRpOiB0cnVlfSxcclxuICAgIHtwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNYXRUaW1lU2VsZWN0SW5wdXREaXJlY3RpdmUpLCBtdWx0aTogdHJ1ZX0sXHJcbiAgICB7cHJvdmlkZTogTUFUX0lOUFVUX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogTWF0VGltZVNlbGVjdElucHV0RGlyZWN0aXZlfVxyXG4gIF0sXHJcbiAgZXhwb3J0QXM6ICdtYXRUaW1lU2VsZWN0SW5wdXQnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXRUaW1lU2VsZWN0SW5wdXREaXJlY3RpdmU8RD4gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xyXG5cclxuICBwcml2YXRlIF90aW1lU2VsZWN0U3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG4gIHByaXZhdGUgX2xvY2FsZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICBwcml2YXRlIF90aW1lU2VsZWN0OiBNYXRUaW1lU2VsZWN0Q29tcG9uZW50PEQ+O1xyXG5cclxuICBwcml2YXRlIF92YWx1ZTogRDtcclxuICBwcml2YXRlIF9taW46IEQ7XHJcbiAgcHJpdmF0ZSBfbWF4OiBEO1xyXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuO1xyXG5cclxuICBwcml2YXRlIF92YWx1ZUNoYW5nZTogU3ViamVjdDxEIHwgbnVsbD4gPSBuZXcgU3ViamVjdDxEIHwgbnVsbD4oKTtcclxuICBwcml2YXRlIF9kaXNhYmxlZENoYW5nZTogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XHJcblxyXG4gIC8qKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3Igd2hldGhlciB0aGUgaW5wdXQgcGFyc2VzLiAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3BhcnNlVmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtaW4gZGF0ZSB0aW1lLiAqL1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX21pblZhbGlkYXRvcjogVmFsaWRhdG9yRm47XHJcbiAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgbWF4IGRhdGUgdGltZS4gKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IF9tYXhWYWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG4gIC8qKiBUaGUgY29tYmluZWQgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhpcyBpbnB1dC4gKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IF92YWxpZGF0b3I6IFZhbGlkYXRvckZuIHwgbnVsbDtcclxuXHJcbiAgLyoqIFdoZXRoZXIgdGhlIGxhc3QgdmFsdWUgc2V0IG9uIHRoZSBpbnB1dCB3YXMgdmFsaWQuICovXHJcbiAgcHJpdmF0ZSBfbGFzdFZhbHVlVmFsaWQ6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBFbWl0cyB3aGVuIGEgYGNoYW5nZWAgZXZlbnQgaXMgZmlyZWQgb24gdGhpcyBgPGlucHV0PmAuICovXHJcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHRpbWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXRUaW1lU2VsZWN0SW5wdXRFdmVudDxEPj4gPSBuZXcgRXZlbnRFbWl0dGVyPE1hdFRpbWVTZWxlY3RJbnB1dEV2ZW50PEQ+PigpO1xyXG4gIC8qKiBFbWl0cyB3aGVuIGFuIGBpbnB1dGAgZXZlbnQgaXMgZmlyZWQgb24gdGhpcyBgPGlucHV0PmAuICovXHJcbiAgQE91dHB1dCgpIHJlYWRvbmx5IHRpbWVJbnB1dDogRXZlbnRFbWl0dGVyPE1hdFRpbWVTZWxlY3RJbnB1dEV2ZW50PEQ+PiA9IG5ldyBFdmVudEVtaXR0ZXI8TWF0VGltZVNlbGVjdElucHV0RXZlbnQ8RD4+KCk7XHJcblxyXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChlaXRoZXIgZHVlIHRvIHVzZXIgaW5wdXQgb3IgcHJvZ3JhbW1hdGljIGNoYW5nZSkuICovXHJcbiAgdmFsdWVDaGFuZ2U6IE9ic2VydmFibGU8RCB8IG51bGw+ID0gdGhpcy5fdmFsdWVDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XHJcbiAgLyoqIEVtaXRzIHdoZW4gdGhlIGRpc2FibGVkIHN0YXRlIGhhcyBjaGFuZ2VkLiAqL1xyXG4gIGRpc2FibGVkQ2hhbmdlOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5fZGlzYWJsZWRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XHJcblxyXG4gIHByaXZhdGUgX29uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHt9O1xyXG4gIHByaXZhdGUgX29uVG91Y2hlZDogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xyXG4gIHByaXZhdGUgX29uVmFsaWRhdG9yQ2hhbmdlOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XHJcblxyXG4gIC8qKiBUaGUgdGltZSBzZWxlY3QgdGhhdCB0aGlzIGlucHV0IGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cclxuICBASW5wdXQoKVxyXG4gIHNldCBtYXRUaW1lU2VsZWN0KHZhbHVlOiBNYXRUaW1lU2VsZWN0Q29tcG9uZW50PEQ+KSB7XHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl90aW1lU2VsZWN0ID0gdmFsdWU7XHJcbiAgICB0aGlzLl90aW1lU2VsZWN0LnJlZ2lzdGVySW5wdXQodGhpcyk7XHJcbiAgICB0aGlzLl90aW1lU2VsZWN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgdGhpcy5fdGltZVNlbGVjdFN1YnNjcmlwdGlvbiA9IHRoaXMuX3RpbWVTZWxlY3Quc2VsZWN0ZWRDaGFuZ2Uuc3Vic2NyaWJlKChzZWxlY3RlZDogRCkgPT4ge1xyXG4gICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWQ7XHJcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHNlbGVjdGVkKTtcclxuICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XHJcbiAgICAgIHRoaXMudGltZUlucHV0LmVtaXQobmV3IE1hdFRpbWVTZWxlY3RJbnB1dEV2ZW50KHRoaXMsIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpO1xyXG4gICAgICB0aGlzLnRpbWVDaGFuZ2UuZW1pdChuZXcgTWF0VGltZVNlbGVjdElucHV0RXZlbnQodGhpcywgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBUaGUgdmFsdWUgb2YgdGhlIGlucHV0LiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IHZhbHVlKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XHJcbiAgc2V0IHZhbHVlKHZhbHVlOiBEIHwgbnVsbCkge1xyXG4gICAgdmFsdWUgPSB0aGlzLl90aW1lQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZSk7XHJcbiAgICB0aGlzLl9sYXN0VmFsdWVWYWxpZCA9ICF2YWx1ZSB8fCB0aGlzLl90aW1lQWRhcHRlci5pc1ZhbGlkKHZhbHVlKTtcclxuICAgIHZhbHVlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHZhbHVlKTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fdmFsdWU7XHJcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgdGhpcy5fZm9ybWF0VmFsdWUodmFsdWUpO1xyXG5cclxuICAgIGlmICghdGhpcy5fdGltZUFkYXB0ZXIuc2FtZVRpbWUob2xkVmFsdWUsIHZhbHVlKSkge1xyXG4gICAgICB0aGlzLl92YWx1ZUNoYW5nZS5uZXh0KHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBUaGUgbWluaW11bSB2YWxpZCBkYXRlIHRpbWUuICovXHJcbiAgQElucHV0KClcclxuICBnZXQgbWluKCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX21pbjsgfVxyXG4gIHNldCBtaW4odmFsdWU6IEQgfCBudWxsKSB7XHJcbiAgICB0aGlzLl9taW4gPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fdGltZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTtcclxuICAgIHRoaXMuX29uVmFsaWRhdG9yQ2hhbmdlKCk7XHJcbiAgfVxyXG5cclxuICAvKiogVGhlIG1heGltdW0gdmFsaWQgZGF0ZSB0aW1lLiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IG1heCgpOiBEIHwgbnVsbCB7IHJldHVybiB0aGlzLl9tYXg7IH1cclxuICBzZXQgbWF4KHZhbHVlOiBEIHwgbnVsbCkge1xyXG4gICAgdGhpcy5fbWF4ID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX3RpbWVBZGFwdGVyLmRlc2VyaWFsaXplKHZhbHVlKSk7XHJcbiAgICB0aGlzLl9vblZhbGlkYXRvckNoYW5nZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFdoZXRoZXIgdGhlIHRpbWUgc2VsZWN0IGlucHV0IGlzIGRpc2FibGVkLiAqL1xyXG4gIEBIb3N0QmluZGluZygpXHJcbiAgQElucHV0KClcclxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfVxyXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgY29uc3QgZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xyXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgIGlmICh0aGlzLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5uZXh0KGRpc2FibGVkKTtcclxuICAgIH1cclxuICAgIGlmIChkaXNhYmxlZCAmJiBlbGVtZW50LmJsdXIpIHtcclxuICAgICAgZWxlbWVudC5ibHVyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWhhc3BvcHVwJylcclxuICBnZXQgX2FyaWFIYXNQb3B1cCgpOiBib29sZWFuIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1vd25zJylcclxuICBnZXQgX2FyaWFPd25zKCk6IGJvb2xlYW4geyByZXR1cm4gKHRoaXMuX3RpbWVTZWxlY3QgJiYgdGhpcy5fdGltZVNlbGVjdC5vcGVuZWQgJiYgISF0aGlzLl90aW1lU2VsZWN0LmlkKSB8fCBudWxsOyB9XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLm1pbicpXHJcbiAgZ2V0IF9taW5UaW1lKCk6IHN0cmluZyB8IG51bGwgeyByZXR1cm4gdGhpcy5taW4gPyB0aGlzLl90aW1lQWRhcHRlci50b0lzbzg2MDEodGhpcy5taW4pIDogbnVsbDsgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIEBIb3N0QmluZGluZygnYXR0ci5tYXgnKVxyXG4gIGdldCBfbWF4VGltZSgpOiBzdHJpbmcgfCBudWxsIHsgcmV0dXJuIHRoaXMubWF4ID8gdGhpcy5fdGltZUFkYXB0ZXIudG9Jc284NjAxKHRoaXMubWF4KSA6IG51bGw7IH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MSW5wdXRFbGVtZW50PixcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF90aW1lQWRhcHRlcjogVGltZUFkYXB0ZXI8RD4sXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRfVElNRV9GT1JNQVRTKSBwcml2YXRlIF90aW1lRm9ybWF0czogTWF0VGltZUZvcm1hdHMsXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZm9ybUZpZWxkOiBNYXRGb3JtRmllbGQpIHtcclxuICAgIHRoaXMuX3BhcnNlVmFsaWRhdG9yID0gKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2xhc3RWYWx1ZVZhbGlkID8gbnVsbCA6IHsnbWF0VGltZVNlbGVjdFBhcnNlJzogeyd0ZXh0JzogdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlfX07XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX21pblZhbGlkYXRvciA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX3RpbWVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUpKTtcclxuICAgICAgcmV0dXJuICF0aGlzLm1pbiB8fCAhdmFsdWUgfHwgdGhpcy5fdGltZUFkYXB0ZXIuY29tcGFyZVRpbWUodGhpcy5taW4sIHZhbHVlKSA8PSAwID9cclxuICAgICAgICBudWxsIDogeydtYXRUaW1lU2VsZWN0TWluJzogeydtaW4nOiB0aGlzLm1pbiwgJ2FjdHVhbCc6IHZhbHVlfX07XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX21heFZhbGlkYXRvciA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0VmFsaWREYXRlT3JOdWxsKHRoaXMuX3RpbWVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUpKTtcclxuICAgICAgcmV0dXJuICF0aGlzLm1heCB8fCAhdmFsdWUgfHwgdGhpcy5fdGltZUFkYXB0ZXIuY29tcGFyZVRpbWUodGhpcy5tYXgsIHZhbHVlKSA+PSAwID9cclxuICAgICAgICBudWxsIDogeydtYXRUaW1lU2VsZWN0TWF4JzogeydtYXgnOiB0aGlzLm1heCwgJ2FjdHVhbCc6IHZhbHVlfX07XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbXHJcbiAgICAgIHRoaXMuX3BhcnNlVmFsaWRhdG9yLFxyXG4gICAgICB0aGlzLl9taW5WYWxpZGF0b3IsXHJcbiAgICAgIHRoaXMuX21heFZhbGlkYXRvclxyXG4gICAgXSk7XHJcblxyXG4gICAgdGhpcy5fbG9jYWxlU3Vic2NyaXB0aW9uID0gdGhpcy5fdGltZUFkYXB0ZXIubG9jYWxlQ2hhbmdlcy5zdWJzY3JpYmUoXHJcbiAgICAgICgpID0+IHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl90aW1lU2VsZWN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB0aGlzLl9sb2NhbGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cclxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXHJcbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xyXG4gIH1cclxuXHJcbiAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cclxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcclxuICB9XHJcblxyXG4gIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXHJcbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvciA/IHRoaXMuX3ZhbGlkYXRvcihjb250cm9sKSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgIHRoaXMuX29uVmFsaWRhdG9yQ2hhbmdlID0gZm47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUga2V5ZG93biBldmVudC5cclxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdC5cclxuICAgKi9cclxuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcclxuICBvbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgIGNvbnN0IGlzQWx0RG93bkFycm93ID0gZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09IERPV05fQVJST1c7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RpbWVTZWxlY3QgJiYgaXNBbHREb3duQXJyb3cgJiYgIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5yZWFkT25seSkge1xyXG4gICAgICB0aGlzLl90aW1lU2VsZWN0Lm9wZW4oKTtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBpbnB1dCBldmVudC5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlxyXG4gICAqL1xyXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pXHJcbiAgb25JbnB1dCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgdGltZSA9IHRoaXMuX3RpbWVBZGFwdGVyLnBhcnNlKHZhbHVlLCB0aGlzLl90aW1lRm9ybWF0cy5wYXJzZS50aW1lSW5wdXQpO1xyXG4gICAgdGhpcy5fbGFzdFZhbHVlVmFsaWQgPSAhdGltZSB8fCB0aGlzLl90aW1lQWRhcHRlci5pc1ZhbGlkKHRpbWUpO1xyXG4gICAgdGltZSA9IHRoaXMuX2dldFZhbGlkRGF0ZU9yTnVsbCh0aW1lKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3RpbWVBZGFwdGVyLnNhbWVUaW1lKHRoaXMuX3ZhbHVlLCB0aW1lKSkge1xyXG4gICAgICB0aGlzLl92YWx1ZSA9IHRpbWU7XHJcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHRpbWUpO1xyXG4gICAgICB0aGlzLl92YWx1ZUNoYW5nZS5uZXh0KHRpbWUpO1xyXG4gICAgICB0aGlzLnRpbWVJbnB1dC5lbWl0KG5ldyBNYXRUaW1lU2VsZWN0SW5wdXRFdmVudCh0aGlzLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBjaGFuZ2UgZXZlbnQuXHJcbiAgICovXHJcbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJylcclxuICBvbkNoYW5nZSgpIHtcclxuICAgIHRoaXMudGltZUNoYW5nZS5lbWl0KG5ldyBNYXRUaW1lU2VsZWN0SW5wdXRFdmVudCh0aGlzLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBibHVyIGV2ZW50LlxyXG4gICAqL1xyXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxyXG4gIG9uQmx1cigpIHtcclxuICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgIHRoaXMuX2Zvcm1hdFZhbHVlKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fb25Ub3VjaGVkKCk7XHJcbiAgfVxyXG5cclxuICAvKiogUmV0dXJucyB0aGUgcGFsZXR0ZSB1c2VkIGJ5IHRoZSBpbnB1dCdzIGZvcm0gZmllbGQsIGlmIGFueS4gKi9cclxuICBnZXRUaGVtZVBhbGV0dGUoKTogVGhlbWVQYWxldHRlIHtcclxuICAgIHJldHVybiB0aGlzLl9mb3JtRmllbGQgPyB0aGlzLl9mb3JtRmllbGQuY29sb3IgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBlbGVtZW50IHRoYXQgdGhlIHRpbWUgc2VsZWN0IHBvcHVwIHNob3VsZCBiZSBjb25uZWN0ZWQgdG8uXHJcbiAgICogQHJldHVybiBUaGUgZWxlbWVudCB0byBjb25uZWN0IHRoZSBwb3B1cCB0by5cclxuICAgKi9cclxuICBnZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCk6IEVsZW1lbnRSZWYge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Zvcm1GaWVsZCA/IHRoaXMuX2Zvcm1GaWVsZC5nZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCkgOiB0aGlzLl9lbGVtZW50UmVmO1xyXG4gIH1cclxuXHJcbiAgLyoqIEZvcm1hdHMgYSB2YWx1ZSBhbmQgc2V0cyBpdCBvbiB0aGUgaW5wdXQgZWxlbWVudC4gKi9cclxuICBwcml2YXRlIF9mb3JtYXRWYWx1ZSh2YWx1ZTogRCB8IG51bGwpIHtcclxuICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlID8gdGhpcy5fdGltZUFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aGlzLl90aW1lRm9ybWF0cy5kaXNwbGF5LnRpbWVJbnB1dCkgOiAnJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyBUaGUgZ2l2ZW4gb2JqZWN0IGlmIGl0IGlzIGJvdGggYSBkYXRlIGluc3RhbmNlIGFuZCB2YWxpZCwgb3RoZXJ3aXNlIG51bGwuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0VmFsaWREYXRlT3JOdWxsKG9iajogYW55KTogRCB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVBZGFwdGVyLmlzRGF0ZUluc3RhbmNlKG9iaikgJiYgdGhpcy5fdGltZUFkYXB0ZXIuaXNWYWxpZChvYmopID8gb2JqIDogbnVsbDtcclxuICB9XHJcblxyXG59XHJcbiJdfQ==