/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Inject, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { TimeAdapter } from './time-adapter.service';
import { MAT_TIME_FORMATS } from './time-formats';
/**
 * Component used to select a value of a unit of time.
 * @template D
 */
var MatTimeUnitSelectComponent = /** @class */ (function () {
    function MatTimeUnitSelectComponent(_changeDetectorRef, _timeAdapter, _timeFormats) {
        this._changeDetectorRef = _changeDetectorRef;
        this._timeAdapter = _timeAdapter;
        this._timeFormats = _timeFormats;
        /**
         * The list of all values of the time select.
         */
        this.options = [];
        /**
         * Emits when selected value has been changed. Output to enable support for two-way binding on `[(value)]`.
         */
        this.valueChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var unit = this.unit;
        /** @type {?} */
        var time = this._timeAdapter.createTime();
        /** @type {?} */
        var moment = this._timeAdapter.toMoment(time);
        /** @type {?} */
        var start = moment.clone().startOf('day');
        /** @type {?} */
        var end = moment.clone().endOf('day');
        /** @type {?} */
        var min = start.get(unit);
        /** @type {?} */
        var max = end.get(unit);
        /** @type {?} */
        var localeData = moment.localeData();
        /** @type {?} */
        var displayFormat = localeData.longDateFormat('LTS');
        /** @type {?} */
        var unitFormat = unit === 'hour' ?
            displayFormat.match(/hh?|HH?/g)[0] : unit === 'minute' ?
            displayFormat.match(/mm?/g)[0] : displayFormat.match(/ss?/g)[0];
        moment.set(unit, this.value);
        moment.subtract((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        for (var value = min; value <= max; value++) {
            moment.add((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
            this.options.push({ value: moment.get(unit), label: moment.format(unitFormat) });
        }
    };
    /**
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var element = this.panel.nativeElement;
        this._originTop = parseFloat(getComputedStyle(element).top);
        element.addEventListener('transitionend', function () {
            element.style.removeProperty('transition');
        });
        setTimeout(function () { return _this.move(_this.options.length / 2); });
    };
    /** Select the previous option. */
    /**
     * Select the previous option.
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.prev = /**
     * Select the previous option.
     * @return {?}
     */
    function () {
        this.move(-1);
    };
    /** Select the next option. */
    /**
     * Select the next option.
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.next = /**
     * Select the next option.
     * @return {?}
     */
    function () {
        this.move(+1);
    };
    /**
     * Select the option moving by the given amount of step.
     * @param step The amount of step to move.
     */
    /**
     * Select the option moving by the given amount of step.
     * @param {?} step The amount of step to move.
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.move = /**
     * Select the option moving by the given amount of step.
     * @param {?} step The amount of step to move.
     * @return {?}
     */
    function (step) {
        /** @type {?} */
        var element = this.panel.nativeElement;
        /** @type {?} */
        var option = element.querySelector('mat-time-unit-option');
        /** @type {?} */
        var optionHeight = parseFloat(getComputedStyle(option).height);
        /** @type {?} */
        var currentTop = parseFloat(getComputedStyle(element).top);
        /** @type {?} */
        var targetTop = currentTop + (step * optionHeight);
        /** @type {?} */
        var y = this._originTop - targetTop;
        element.style.top = targetTop + "px";
        if (step < 0) {
            // Move last option to the top
            for (var i = 0; i > step; i--) {
                this.options.unshift(this.options.pop());
            }
        }
        else if (step > 0) {
            // Move first option to the bottom
            for (var i = 0; i < step; i++) {
                this.options.push(this.options.shift());
            }
        }
        this.value = this.options[(this.options.length / 2)].value;
        this.valueChange.emit(this.value);
        element.style.transition = 'transform 0.5s';
        element.style.transform = "translateY(" + y + "px)";
    };
    /**
     * Gets the previous option value.
     */
    /**
     * Gets the previous option value.
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.getPrev = /**
     * Gets the previous option value.
     * @return {?}
     */
    function () {
        return this.options[(this.options.length / 2) - 1].value;
    };
    /**
     * Gets the next option value.
     */
    /**
     * Gets the next option value.
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.getNext = /**
     * Gets the next option value.
     * @return {?}
     */
    function () {
        return this.options[(this.options.length / 2) + 1].value;
    };
    /**
     * Whether the given value is valid.
     * @param value The value to check.
     */
    /**
     * Whether the given value is valid.
     * @param {?} value The value to check.
     * @return {?}
     */
    MatTimeUnitSelectComponent.prototype.isValid = /**
     * Whether the given value is valid.
     * @param {?} value The value to check.
     * @return {?}
     */
    function (value) {
        return (this.min === null || value >= this.min) && (this.max === null || value <= this.max);
    };
    MatTimeUnitSelectComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mat-time-unit-select',
                    template: "<div class=\"mat-time-unit-select-carousel\">\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-prev\" mat-icon-button aria-label=\"Previous\" [disabled]=\"!isValid(getPrev())\" (click)=\"prev()\">\r\n    <mat-icon>keyboard_arrow_up</mat-icon>\r\n  </button>\r\n  <div class=\"mat-time-unit-select-mask\">\r\n    <div #panel class=\"mat-time-unit-select-panel\">\r\n      <mat-time-unit-option *ngFor=\"let option of options\" [value]=\"option.value\" [disabled]=\"!isValid(option.value)\"> {{ option.label }} </mat-time-unit-option>\r\n    </div>\r\n  </div>\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-next\" mat-icon-button aria-label=\"Next\" [disabled]=\"!isValid(getNext())\" (click)=\"next()\">\r\n    <mat-icon>keyboard_arrow_down</mat-icon>\r\n  </button>\r\n</div>\r\n",
                    exportAs: 'matTimeSelect',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["mat-time-unit-select{display:block;height:100%}mat-time-unit-select .mat-time-unit-select-carousel{display:flex;flex-direction:column;align-items:center;height:100%}mat-time-unit-select .mat-time-unit-select-mask{flex:auto;max-height:120px;width:100%;overflow:hidden}"]
                }] }
    ];
    /** @nocollapse */
    MatTimeUnitSelectComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: TimeAdapter },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_TIME_FORMATS,] }] }
    ]; };
    MatTimeUnitSelectComponent.propDecorators = {
        value: [{ type: Input }],
        unit: [{ type: Input }],
        min: [{ type: Input }],
        max: [{ type: Input }],
        valueChange: [{ type: Output }],
        panel: [{ type: ViewChild, args: ['panel',] }]
    };
    return MatTimeUnitSelectComponent;
}());
export { MatTimeUnitSelectComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._originTop;
    /**
     * The currently selected value.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.value;
    /**
     * The unit of time of the time select.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.unit;
    /**
     * The minimum selectable value.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.min;
    /**
     * The maximum selectable value.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.max;
    /**
     * The list of all values of the time select.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.options;
    /**
     * Emits when selected value has been changed. Output to enable support for two-way binding on `[(value)]`.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.valueChange;
    /**
     * The panel element containing all time select options.
     * @type {?}
     */
    MatTimeUnitSelectComponent.prototype.panel;
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._timeAdapter;
    /**
     * @type {?}
     * @private
     */
    MatTimeUnitSelectComponent.prototype._timeFormats;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS11bml0LXNlbGVjdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbWF0ZXJpYWwtdGltZS1zZWxlY3QvIiwic291cmNlcyI6WyJsaWIvdGltZS11bml0LXNlbGVjdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBRUwsTUFBTSxFQUNOLFNBQVMsRUFDVCxpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQ25ELE9BQU8sRUFBQyxnQkFBZ0IsRUFBaUIsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFHaEU7SUE4QkUsb0NBQW9CLGtCQUFxQyxFQUNyQyxZQUE0QixFQUNGLFlBQTRCO1FBRnRELHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7UUFDckMsaUJBQVksR0FBWixZQUFZLENBQWdCO1FBQ0YsaUJBQVksR0FBWixZQUFZLENBQWdCOzs7O1FBVjFFLFlBQU8sR0FBcUMsRUFBRSxDQUFDOzs7O1FBR3JDLGdCQUFXLEdBQXlCLElBQUksWUFBWSxFQUFVLENBQUM7SUFPSyxDQUFDOzs7O0lBRS9FLDZDQUFROzs7SUFBUjs7WUFDUSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUk7O1lBQ2hCLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRTs7WUFDckMsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQzs7WUFDekMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDOztZQUNyQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENB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aXQsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgQ29tcG9uZW50LFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEluamVjdCxcclxuICBJbnB1dCxcclxuICBPbkluaXQsXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDaGlsZCxcclxuICBWaWV3RW5jYXBzdWxhdGlvblxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0R1cmF0aW9uSW5wdXRBcmcxLCBEdXJhdGlvbklucHV0QXJnMiwgdW5pdE9mVGltZX0gZnJvbSAnbW9tZW50JztcclxuaW1wb3J0IHtUaW1lQWRhcHRlcn0gZnJvbSAnLi90aW1lLWFkYXB0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7TUFUX1RJTUVfRk9STUFUUywgTWF0VGltZUZvcm1hdHN9IGZyb20gJy4vdGltZS1mb3JtYXRzJztcclxuXHJcbi8qKiBDb21wb25lbnQgdXNlZCB0byBzZWxlY3QgYSB2YWx1ZSBvZiBhIHVuaXQgb2YgdGltZS4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdtYXQtdGltZS11bml0LXNlbGVjdCcsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL3RpbWUtdW5pdC1zZWxlY3QuY29tcG9uZW50Lmh0bWwnLFxyXG4gIHN0eWxlVXJsczogWycuL3RpbWUtdW5pdC1zZWxlY3QuY29tcG9uZW50LnNjc3MnXSxcclxuICBleHBvcnRBczogJ21hdFRpbWVTZWxlY3QnLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hdFRpbWVVbml0U2VsZWN0Q29tcG9uZW50PEQ+IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25Jbml0IHtcclxuXHJcbiAgcHJpdmF0ZSBfb3JpZ2luVG9wOiBudW1iZXI7XHJcblxyXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlLiAqL1xyXG4gIEBJbnB1dCgpIHZhbHVlOiBudW1iZXI7XHJcbiAgLyoqIFRoZSB1bml0IG9mIHRpbWUgb2YgdGhlIHRpbWUgc2VsZWN0LiAqL1xyXG4gIEBJbnB1dCgpIHVuaXQ6IHVuaXRPZlRpbWUuQWxsO1xyXG4gIC8qKiBUaGUgbWluaW11bSBzZWxlY3RhYmxlIHZhbHVlLiAqL1xyXG4gIEBJbnB1dCgpIG1pbjogbnVtYmVyIHwgbnVsbDtcclxuICAvKiogVGhlIG1heGltdW0gc2VsZWN0YWJsZSB2YWx1ZS4gKi9cclxuICBASW5wdXQoKSBtYXg6IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8qKiBUaGUgbGlzdCBvZiBhbGwgdmFsdWVzIG9mIHRoZSB0aW1lIHNlbGVjdC4gKi9cclxuICBvcHRpb25zOiB7dmFsdWU6IG51bWJlcjsgbGFiZWw6IHN0cmluZ31bXSA9IFtdO1xyXG5cclxuICAvKiogRW1pdHMgd2hlbiBzZWxlY3RlZCB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLiBPdXRwdXQgdG8gZW5hYmxlIHN1cHBvcnQgZm9yIHR3by13YXkgYmluZGluZyBvbiBgWyh2YWx1ZSldYC4gKi9cclxuICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XHJcblxyXG4gIC8qKiBUaGUgcGFuZWwgZWxlbWVudCBjb250YWluaW5nIGFsbCB0aW1lIHNlbGVjdCBvcHRpb25zLiAqL1xyXG4gIEBWaWV3Q2hpbGQoJ3BhbmVsJykgcGFuZWw6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfdGltZUFkYXB0ZXI6IFRpbWVBZGFwdGVyPEQ+LFxyXG4gICAgICAgICAgICAgIEBJbmplY3QoTUFUX1RJTUVfRk9STUFUUykgcHJpdmF0ZSBfdGltZUZvcm1hdHM6IE1hdFRpbWVGb3JtYXRzKSB7IH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICBjb25zdCB1bml0ID0gdGhpcy51bml0O1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX3RpbWVBZGFwdGVyLmNyZWF0ZVRpbWUoKTtcclxuICAgIGNvbnN0IG1vbWVudCA9IHRoaXMuX3RpbWVBZGFwdGVyLnRvTW9tZW50KHRpbWUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBtb21lbnQuY2xvbmUoKS5zdGFydE9mKCdkYXknKTtcclxuICAgIGNvbnN0IGVuZCA9IG1vbWVudC5jbG9uZSgpLmVuZE9mKCdkYXknKTtcclxuICAgIGNvbnN0IG1pbiA9IHN0YXJ0LmdldCh1bml0KTtcclxuICAgIGNvbnN0IG1heCA9IGVuZC5nZXQodW5pdCk7XHJcbiAgICBjb25zdCBsb2NhbGVEYXRhID0gbW9tZW50LmxvY2FsZURhdGEoKTtcclxuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXQgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KCdMVFMnKTtcclxuICAgIGNvbnN0IHVuaXRGb3JtYXQgPSB1bml0ID09PSAnaG91cicgP1xyXG4gICAgICBkaXNwbGF5Rm9ybWF0Lm1hdGNoKC9oaD98SEg/L2cpWzBdIDogdW5pdCA9PT0gJ21pbnV0ZScgP1xyXG4gICAgICAgIGRpc3BsYXlGb3JtYXQubWF0Y2goL21tPy9nKVswXSA6IGRpc3BsYXlGb3JtYXQubWF0Y2goL3NzPy9nKVswXTtcclxuICAgIG1vbWVudC5zZXQodW5pdCwgdGhpcy52YWx1ZSk7XHJcbiAgICBtb21lbnQuc3VidHJhY3QoMSBhcyBEdXJhdGlvbklucHV0QXJnMSwgdW5pdCBhcyBEdXJhdGlvbklucHV0QXJnMik7XHJcbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XHJcbiAgICAgIG1vbWVudC5hZGQoMSBhcyBEdXJhdGlvbklucHV0QXJnMSwgdW5pdCBhcyBEdXJhdGlvbklucHV0QXJnMik7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5wdXNoKHt2YWx1ZTogbW9tZW50LmdldCh1bml0KSwgbGFiZWw6IG1vbWVudC5mb3JtYXQodW5pdEZvcm1hdCl9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnBhbmVsLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB0aGlzLl9vcmlnaW5Ub3AgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudG9wKTtcclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsICgpID0+IHtcclxuICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xyXG4gICAgfSk7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubW92ZSh0aGlzLm9wdGlvbnMubGVuZ3RoIC8gMikpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNlbGVjdCB0aGUgcHJldmlvdXMgb3B0aW9uLiAqL1xyXG4gIHByZXYoKSB7XHJcbiAgICB0aGlzLm1vdmUoLTEpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNlbGVjdCB0aGUgbmV4dCBvcHRpb24uICovXHJcbiAgbmV4dCgpIHtcclxuICAgIHRoaXMubW92ZSgrMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3QgdGhlIG9wdGlvbiBtb3ZpbmcgYnkgdGhlIGdpdmVuIGFtb3VudCBvZiBzdGVwLlxyXG4gICAqIEBwYXJhbSBzdGVwIFRoZSBhbW91bnQgb2Ygc3RlcCB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIG1vdmUoc3RlcDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50O1xyXG4gICAgY29uc3Qgb3B0aW9uID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdtYXQtdGltZS11bml0LW9wdGlvbicpO1xyXG4gICAgY29uc3Qgb3B0aW9uSGVpZ2h0ID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKG9wdGlvbikuaGVpZ2h0KTtcclxuICAgIGNvbnN0IGN1cnJlbnRUb3AgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudG9wKTtcclxuICAgIGNvbnN0IHRhcmdldFRvcCA9IGN1cnJlbnRUb3AgKyAoc3RlcCAqIG9wdGlvbkhlaWdodCk7XHJcbiAgICBjb25zdCB5ID0gdGhpcy5fb3JpZ2luVG9wIC0gdGFyZ2V0VG9wO1xyXG5cclxuICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7dGFyZ2V0VG9wfXB4YDtcclxuXHJcbiAgICBpZiAoc3RlcCA8IDApIHtcclxuICAgICAgLy8gTW92ZSBsYXN0IG9wdGlvbiB0byB0aGUgdG9wXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpID4gc3RlcDsgaS0tKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnVuc2hpZnQodGhpcy5vcHRpb25zLnBvcCgpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzdGVwID4gMCkge1xyXG4gICAgICAvLyBNb3ZlIGZpcnN0IG9wdGlvbiB0byB0aGUgYm90dG9tXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnB1c2godGhpcy5vcHRpb25zLnNoaWZ0KCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9uc1sodGhpcy5vcHRpb25zLmxlbmd0aCAvIDIpXS52YWx1ZTtcclxuICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcclxuXHJcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSAndHJhbnNmb3JtIDAuNXMnO1xyXG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke3l9cHgpYDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHByZXZpb3VzIG9wdGlvbiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRQcmV2KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zWyh0aGlzLm9wdGlvbnMubGVuZ3RoIC8gMikgLSAxXS52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG5leHQgb3B0aW9uIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldE5leHQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnNbKHRoaXMub3B0aW9ucy5sZW5ndGggLyAyKSArIDFdLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQuXHJcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICAgKi9cclxuICBpc1ZhbGlkKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAodGhpcy5taW4gPT09IG51bGwgfHwgdmFsdWUgPj0gdGhpcy5taW4pICYmICh0aGlzLm1heCA9PT0gbnVsbCB8fCB2YWx1ZSA8PSB0aGlzLm1heCk7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=