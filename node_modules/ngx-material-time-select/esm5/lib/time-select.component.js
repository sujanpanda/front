/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostBinding, Inject, InjectionToken, Injector, Input, NgZone, Optional, Output, QueryList, ViewChildren, ViewContainerRef, ViewEncapsulation } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE, UP_ARROW } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import { mixinColor } from '@angular/material';
import { merge, Subject, Subscription } from 'rxjs';
import { filter, take } from 'rxjs/operators';
import { TimeAdapter } from './time-adapter.service';
import { createMissingTimeImplError } from './time-select-errors';
import { MatTimeSelectIntl } from './time-select-intl.service';
import { MatTimeUnitSelectComponent } from './time-unit-select.component';
/**
 * Used to generate a unique ID for each time select instance.
 * @type {?}
 */
var timeSelectUid = 0;
/**
 * Injection token used to initialize the time select data.
 * @type {?}
 */
export var MAT_TIME_SELECT_DATA = new InjectionToken('mat-time-select-data');
/**
 * Injection token that determines the scroll handling while the time select is opened.
 * @type {?}
 */
export var MAT_TIME_SELECT_SCROLL_STRATEGY = new InjectionToken('mat-time-select-scroll-strategy');
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
export function MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY(overlay) {
    return function () { return overlay.scrollStrategies.reposition(); };
}
/**
 * \@docs-private
 * @type {?}
 */
export var MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER = {
    provide: MAT_TIME_SELECT_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY
};
/**
 * @record
 * @template D
 */
export function MatTimeSelectData() { }
if (false) {
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.units;
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.value;
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.minTime;
    /** @type {?|undefined} */
    MatTimeSelectData.prototype.maxTime;
}
/**
 * \@docs-private
 */
var /**
 * \@docs-private
 */
MatTimeSelectContentBase = /** @class */ (function () {
    function MatTimeSelectContentBase(_elementRef) {
        this._elementRef = _elementRef;
    }
    return MatTimeSelectContentBase;
}());
/**
 * \@docs-private
 */
export { MatTimeSelectContentBase };
if (false) {
    /** @type {?} */
    MatTimeSelectContentBase.prototype._elementRef;
}
/** @type {?} */
export var _MatTimeSelectContentMixinBase = mixinColor(MatTimeSelectContentBase);
/**
 * Component used as the content for the time select popup.
 * \@docs-private
 * @template D
 */
var MatTimeSelectContentComponent = /** @class */ (function (_super) {
    tslib_1.__extends(MatTimeSelectContentComponent, _super);
    function MatTimeSelectContentComponent(elementRef, _intl, _timeAdapter, data) {
        var _this = _super.call(this, elementRef) || this;
        _this._intl = _intl;
        _this._timeAdapter = _timeAdapter;
        /**
         * Emits when the time select content selected time has been changed.
         */
        _this.valueChange = new EventEmitter();
        /**
         * \@docs-private
         */
        _this.class = 'mat-time-select-content';
        if (!_this._timeAdapter) {
            throw createMissingTimeImplError('TimeAdapter');
        }
        /** @type {?} */
        var time = _this._timeAdapter.isDateInstance(data.value) && _this._timeAdapter.isValid(data.value) ?
            _this._timeAdapter.clone(data.value) : _this._timeAdapter.now();
        /** @type {?} */
        var value = _this._timeAdapter.toMoment(_this._timeAdapter.clampTime(time, data.minTime, data.maxTime));
        /** @type {?} */
        var localeData = value.localeData();
        /** @type {?} */
        var displayFormat = localeData.longDateFormat('LTS');
        _this.hourClock = /hh?/g.test(displayFormat) ? 12 : 24;
        _this.value = value;
        _this.units = data.units || ['hour', 'minute'];
        _this.minTime = data.minTime ? _this._timeAdapter.toMoment(data.minTime) : null;
        _this.maxTime = data.maxTime ? _this._timeAdapter.toMoment(data.maxTime) : null;
        return _this;
    }
    Object.defineProperty(MatTimeSelectContentComponent.prototype, "amPm", {
        /**
         * The time period of the currently selected time of the time select content. Possible values: `am` when selected time hour is less
         * than 12; `pm` when selected time hour is greater than or equal to 12.
         */
        get: /**
         * The time period of the currently selected time of the time select content. Possible values: `am` when selected time hour is less
         * than 12; `pm` when selected time hour is greater than or equal to 12.
         * @return {?}
         */
        function () { return this.value ? (this.value.hour() < 12 ? 'am' : 'pm') : null; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.timeUnitSelectComponents) {
                this.timeUnitSelectComponents.toArray()
                    .filter(function (timeSelect) { return timeSelect.unit === 'hour'; })
                    .forEach(function (timeSelect) { return timeSelect.move(value === 'am' ? -12 : 12); });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the value of the given unit of time.
     * @param unit The unit of time to query.
     * @returns The retrieved value.
     */
    /**
     * Gets the value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The retrieved value.
     */
    MatTimeSelectContentComponent.prototype.get = /**
     * Gets the value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The retrieved value.
     */
    function (unit) {
        return this.value.get(unit);
    };
    /**
     * Sets the value of the given unit of time.
     * @param unit The unit of time to update.
     * @param value The value to set.
     */
    /**
     * Sets the value of the given unit of time.
     * @param {?} unit The unit of time to update.
     * @param {?} value The value to set.
     * @return {?}
     */
    MatTimeSelectContentComponent.prototype.set = /**
     * Sets the value of the given unit of time.
     * @param {?} unit The unit of time to update.
     * @param {?} value The value to set.
     * @return {?}
     */
    function (unit, value) {
        this.value.set(unit, value);
        this.valueChange.emit(this.value);
    };
    /**
     * Gets the minimum allowed value of the given unit of time.
     * @param unit The unit of time to query.
     * @returns The minimum value.
     */
    /**
     * Gets the minimum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The minimum value.
     */
    MatTimeSelectContentComponent.prototype.getMin = /**
     * Gets the minimum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The minimum value.
     */
    function (unit) {
        /** @type {?} */
        var min = null;
        if (this.minTime && this.value.isSame(this.minTime, 'day')) {
            if (this.getPrev(unit).isBefore(this.minTime)) {
                min = this.value.get(unit);
            }
            if (this.getNext(unit).isBefore(this.minTime)) {
                min = this.minTime.get(unit);
            }
        }
        return min;
    };
    /**
     * Gets the maximum allowed value of the given unit of time.
     * @param unit The unit of time to query.
     * @returns The maximum value.
     */
    /**
     * Gets the maximum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The maximum value.
     */
    MatTimeSelectContentComponent.prototype.getMax = /**
     * Gets the maximum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The maximum value.
     */
    function (unit) {
        /** @type {?} */
        var max = null;
        if (this.maxTime && this.value.isSame(this.maxTime, 'day')) {
            if (this.getNext(unit).isAfter(this.maxTime)) {
                max = this.value.get(unit);
            }
            if (this.getPrev(unit).isAfter(this.maxTime)) {
                max = this.maxTime.get(unit);
            }
        }
        return max;
    };
    /**
     * Gets the value after moving up the given unit of time.
     * @param unit The unit of time to move.
     * @returns The new value.
     */
    /**
     * Gets the value after moving up the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    MatTimeSelectContentComponent.prototype.getPrev = /**
     * Gets the value after moving up the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    function (unit) {
        /** @type {?} */
        var prev = this.value.clone().subtract((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        return this.value.clone().set(unit, prev.get(unit));
    };
    /**
     * Gets the value after moving down the given unit of time.
     * @param unit The unit of time to move.
     * @returns The new value.
     */
    /**
     * Gets the value after moving down the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    MatTimeSelectContentComponent.prototype.getNext = /**
     * Gets the value after moving down the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    function (unit) {
        /** @type {?} */
        var next = this.value.clone().add((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        return this.value.clone().set(unit, next.get(unit));
    };
    /**
     * Gets the value before midday.
     */
    /**
     * Gets the value before midday.
     * @return {?}
     */
    MatTimeSelectContentComponent.prototype.getAM = /**
     * Gets the value before midday.
     * @return {?}
     */
    function () {
        if (this.value.hour() >= 12) {
            return this.value.clone().subtract(12, 'hour');
        }
        return this.value;
    };
    /**
     * Gets the value after midday.
     */
    /**
     * Gets the value after midday.
     * @return {?}
     */
    MatTimeSelectContentComponent.prototype.getPM = /**
     * Gets the value after midday.
     * @return {?}
     */
    function () {
        if (this.value.hour() < 12) {
            return this.value.clone().add(12, 'hour');
        }
        return this.value;
    };
    /**
     * Whether the given value is selectable.
     * @param value The value to check.
     * @returns `true` if the value is valid. Otherwise `false`.
     */
    /**
     * Whether the given value is selectable.
     * @param {?} value The value to check.
     * @return {?} `true` if the value is valid. Otherwise `false`.
     */
    MatTimeSelectContentComponent.prototype.isValid = /**
     * Whether the given value is selectable.
     * @param {?} value The value to check.
     * @return {?} `true` if the value is valid. Otherwise `false`.
     */
    function (value) {
        /** @type {?} */
        var beforeMin = this.minTime && value.isBefore(this.minTime);
        /** @type {?} */
        var afterMax = this.maxTime && value.isAfter(this.maxTime);
        return !(beforeMin || afterMax);
    };
    MatTimeSelectContentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mat-time-select-content',
                    template: "<table class=\"mat-time-select-table mat-{{ color }}\">\r\n  <tr>\r\n    <ng-container *ngFor=\"let unit of units; first as first\">\r\n      <td *ngIf=\"!first\" class=\"mat-time-select-column mat-time-select-separator\">\r\n        <div class=\"mat-time-unit-separator\">\r\n          <span class=\"mat-time-unit-separator-text\">:</span>\r\n        </div>\r\n      </td>\r\n      <td class=\"mat-time-select-column mat-time-select-{{ unit }}\">\r\n        <mat-time-unit-select\r\n          [min]=\"getMin(unit)\"\r\n          [max]=\"getMax(unit)\"\r\n          [unit]=\"unit\"\r\n          [value]=\"get(unit)\"\r\n          (valueChange)=\"set(unit, $event)\">\r\n        </mat-time-unit-select>\r\n      </td>\r\n    </ng-container>\r\n  </tr>\r\n  <tr *ngIf=\"hourClock === 12\">\r\n    <td class=\"mat-time-ampm\" [colSpan]=\"(units.length * 2) - 1\">\r\n      <mat-button-toggle-group [value]=\"amPm\" (change)=\"amPm = $event.value\">\r\n        <mat-button-toggle value=\"am\" [disabled]=\"!isValid(getAM())\">{{ _intl.amLabel }}</mat-button-toggle>\r\n        <mat-button-toggle value=\"pm\" [disabled]=\"!isValid(getPM())\">{{ _intl.pmLabel }}</mat-button-toggle>\r\n      </mat-button-toggle-group>\r\n    </td>\r\n  </tr>\r\n</table>\r\n",
                    exportAs: 'matTimeSelectContent',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".mat-time-select-content{display:block;border-radius:4px}.mat-time-select-content .mat-time-select-table{border-collapse:collapse}.mat-time-select-content .mat-time-select-column{width:80px;padding:0}.mat-time-select-content .mat-time-select-column .mat-time-unit-select-panel{position:relative}.mat-time-select-content .mat-time-select-hour .mat-time-unit-select-panel{top:-440px}.mat-time-select-content .mat-time-select-minute .mat-time-unit-select-panel,.mat-time-select-content .mat-time-select-second .mat-time-unit-select-panel{top:-1160px}.mat-time-select-content .mat-time-select-separator{text-align:center}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;height:40px;width:100%}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator-text{width:100%}.mat-time-select-content .mat-time-ampm{text-align:center}"]
                }] }
    ];
    /** @nocollapse */
    MatTimeSelectContentComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: MatTimeSelectIntl },
        { type: TimeAdapter, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TIME_SELECT_DATA,] }] }
    ]; };
    MatTimeSelectContentComponent.propDecorators = {
        color: [{ type: Input }],
        units: [{ type: Input }],
        value: [{ type: Input }],
        minTime: [{ type: Input }],
        maxTime: [{ type: Input }],
        valueChange: [{ type: Output }],
        timeUnitSelectComponents: [{ type: ViewChildren, args: [MatTimeUnitSelectComponent,] }],
        class: [{ type: HostBinding, args: ['class',] }]
    };
    return MatTimeSelectContentComponent;
}(_MatTimeSelectContentMixinBase));
export { MatTimeSelectContentComponent };
if (false) {
    /**
     * \@docs-private
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.color;
    /**
     * The array of unit of time selectable in the time select content.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.units;
    /**
     * The currently selected time of the time select content.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.value;
    /**
     * The minimum selectable time.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.minTime;
    /**
     * The minimum selectable time.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.maxTime;
    /**
     * Emits when the time select content selected time has been changed.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.valueChange;
    /**
     * Reference to the internal time unit select components.
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.timeUnitSelectComponents;
    /**
     * \@docs-private
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.class;
    /**
     * The hour clock type. Possible values: 12: 12 hour clock; 24: 24 hour clock
     * @type {?}
     */
    MatTimeSelectContentComponent.prototype.hourClock;
    /** @type {?} */
    MatTimeSelectContentComponent.prototype._intl;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectContentComponent.prototype._timeAdapter;
}
/**
 * Component responsible for managing the time select popup.
 * @template D
 */
var MatTimeSelectComponent = /** @class */ (function () {
    function MatTimeSelectComponent(_overlay, _injector, _ngZone, _viewContainerRef, scrollStrategy, _timeAdapter, _dir, _document) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._viewContainerRef = _viewContainerRef;
        this._timeAdapter = _timeAdapter;
        this._dir = _dir;
        this._document = _document;
        /**
         * Subscription to value changes in the associated input element.
         */
        this._inputSubscription = Subscription.EMPTY;
        this._opened = false;
        this._disabledChange = new Subject();
        this._selectedChange = new Subject();
        /**
         * The element that was focused before the time select was opened.
         */
        this._focusedElementBeforeOpen = null;
        /**
         * Emits when the time select has been opened.
         */
        this.openStream = new EventEmitter();
        /**
         * Emits when the time select has been closed.
         */
        this.closeStream = new EventEmitter();
        /**
         * The id for the time select popup.
         */
        this.id = "mat-time-select-" + timeSelectUid++;
        if (!this._timeAdapter) {
            throw createMissingTimeImplError('TimeAdapter');
        }
        this._scrollStrategy = scrollStrategy;
    }
    Object.defineProperty(MatTimeSelectComponent.prototype, "startAt", {
        /** The initial time of the time select. */
        get: /**
         * The initial time of the time select.
         * @return {?}
         */
        function () { return this._startAt || (this._timeSelectInput ? this._timeSelectInput.value : null); },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._startAt = this._getValidDateOrNull(this._timeAdapter.deserialize(value)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectComponent.prototype, "color", {
        /** The color palette to use on the time select popup. */
        get: /**
         * The color palette to use on the time select popup.
         * @return {?}
         */
        function () { return this._color || (this._timeSelectInput ? this._timeSelectInput.getThemePalette() : undefined); },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._color = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectComponent.prototype, "disabled", {
        /** Whether the time select pop-up should disabled. */
        get: /**
         * Whether the time select pop-up should disabled.
         * @return {?}
         */
        function () {
            return this._disabled !== undefined ? this._disabled : (this._timeSelectInput ? this._timeSelectInput.disabled : false);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var disabled = coerceBooleanProperty(value);
            if (this._disabled !== disabled) {
                this._disabled = disabled;
                this._disabledChange.next(disabled);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectComponent.prototype, "selected", {
        /** The currently selected time. */
        get: /**
         * The currently selected time.
         * @return {?}
         */
        function () { return this._selected; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._selected = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectComponent.prototype, "opened", {
        /** Whether the time select is opened. */
        get: /**
         * Whether the time select is opened.
         * @return {?}
         */
        function () { return this._opened; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { value ? this.open() : close(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectComponent.prototype, "disabledChange", {
        /** Emits when the time select disabled state has been changed. */
        get: /**
         * Emits when the time select disabled state has been changed.
         * @return {?}
         */
        function () { return this._disabledChange.asObservable(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimeSelectComponent.prototype, "selectedChange", {
        /** Emits when the time select selected time has been changed. */
        get: /**
         * Emits when the time select selected time has been changed.
         * @return {?}
         */
        function () { return this._selectedChange.asObservable(); },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatTimeSelectComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.close();
        this._inputSubscription.unsubscribe();
        this._disabledChange.complete();
        if (this._popupRef) {
            this._popupRef.dispose();
            this._popupComponentRef = null;
        }
    };
    /**
     * Selects the given time.
     * @param time The date time to select.
     */
    /**
     * Selects the given time.
     * @param {?} time The date time to select.
     * @return {?}
     */
    MatTimeSelectComponent.prototype.select = /**
     * Selects the given time.
     * @param {?} time The date time to select.
     * @return {?}
     */
    function (time) {
        /** @type {?} */
        var oldValue = this.selected;
        /** @type {?} */
        var value = this._timeAdapter.clone(time);
        this.selected = value;
        if (!this._timeAdapter.sameTime(oldValue, value)) {
            this._selectedChange.next(value);
        }
    };
    /**
     * Register an input with this time select.
     * @param input The time select input to register with this time select.
     */
    /**
     * Register an input with this time select.
     * @param {?} input The time select input to register with this time select.
     * @return {?}
     */
    MatTimeSelectComponent.prototype.registerInput = /**
     * Register an input with this time select.
     * @param {?} input The time select input to register with this time select.
     * @return {?}
     */
    function (input) {
        var _this = this;
        if (this._timeSelectInput) {
            throw Error('A MatTimeSelect can only be associated with a single input.');
        }
        this._timeSelectInput = input;
        this._inputSubscription = this._timeSelectInput.valueChange.subscribe(function (value) { return _this.selected = value; });
    };
    /** Open the time select. */
    /**
     * Open the time select.
     * @return {?}
     */
    MatTimeSelectComponent.prototype.open = /**
     * Open the time select.
     * @return {?}
     */
    function () {
        if (this._opened || this.disabled) {
            return;
        }
        if (!this._timeSelectInput) {
            throw Error('Attempted to open an MatTimeSelect with no associated input.');
        }
        if (this._document) {
            this._focusedElementBeforeOpen = this._document.activeElement;
        }
        this._openAsPopup();
        this._opened = true;
        this.openStream.emit();
    };
    /** Close the time select. */
    /**
     * Close the time select.
     * @return {?}
     */
    MatTimeSelectComponent.prototype.close = /**
     * Close the time select.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._opened) {
            return;
        }
        if (this._popupRef && this._popupRef.hasAttached()) {
            this._popupRef.detach();
        }
        if (this._popupComponentPortal && this._popupComponentPortal.isAttached) {
            this._popupComponentPortal.detach();
        }
        /** @type {?} */
        var completeClose = function () {
            // The `_opened` could've been reset already if
            // we got two events in quick succession.
            if (_this._opened) {
                _this._opened = false;
                _this.closeStream.emit();
                _this._focusedElementBeforeOpen = null;
            }
        };
        if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {
            // Because IE moves focus asynchronously, we can't count on it being restored before we've
            // marked the time select as closed. If the event fires out of sequence and the element that
            // we're refocusing opens the time select on focus, the user could be stuck with not being
            // able to close the select panel at all. We work around it by making the logic, that marks
            // the time select as closed, async as well.
            this._focusedElementBeforeOpen.focus();
            setTimeout(completeClose);
        }
        else {
            completeClose();
        }
    };
    /** Open the time select as a popup. */
    /**
     * Open the time select as a popup.
     * @private
     * @return {?}
     */
    MatTimeSelectComponent.prototype._openAsPopup = /**
     * Open the time select as a popup.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._popupComponentPortal = new ComponentPortal(MatTimeSelectContentComponent, this._viewContainerRef, this._createInjector());
        if (!this._popupRef) {
            this._createPopup();
        }
        if (!this._popupRef.hasAttached()) {
            this._popupComponentRef = this._popupRef.attach(this._popupComponentPortal);
            this._popupComponentRef.instance.valueChange.subscribe(function (value) { return _this.select(_this._timeAdapter.deserialize(value.toISOString())); });
            this._setColor();
            // Update the position once the select panel has rendered.
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {
                _this._popupRef.updatePosition();
            });
        }
    };
    /** Create a portal injector to inject time select initial data. */
    /**
     * Create a portal injector to inject time select initial data.
     * @private
     * @return {?}
     */
    MatTimeSelectComponent.prototype._createInjector = /**
     * Create a portal injector to inject time select initial data.
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var data = {
            value: this.startAt,
            minTime: this._timeSelectInput && this._timeSelectInput.min,
            maxTime: this._timeSelectInput && this._timeSelectInput.max
        };
        /** @type {?} */
        var injectorTokens = new WeakMap([
            [MAT_TIME_SELECT_DATA, data]
        ]);
        return new PortalInjector(this._injector, injectorTokens);
    };
    /** Create the popup. */
    /**
     * Create the popup.
     * @private
     * @return {?}
     */
    MatTimeSelectComponent.prototype._createPopup = /**
     * Create the popup.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var overlayConfig = new OverlayConfig({
            positionStrategy: this._createPopupPositionStrategy(),
            hasBackdrop: true,
            backdropClass: 'mat-overlay-transparent-backdrop',
            direction: this._dir,
            scrollStrategy: this._scrollStrategy(),
            panelClass: 'mat-time-select-popup',
        });
        this._popupRef = this._overlay.create(overlayConfig);
        this._popupRef.overlayElement.setAttribute('role', 'dialog');
        merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(function (event) {
            // Closing on alt + up is only valid when there's an input associated with the time select.
            return event.keyCode === ESCAPE ||
                (_this._timeSelectInput && event.altKey && event.keyCode === UP_ARROW);
        }))).subscribe(function () { return _this.close(); });
    };
    /** Create the popup position strategy. */
    /**
     * Create the popup position strategy.
     * @private
     * @return {?}
     */
    MatTimeSelectComponent.prototype._createPopupPositionStrategy = /**
     * Create the popup position strategy.
     * @private
     * @return {?}
     */
    function () {
        return this._overlay.position()
            .flexibleConnectedTo(this._timeSelectInput.getConnectedOverlayOrigin())
            .withTransformOriginOn('.mat-time-select-content')
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withLockedPosition()
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
    };
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    MatTimeSelectComponent.prototype._getValidDateOrNull = /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    function (obj) {
        return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
    };
    /** Passes the current theme color along to the time select overlay. */
    /**
     * Passes the current theme color along to the time select overlay.
     * @private
     * @return {?}
     */
    MatTimeSelectComponent.prototype._setColor = /**
     * Passes the current theme color along to the time select overlay.
     * @private
     * @return {?}
     */
    function () {
        if (this._popupComponentRef) {
            this._popupComponentRef.instance.color = this.color;
        }
    };
    MatTimeSelectComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mat-time-select',
                    template: '',
                    exportAs: 'matTimeSelect',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    MatTimeSelectComponent.ctorParameters = function () { return [
        { type: Overlay },
        { type: Injector },
        { type: NgZone },
        { type: ViewContainerRef },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_TIME_SELECT_SCROLL_STRATEGY,] }] },
        { type: TimeAdapter, decorators: [{ type: Optional }] },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    MatTimeSelectComponent.propDecorators = {
        openStream: [{ type: Output, args: ['open',] }],
        closeStream: [{ type: Output, args: ['close',] }],
        startAt: [{ type: Input }],
        color: [{ type: Input }],
        disabled: [{ type: Input }],
        selected: [{ type: Input }],
        opened: [{ type: Input }]
    };
    return MatTimeSelectComponent;
}());
export { MatTimeSelectComponent };
if (false) {
    /**
     * Subscription to value changes in the associated input element.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._inputSubscription;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._startAt;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._color;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._selected;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._opened;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._disabledChange;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._selectedChange;
    /**
     * A reference to the overlay when the time select is opened as a popup.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._popupRef;
    /**
     * A portal containing the popup for this time select.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._popupComponentPortal;
    /**
     * Reference to the component instantiated in popup mode.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._popupComponentRef;
    /**
     * The element that was focused before the time select was opened.
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._focusedElementBeforeOpen;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._scrollStrategy;
    /**
     * The input element this time select is associated with.
     * @type {?}
     */
    MatTimeSelectComponent.prototype._timeSelectInput;
    /**
     * Emits when the time select has been opened.
     * @type {?}
     */
    MatTimeSelectComponent.prototype.openStream;
    /**
     * Emits when the time select has been closed.
     * @type {?}
     */
    MatTimeSelectComponent.prototype.closeStream;
    /**
     * The id for the time select popup.
     * @type {?}
     */
    MatTimeSelectComponent.prototype.id;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._timeAdapter;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    MatTimeSelectComponent.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS1zZWxlY3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hdGVyaWFsLXRpbWUtc2VsZWN0LyIsInNvdXJjZXMiOlsibGliL3RpbWUtc2VsZWN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUVULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixjQUFjLEVBQ2QsUUFBUSxFQUNSLEtBQUssRUFDTCxNQUFNLEVBRU4sUUFBUSxFQUNSLE1BQU0sRUFFTixTQUFTLEVBQ1QsWUFBWSxFQUNaLGdCQUFnQixFQUNoQixpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsTUFBTSxFQUFFLFFBQVEsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ3ZELE9BQU8sRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUErQyxNQUFNLHNCQUFzQixDQUFDO0FBQzFHLE9BQU8sRUFBQyxlQUFlLEVBQUUsY0FBYyxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDcEUsT0FBTyxFQUF5QixVQUFVLEVBQWUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRixPQUFPLEVBQUMsS0FBSyxFQUFjLE9BQU8sRUFBRSxZQUFZLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDOUQsT0FBTyxFQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUU1QyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDbkQsT0FBTyxFQUFDLDBCQUEwQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7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QTJCOzs7OztJQUMzQiwyQ0FBcUI7Ozs7O0lBQ3JCLHlDQUF3Qjs7Ozs7SUFFeEIsaURBQW1FOzs7OztJQUNuRSxpREFBdUQ7Ozs7OztJQUd2RCwyQ0FBOEI7Ozs7OztJQUU5Qix1REFBaUY7Ozs7OztJQUVqRixvREFBMkU7Ozs7OztJQUUzRSwyREFBNkQ7Ozs7O0lBRTdELGlEQUF1RDs7Ozs7SUFHdkQsa0RBQWlEOzs7OztJQUdqRCw0Q0FBMEU7Ozs7O0lBRTFFLDZDQUE0RTs7Ozs7SUFHNUUsb0NBQTBDOzs7OztJQXdDOUIsMENBQXlCOzs7OztJQUN6QiwyQ0FBMkI7Ozs7O0lBQzNCLHlDQUF1Qjs7Ozs7SUFDdkIsbURBQTJDOzs7OztJQUUzQyw4Q0FBZ0Q7Ozs7O0lBQ2hELHNDQUF3Qzs7Ozs7SUFDeEMsMkNBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDb21wb25lbnQsXHJcbiAgQ29tcG9uZW50UmVmLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEhvc3RCaW5kaW5nLFxyXG4gIEluamVjdCxcclxuICBJbmplY3Rpb25Ub2tlbixcclxuICBJbmplY3RvcixcclxuICBJbnB1dCxcclxuICBOZ1pvbmUsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9wdGlvbmFsLFxyXG4gIE91dHB1dCxcclxuICBQcm92aWRlcixcclxuICBRdWVyeUxpc3QsXHJcbiAgVmlld0NoaWxkcmVuLFxyXG4gIFZpZXdDb250YWluZXJSZWYsXHJcbiAgVmlld0VuY2Fwc3VsYXRpb25cclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtEaXJlY3Rpb25hbGl0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xyXG5pbXBvcnQge2NvZXJjZUJvb2xlYW5Qcm9wZXJ0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHtFU0NBUEUsIFVQX0FSUk9XfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xyXG5pbXBvcnQge092ZXJsYXksIE92ZXJsYXlDb25maWcsIE92ZXJsYXlSZWYsIFBvc2l0aW9uU3RyYXRlZ3ksIFNjcm9sbFN0cmF0ZWd5fSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XHJcbmltcG9ydCB7Q29tcG9uZW50UG9ydGFsLCBQb3J0YWxJbmplY3Rvcn0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XHJcbmltcG9ydCB7Q2FuQ29sb3IsIENhbkNvbG9yQ3RvciwgbWl4aW5Db2xvciwgVGhlbWVQYWxldHRlfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcbmltcG9ydCB7bWVyZ2UsIE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7ZmlsdGVyLCB0YWtlfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7RHVyYXRpb25JbnB1dEFyZzEsIER1cmF0aW9uSW5wdXRBcmcyLCBNb21lbnQsIHVuaXRPZlRpbWV9IGZyb20gJ21vbWVudCc7XHJcbmltcG9ydCB7VGltZUFkYXB0ZXJ9IGZyb20gJy4vdGltZS1hZGFwdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQge2NyZWF0ZU1pc3NpbmdUaW1lSW1wbEVycm9yfSBmcm9tICcuL3RpbWUtc2VsZWN0LWVycm9ycyc7XHJcbmltcG9ydCB7TWF0VGltZVNlbGVjdEludGx9IGZyb20gJy4vdGltZS1zZWxlY3QtaW50bC5zZXJ2aWNlJztcclxuaW1wb3J0IHtNYXRUaW1lU2VsZWN0SW5wdXREaXJlY3RpdmV9IGZyb20gJy4vdGltZS1zZWxlY3QtaW5wdXQuZGlyZWN0aXZlJztcclxuaW1wb3J0IHtNYXRUaW1lVW5pdFNlbGVjdENvbXBvbmVudH0gZnJvbSAnLi90aW1lLXVuaXQtc2VsZWN0LmNvbXBvbmVudCc7XHJcblxyXG4vKiogVXNlZCB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgZWFjaCB0aW1lIHNlbGVjdCBpbnN0YW5jZS4gKi9cclxubGV0IHRpbWVTZWxlY3RVaWQgPSAwO1xyXG5cclxuLyoqIEluamVjdGlvbiB0b2tlbiB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHRpbWUgc2VsZWN0IGRhdGEuICovXHJcbmV4cG9ydCBjb25zdCBNQVRfVElNRV9TRUxFQ1RfREFUQSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxNb21lbnQ+KCdtYXQtdGltZS1zZWxlY3QtZGF0YScpO1xyXG5cclxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGRldGVybWluZXMgdGhlIHNjcm9sbCBoYW5kbGluZyB3aGlsZSB0aGUgdGltZSBzZWxlY3QgaXMgb3BlbmVkLiAqL1xyXG5leHBvcnQgY29uc3QgTUFUX1RJTUVfU0VMRUNUX1NDUk9MTF9TVFJBVEVHWSA9IG5ldyBJbmplY3Rpb25Ub2tlbjwoKSA9PiBTY3JvbGxTdHJhdGVneT4oJ21hdC10aW1lLXNlbGVjdC1zY3JvbGwtc3RyYXRlZ3knKTtcclxuXHJcbi8qKiBAZG9jcy1wcml2YXRlICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNQVRfVElNRV9TRUxFQ1RfU0NST0xMX1NUUkFURUdZX0ZBQ1RPUlkob3ZlcmxheTogT3ZlcmxheSk6ICgpID0+IFNjcm9sbFN0cmF0ZWd5IHtcclxuICByZXR1cm4gKCkgPT4gb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcclxufVxyXG5cclxuLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuZXhwb3J0IGNvbnN0IE1BVF9USU1FX1NFTEVDVF9TQ1JPTExfU1RSQVRFR1lfRkFDVE9SWV9QUk9WSURFUjogUHJvdmlkZXIgPSB7XHJcbiAgcHJvdmlkZTogTUFUX1RJTUVfU0VMRUNUX1NDUk9MTF9TVFJBVEVHWSxcclxuICBkZXBzOiBbT3ZlcmxheV0sXHJcbiAgdXNlRmFjdG9yeTogTUFUX1RJTUVfU0VMRUNUX1NDUk9MTF9TVFJBVEVHWV9GQUNUT1JZXHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hdFRpbWVTZWxlY3REYXRhPEQ+IHtcclxuICB1bml0cz86IHVuaXRPZlRpbWUuQWxsW107XHJcbiAgdmFsdWU/OiBEO1xyXG4gIG1pblRpbWU/OiBEO1xyXG4gIG1heFRpbWU/OiBEO1xyXG59XHJcblxyXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG5leHBvcnQgY2xhc3MgTWF0VGltZVNlbGVjdENvbnRlbnRCYXNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBfTWF0VGltZVNlbGVjdENvbnRlbnRNaXhpbkJhc2U6IENhbkNvbG9yQ3RvciAmIHR5cGVvZiBNYXRUaW1lU2VsZWN0Q29udGVudEJhc2UgPVxyXG4gIG1peGluQ29sb3IoTWF0VGltZVNlbGVjdENvbnRlbnRCYXNlKTtcclxuXHJcbi8qKlxyXG4gKiBDb21wb25lbnQgdXNlZCBhcyB0aGUgY29udGVudCBmb3IgdGhlIHRpbWUgc2VsZWN0IHBvcHVwLlxyXG4gKiBAZG9jcy1wcml2YXRlXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ21hdC10aW1lLXNlbGVjdC1jb250ZW50JyxcclxuICB0ZW1wbGF0ZVVybDogJy4vdGltZS1zZWxlY3QtY29udGVudC5jb21wb25lbnQuaHRtbCcsXHJcbiAgc3R5bGVVcmxzOiBbJy4vdGltZS1zZWxlY3QtY29udGVudC5jb21wb25lbnQuc2NzcyddLFxyXG4gIGV4cG9ydEFzOiAnbWF0VGltZVNlbGVjdENvbnRlbnQnLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hdFRpbWVTZWxlY3RDb250ZW50Q29tcG9uZW50PEQ+IGV4dGVuZHMgX01hdFRpbWVTZWxlY3RDb250ZW50TWl4aW5CYXNlIGltcGxlbWVudHMgQ2FuQ29sb3Ige1xyXG5cclxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xyXG4gIEBJbnB1dCgpIGNvbG9yOiBUaGVtZVBhbGV0dGU7XHJcbiAgLyoqIFRoZSBhcnJheSBvZiB1bml0IG9mIHRpbWUgc2VsZWN0YWJsZSBpbiB0aGUgdGltZSBzZWxlY3QgY29udGVudC4gKi9cclxuICBASW5wdXQoKSB1bml0czogdW5pdE9mVGltZS5BbGxbXTtcclxuICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0aW1lIG9mIHRoZSB0aW1lIHNlbGVjdCBjb250ZW50LiAqL1xyXG4gIEBJbnB1dCgpIHZhbHVlOiBNb21lbnQ7XHJcbiAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgdGltZS4gKi9cclxuICBASW5wdXQoKSBtaW5UaW1lOiBNb21lbnQ7XHJcbiAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgdGltZS4gKi9cclxuICBASW5wdXQoKSBtYXhUaW1lOiBNb21lbnQ7XHJcblxyXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSB0aW1lIHNlbGVjdCBjb250ZW50IHNlbGVjdGVkIHRpbWUgaGFzIGJlZW4gY2hhbmdlZC4gKi9cclxuICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNb21lbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb21lbnQ+KCk7XHJcblxyXG4gIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIHRpbWUgdW5pdCBzZWxlY3QgY29tcG9uZW50cy4gKi9cclxuICBAVmlld0NoaWxkcmVuKE1hdFRpbWVVbml0U2VsZWN0Q29tcG9uZW50KSB0aW1lVW5pdFNlbGVjdENvbXBvbmVudHM6IFF1ZXJ5TGlzdDxNYXRUaW1lVW5pdFNlbGVjdENvbXBvbmVudDxEPj47XHJcblxyXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIHJlYWRvbmx5IGNsYXNzID0gJ21hdC10aW1lLXNlbGVjdC1jb250ZW50JztcclxuXHJcbiAgLyoqIFRoZSBob3VyIGNsb2NrIHR5cGUuIFBvc3NpYmxlIHZhbHVlczogMTI6IDEyIGhvdXIgY2xvY2s7IDI0OiAyNCBob3VyIGNsb2NrICovXHJcbiAgaG91ckNsb2NrOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB0aW1lIHBlcmlvZCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRpbWUgb2YgdGhlIHRpbWUgc2VsZWN0IGNvbnRlbnQuIFBvc3NpYmxlIHZhbHVlczogYGFtYCB3aGVuIHNlbGVjdGVkIHRpbWUgaG91ciBpcyBsZXNzXHJcbiAgICogdGhhbiAxMjsgYHBtYCB3aGVuIHNlbGVjdGVkIHRpbWUgaG91ciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMTIuXHJcbiAgICovXHJcbiAgZ2V0IGFtUG0oKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMudmFsdWUgPyAodGhpcy52YWx1ZS5ob3VyKCkgPCAxMiA/ICdhbScgOiAncG0nKSA6IG51bGw7IH1cclxuICBzZXQgYW1QbSh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICBpZiAodGhpcy50aW1lVW5pdFNlbGVjdENvbXBvbmVudHMpIHtcclxuICAgICAgdGhpcy50aW1lVW5pdFNlbGVjdENvbXBvbmVudHMudG9BcnJheSgpXHJcbiAgICAgICAgLmZpbHRlcih0aW1lU2VsZWN0ID0+IHRpbWVTZWxlY3QudW5pdCA9PT0gJ2hvdXInKVxyXG4gICAgICAgIC5mb3JFYWNoKHRpbWVTZWxlY3QgPT4gdGltZVNlbGVjdC5tb3ZlKHZhbHVlID09PSAnYW0nID8gLTEyIDogMTIpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgcHVibGljIF9pbnRsOiBNYXRUaW1lU2VsZWN0SW50bCxcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF90aW1lQWRhcHRlcjogVGltZUFkYXB0ZXI8RD4sXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRfVElNRV9TRUxFQ1RfREFUQSkgZGF0YTogTWF0VGltZVNlbGVjdERhdGE8RD4pIHtcclxuICAgIHN1cGVyKGVsZW1lbnRSZWYpO1xyXG5cclxuICAgIGlmICghdGhpcy5fdGltZUFkYXB0ZXIpIHtcclxuICAgICAgdGhyb3cgY3JlYXRlTWlzc2luZ1RpbWVJbXBsRXJyb3IoJ1RpbWVBZGFwdGVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX3RpbWVBZGFwdGVyLmlzRGF0ZUluc3RhbmNlKGRhdGEudmFsdWUpICYmIHRoaXMuX3RpbWVBZGFwdGVyLmlzVmFsaWQoZGF0YS52YWx1ZSkgP1xyXG4gICAgICB0aGlzLl90aW1lQWRhcHRlci5jbG9uZShkYXRhLnZhbHVlKSA6IHRoaXMuX3RpbWVBZGFwdGVyLm5vdygpO1xyXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl90aW1lQWRhcHRlci50b01vbWVudCh0aGlzLl90aW1lQWRhcHRlci5jbGFtcFRpbWUodGltZSwgZGF0YS5taW5UaW1lLCBkYXRhLm1heFRpbWUpKTtcclxuICAgIGNvbnN0IGxvY2FsZURhdGEgPSB2YWx1ZS5sb2NhbGVEYXRhKCk7XHJcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0ID0gbG9jYWxlRGF0YS5sb25nRGF0ZUZvcm1hdCgnTFRTJyk7XHJcbiAgICB0aGlzLmhvdXJDbG9jayA9IC9oaD8vZy50ZXN0KGRpc3BsYXlGb3JtYXQpID8gMTIgOiAyNDtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMudW5pdHMgPSBkYXRhLnVuaXRzIHx8IFsnaG91cicsICdtaW51dGUnXTtcclxuICAgIHRoaXMubWluVGltZSA9IGRhdGEubWluVGltZSA/IHRoaXMuX3RpbWVBZGFwdGVyLnRvTW9tZW50KGRhdGEubWluVGltZSkgOiBudWxsO1xyXG4gICAgdGhpcy5tYXhUaW1lID0gZGF0YS5tYXhUaW1lID8gdGhpcy5fdGltZUFkYXB0ZXIudG9Nb21lbnQoZGF0YS5tYXhUaW1lKSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gdW5pdCBvZiB0aW1lLlxyXG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRpbWUgdG8gcXVlcnkuXHJcbiAgICogQHJldHVybnMgVGhlIHJldHJpZXZlZCB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQodW5pdDogdW5pdE9mVGltZS5BbGwpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZ2V0KHVuaXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHVuaXQgb2YgdGltZS5cclxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aW1lIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgKi9cclxuICBzZXQodW5pdDogdW5pdE9mVGltZS5BbGwsIHZhbHVlOiBudW1iZXIpIHtcclxuICAgIHRoaXMudmFsdWUuc2V0KHVuaXQsIHZhbHVlKTtcclxuICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG1pbmltdW0gYWxsb3dlZCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gdW5pdCBvZiB0aW1lLlxyXG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRpbWUgdG8gcXVlcnkuXHJcbiAgICogQHJldHVybnMgVGhlIG1pbmltdW0gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0TWluKHVuaXQ6IHVuaXRPZlRpbWUuQWxsKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICBsZXQgbWluID0gbnVsbDtcclxuICAgIGlmICh0aGlzLm1pblRpbWUgJiYgdGhpcy52YWx1ZS5pc1NhbWUodGhpcy5taW5UaW1lLCAnZGF5JykpIHtcclxuICAgICAgaWYgKHRoaXMuZ2V0UHJldih1bml0KS5pc0JlZm9yZSh0aGlzLm1pblRpbWUpKSB7XHJcbiAgICAgICAgbWluID0gdGhpcy52YWx1ZS5nZXQodW5pdCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZ2V0TmV4dCh1bml0KS5pc0JlZm9yZSh0aGlzLm1pblRpbWUpKSB7XHJcbiAgICAgICAgbWluID0gdGhpcy5taW5UaW1lLmdldCh1bml0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1pbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gdW5pdCBvZiB0aW1lLlxyXG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRpbWUgdG8gcXVlcnkuXHJcbiAgICogQHJldHVybnMgVGhlIG1heGltdW0gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0TWF4KHVuaXQ6IHVuaXRPZlRpbWUuQWxsKTogbnVtYmVyIHwgbnVsbCB7XHJcbiAgICBsZXQgbWF4ID0gbnVsbDtcclxuICAgIGlmICh0aGlzLm1heFRpbWUgJiYgdGhpcy52YWx1ZS5pc1NhbWUodGhpcy5tYXhUaW1lLCAnZGF5JykpIHtcclxuICAgICAgaWYgKHRoaXMuZ2V0TmV4dCh1bml0KS5pc0FmdGVyKHRoaXMubWF4VGltZSkpIHtcclxuICAgICAgICBtYXggPSB0aGlzLnZhbHVlLmdldCh1bml0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5nZXRQcmV2KHVuaXQpLmlzQWZ0ZXIodGhpcy5tYXhUaW1lKSkge1xyXG4gICAgICAgIG1heCA9IHRoaXMubWF4VGltZS5nZXQodW5pdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhZnRlciBtb3ZpbmcgdXAgdGhlIGdpdmVuIHVuaXQgb2YgdGltZS5cclxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aW1lIHRvIG1vdmUuXHJcbiAgICogQHJldHVybnMgVGhlIG5ldyB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRQcmV2KHVuaXQ6IHVuaXRPZlRpbWUuQWxsKTogTW9tZW50IHtcclxuICAgIGNvbnN0IHByZXYgPSB0aGlzLnZhbHVlLmNsb25lKCkuc3VidHJhY3QoMSBhcyBEdXJhdGlvbklucHV0QXJnMSwgdW5pdCBhcyBEdXJhdGlvbklucHV0QXJnMik7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5jbG9uZSgpLnNldCh1bml0LCBwcmV2LmdldCh1bml0KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhZnRlciBtb3ZpbmcgZG93biB0aGUgZ2l2ZW4gdW5pdCBvZiB0aW1lLlxyXG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRpbWUgdG8gbW92ZS5cclxuICAgKiBAcmV0dXJucyBUaGUgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldE5leHQodW5pdDogdW5pdE9mVGltZS5BbGwpOiBNb21lbnQge1xyXG4gICAgY29uc3QgbmV4dCA9IHRoaXMudmFsdWUuY2xvbmUoKS5hZGQoMSBhcyBEdXJhdGlvbklucHV0QXJnMSwgdW5pdCBhcyBEdXJhdGlvbklucHV0QXJnMik7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5jbG9uZSgpLnNldCh1bml0LCBuZXh0LmdldCh1bml0KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB2YWx1ZSBiZWZvcmUgbWlkZGF5LlxyXG4gICAqL1xyXG4gIGdldEFNKCk6IE1vbWVudCB7XHJcbiAgICBpZiAodGhpcy52YWx1ZS5ob3VyKCkgPj0gMTIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuY2xvbmUoKS5zdWJ0cmFjdCgxMiwgJ2hvdXInKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdmFsdWUgYWZ0ZXIgbWlkZGF5LlxyXG4gICAqL1xyXG4gIGdldFBNKCk6IE1vbWVudCB7XHJcbiAgICBpZiAodGhpcy52YWx1ZS5ob3VyKCkgPCAxMikge1xyXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZS5jbG9uZSgpLmFkZCgxMiwgJ2hvdXInKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgc2VsZWN0YWJsZS5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdmFsaWQuIE90aGVyd2lzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGlzVmFsaWQodmFsdWU6IE1vbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgYmVmb3JlTWluID0gdGhpcy5taW5UaW1lICYmIHZhbHVlLmlzQmVmb3JlKHRoaXMubWluVGltZSk7XHJcbiAgICBjb25zdCBhZnRlck1heCA9IHRoaXMubWF4VGltZSAmJiB2YWx1ZS5pc0FmdGVyKHRoaXMubWF4VGltZSk7XHJcbiAgICByZXR1cm4gIShiZWZvcmVNaW4gfHwgYWZ0ZXJNYXgpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbi8qKiBDb21wb25lbnQgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHRoZSB0aW1lIHNlbGVjdCBwb3B1cC4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdtYXQtdGltZS1zZWxlY3QnLFxyXG4gIHRlbXBsYXRlOiAnJyxcclxuICBleHBvcnRBczogJ21hdFRpbWVTZWxlY3QnLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hdFRpbWVTZWxlY3RDb21wb25lbnQ8RD4gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIENhbkNvbG9yIHtcclxuXHJcbiAgLyoqIFN1YnNjcmlwdGlvbiB0byB2YWx1ZSBjaGFuZ2VzIGluIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuICovXHJcbiAgcHJpdmF0ZSBfaW5wdXRTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XHJcblxyXG4gIHByaXZhdGUgX3N0YXJ0QXQ6IEQgfCBudWxsO1xyXG4gIHByaXZhdGUgX2NvbG9yOiBUaGVtZVBhbGV0dGU7XHJcbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSBfc2VsZWN0ZWQ6IEQ7XHJcbiAgcHJpdmF0ZSBfb3BlbmVkID0gZmFsc2U7XHJcblxyXG4gIHByaXZhdGUgX2Rpc2FibGVkQ2hhbmdlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcclxuICBwcml2YXRlIF9zZWxlY3RlZENoYW5nZTogU3ViamVjdDxEPiA9IG5ldyBTdWJqZWN0PEQ+KCk7XHJcblxyXG4gIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSB3aGVuIHRoZSB0aW1lIHNlbGVjdCBpcyBvcGVuZWQgYXMgYSBwb3B1cC4gKi9cclxuICBwcml2YXRlIF9wb3B1cFJlZjogT3ZlcmxheVJlZjtcclxuICAvKiogQSBwb3J0YWwgY29udGFpbmluZyB0aGUgcG9wdXAgZm9yIHRoaXMgdGltZSBzZWxlY3QuICovXHJcbiAgcHJpdmF0ZSBfcG9wdXBDb21wb25lbnRQb3J0YWw6IENvbXBvbmVudFBvcnRhbDxNYXRUaW1lU2VsZWN0Q29udGVudENvbXBvbmVudDxEPj47XHJcbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgY29tcG9uZW50IGluc3RhbnRpYXRlZCBpbiBwb3B1cCBtb2RlLiAqL1xyXG4gIHByaXZhdGUgX3BvcHVwQ29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8TWF0VGltZVNlbGVjdENvbnRlbnRDb21wb25lbnQ8RD4+O1xyXG4gIC8qKiBUaGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgdGltZSBzZWxlY3Qgd2FzIG9wZW5lZC4gKi9cclxuICBwcml2YXRlIF9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW46IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgX3Njcm9sbFN0cmF0ZWd5OiAoKSA9PiBTY3JvbGxTdHJhdGVneTtcclxuXHJcbiAgLyoqIFRoZSBpbnB1dCBlbGVtZW50IHRoaXMgdGltZSBzZWxlY3QgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xyXG4gIF90aW1lU2VsZWN0SW5wdXQ6IE1hdFRpbWVTZWxlY3RJbnB1dERpcmVjdGl2ZTxEPjtcclxuXHJcbiAgLyoqIEVtaXRzIHdoZW4gdGhlIHRpbWUgc2VsZWN0IGhhcyBiZWVuIG9wZW5lZC4gKi9cclxuICBAT3V0cHV0KCdvcGVuJykgb3BlblN0cmVhbTogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSB0aW1lIHNlbGVjdCBoYXMgYmVlbiBjbG9zZWQuICovXHJcbiAgQE91dHB1dCgnY2xvc2UnKSBjbG9zZVN0cmVhbTogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICAvKiogVGhlIGlkIGZvciB0aGUgdGltZSBzZWxlY3QgcG9wdXAuICovXHJcbiAgaWQgPSBgbWF0LXRpbWUtc2VsZWN0LSR7dGltZVNlbGVjdFVpZCsrfWA7XHJcblxyXG4gIC8qKiBUaGUgaW5pdGlhbCB0aW1lIG9mIHRoZSB0aW1lIHNlbGVjdC4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBzdGFydEF0KCk6IEQgfCBudWxsIHsgcmV0dXJuIHRoaXMuX3N0YXJ0QXQgfHwgKHRoaXMuX3RpbWVTZWxlY3RJbnB1dCA/IHRoaXMuX3RpbWVTZWxlY3RJbnB1dC52YWx1ZSA6IG51bGwpOyB9XHJcbiAgc2V0IHN0YXJ0QXQodmFsdWU6IEQgfCBudWxsKSB7IHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9nZXRWYWxpZERhdGVPck51bGwodGhpcy5fdGltZUFkYXB0ZXIuZGVzZXJpYWxpemUodmFsdWUpKTsgfVxyXG5cclxuICAvKiogVGhlIGNvbG9yIHBhbGV0dGUgdG8gdXNlIG9uIHRoZSB0aW1lIHNlbGVjdCBwb3B1cC4gKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBjb2xvcigpOiBUaGVtZVBhbGV0dGUgeyByZXR1cm4gdGhpcy5fY29sb3IgfHwgKHRoaXMuX3RpbWVTZWxlY3RJbnB1dCA/IHRoaXMuX3RpbWVTZWxlY3RJbnB1dC5nZXRUaGVtZVBhbGV0dGUoKSA6IHVuZGVmaW5lZCk7IH1cclxuICBzZXQgY29sb3IodmFsdWU6IFRoZW1lUGFsZXR0ZSkgeyB0aGlzLl9jb2xvciA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKiBXaGV0aGVyIHRoZSB0aW1lIHNlbGVjdCBwb3AtdXAgc2hvdWxkIGRpc2FibGVkLiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9kaXNhYmxlZCA6ICh0aGlzLl90aW1lU2VsZWN0SW5wdXQgPyB0aGlzLl90aW1lU2VsZWN0SW5wdXQuZGlzYWJsZWQgOiBmYWxzZSk7XHJcbiAgfVxyXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgY29uc3QgZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xyXG4gICAgaWYgKHRoaXMuX2Rpc2FibGVkICE9PSBkaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgICB0aGlzLl9kaXNhYmxlZENoYW5nZS5uZXh0KGRpc2FibGVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHRpbWUuICovXHJcbiAgQElucHV0KClcclxuICBnZXQgc2VsZWN0ZWQoKTogRCB7IHJldHVybiB0aGlzLl9zZWxlY3RlZDsgfVxyXG4gIHNldCBzZWxlY3RlZCh2YWx1ZTogRCkgeyB0aGlzLl9zZWxlY3RlZCA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKiBXaGV0aGVyIHRoZSB0aW1lIHNlbGVjdCBpcyBvcGVuZWQuICovXHJcbiAgQElucHV0KClcclxuICBnZXQgb3BlbmVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fb3BlbmVkOyB9XHJcbiAgc2V0IG9wZW5lZCh2YWx1ZTogYm9vbGVhbikgeyB2YWx1ZSA/IHRoaXMub3BlbigpIDogY2xvc2UoKTsgfVxyXG5cclxuICAvKiogRW1pdHMgd2hlbiB0aGUgdGltZSBzZWxlY3QgZGlzYWJsZWQgc3RhdGUgaGFzIGJlZW4gY2hhbmdlZC4gKi9cclxuICBnZXQgZGlzYWJsZWRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7IHJldHVybiB0aGlzLl9kaXNhYmxlZENoYW5nZS5hc09ic2VydmFibGUoKTsgfVxyXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSB0aW1lIHNlbGVjdCBzZWxlY3RlZCB0aW1lIGhhcyBiZWVuIGNoYW5nZWQuICovXHJcbiAgZ2V0IHNlbGVjdGVkQ2hhbmdlKCk6IE9ic2VydmFibGU8RD4geyByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7IH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcclxuICAgICAgICAgICAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcclxuICAgICAgICAgICAgICBASW5qZWN0KE1BVF9USU1FX1NFTEVDVF9TQ1JPTExfU1RSQVRFR1kpIHNjcm9sbFN0cmF0ZWd5OiBhbnksXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfdGltZUFkYXB0ZXI6IFRpbWVBZGFwdGVyPEQ+LFxyXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHksXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSkge1xyXG4gICAgaWYgKCF0aGlzLl90aW1lQWRhcHRlcikge1xyXG4gICAgICB0aHJvdyBjcmVhdGVNaXNzaW5nVGltZUltcGxFcnJvcignVGltZUFkYXB0ZXInKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IHNjcm9sbFN0cmF0ZWd5O1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5fZGlzYWJsZWRDaGFuZ2UuY29tcGxldGUoKTtcclxuXHJcbiAgICBpZiAodGhpcy5fcG9wdXBSZWYpIHtcclxuICAgICAgdGhpcy5fcG9wdXBSZWYuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9wb3B1cENvbXBvbmVudFJlZiA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3RzIHRoZSBnaXZlbiB0aW1lLlxyXG4gICAqIEBwYXJhbSB0aW1lIFRoZSBkYXRlIHRpbWUgdG8gc2VsZWN0LlxyXG4gICAqL1xyXG4gIHNlbGVjdCh0aW1lOiBEKSB7XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuc2VsZWN0ZWQ7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3RpbWVBZGFwdGVyLmNsb25lKHRpbWUpO1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IHZhbHVlO1xyXG4gICAgaWYgKCF0aGlzLl90aW1lQWRhcHRlci5zYW1lVGltZShvbGRWYWx1ZSwgdmFsdWUpKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGVkQ2hhbmdlLm5leHQodmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgYW4gaW5wdXQgd2l0aCB0aGlzIHRpbWUgc2VsZWN0LlxyXG4gICAqIEBwYXJhbSBpbnB1dCBUaGUgdGltZSBzZWxlY3QgaW5wdXQgdG8gcmVnaXN0ZXIgd2l0aCB0aGlzIHRpbWUgc2VsZWN0LlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVySW5wdXQoaW5wdXQ6IE1hdFRpbWVTZWxlY3RJbnB1dERpcmVjdGl2ZTxEPikge1xyXG4gICAgaWYgKHRoaXMuX3RpbWVTZWxlY3RJbnB1dCkge1xyXG4gICAgICB0aHJvdyBFcnJvcignQSBNYXRUaW1lU2VsZWN0IGNhbiBvbmx5IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3RpbWVTZWxlY3RJbnB1dCA9IGlucHV0O1xyXG4gICAgdGhpcy5faW5wdXRTdWJzY3JpcHRpb24gPSB0aGlzLl90aW1lU2VsZWN0SW5wdXQudmFsdWVDaGFuZ2Uuc3Vic2NyaWJlKCh2YWx1ZTogRCB8IG51bGwpID0+IHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKiogT3BlbiB0aGUgdGltZSBzZWxlY3QuICovXHJcbiAgb3BlbigpIHtcclxuICAgIGlmICh0aGlzLl9vcGVuZWQgfHwgdGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuX3RpbWVTZWxlY3RJbnB1dCkge1xyXG4gICAgICB0aHJvdyBFcnJvcignQXR0ZW1wdGVkIHRvIG9wZW4gYW4gTWF0VGltZVNlbGVjdCB3aXRoIG5vIGFzc29jaWF0ZWQgaW5wdXQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcclxuICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuID0gdGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9vcGVuQXNQb3B1cCgpO1xyXG4gICAgdGhpcy5fb3BlbmVkID0gdHJ1ZTtcclxuICAgIHRoaXMub3BlblN0cmVhbS5lbWl0KCk7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xvc2UgdGhlIHRpbWUgc2VsZWN0LiAqL1xyXG4gIGNsb3NlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX3BvcHVwUmVmICYmIHRoaXMuX3BvcHVwUmVmLmhhc0F0dGFjaGVkKCkpIHtcclxuICAgICAgdGhpcy5fcG9wdXBSZWYuZGV0YWNoKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fcG9wdXBDb21wb25lbnRQb3J0YWwgJiYgdGhpcy5fcG9wdXBDb21wb25lbnRQb3J0YWwuaXNBdHRhY2hlZCkge1xyXG4gICAgICB0aGlzLl9wb3B1cENvbXBvbmVudFBvcnRhbC5kZXRhY2goKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb21wbGV0ZUNsb3NlID0gKCkgPT4ge1xyXG4gICAgICAvLyBUaGUgYF9vcGVuZWRgIGNvdWxkJ3ZlIGJlZW4gcmVzZXQgYWxyZWFkeSBpZlxyXG4gICAgICAvLyB3ZSBnb3QgdHdvIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLlxyXG4gICAgICBpZiAodGhpcy5fb3BlbmVkKSB7XHJcbiAgICAgICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jbG9zZVN0cmVhbS5lbWl0KCk7XHJcbiAgICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5fZm9jdXNlZEVsZW1lbnRCZWZvcmVPcGVuICYmIHR5cGVvZiB0aGlzLl9mb2N1c2VkRWxlbWVudEJlZm9yZU9wZW4uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgLy8gQmVjYXVzZSBJRSBtb3ZlcyBmb2N1cyBhc3luY2hyb25vdXNseSwgd2UgY2FuJ3QgY291bnQgb24gaXQgYmVpbmcgcmVzdG9yZWQgYmVmb3JlIHdlJ3ZlXHJcbiAgICAgIC8vIG1hcmtlZCB0aGUgdGltZSBzZWxlY3QgYXMgY2xvc2VkLiBJZiB0aGUgZXZlbnQgZmlyZXMgb3V0IG9mIHNlcXVlbmNlIGFuZCB0aGUgZWxlbWVudCB0aGF0XHJcbiAgICAgIC8vIHdlJ3JlIHJlZm9jdXNpbmcgb3BlbnMgdGhlIHRpbWUgc2VsZWN0IG9uIGZvY3VzLCB0aGUgdXNlciBjb3VsZCBiZSBzdHVjayB3aXRoIG5vdCBiZWluZ1xyXG4gICAgICAvLyBhYmxlIHRvIGNsb3NlIHRoZSBzZWxlY3QgcGFuZWwgYXQgYWxsLiBXZSB3b3JrIGFyb3VuZCBpdCBieSBtYWtpbmcgdGhlIGxvZ2ljLCB0aGF0IG1hcmtzXHJcbiAgICAgIC8vIHRoZSB0aW1lIHNlbGVjdCBhcyBjbG9zZWQsIGFzeW5jIGFzIHdlbGwuXHJcbiAgICAgIHRoaXMuX2ZvY3VzZWRFbGVtZW50QmVmb3JlT3Blbi5mb2N1cygpO1xyXG4gICAgICBzZXRUaW1lb3V0KGNvbXBsZXRlQ2xvc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29tcGxldGVDbG9zZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIE9wZW4gdGhlIHRpbWUgc2VsZWN0IGFzIGEgcG9wdXAuICovXHJcbiAgcHJpdmF0ZSBfb3BlbkFzUG9wdXAoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9wb3B1cENvbXBvbmVudFBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWw8TWF0VGltZVNlbGVjdENvbnRlbnRDb21wb25lbnQ8RD4+KFxyXG4gICAgICBNYXRUaW1lU2VsZWN0Q29udGVudENvbXBvbmVudCxcclxuICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZixcclxuICAgICAgdGhpcy5fY3JlYXRlSW5qZWN0b3IoKVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3BvcHVwUmVmKSB7XHJcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9wb3B1cFJlZi5oYXNBdHRhY2hlZCgpKSB7XHJcbiAgICAgIHRoaXMuX3BvcHVwQ29tcG9uZW50UmVmID0gdGhpcy5fcG9wdXBSZWYuYXR0YWNoKHRoaXMuX3BvcHVwQ29tcG9uZW50UG9ydGFsKTtcclxuICAgICAgdGhpcy5fcG9wdXBDb21wb25lbnRSZWYuaW5zdGFuY2UudmFsdWVDaGFuZ2Uuc3Vic2NyaWJlKFxyXG4gICAgICAgICh2YWx1ZTogTW9tZW50KSA9PiB0aGlzLnNlbGVjdCh0aGlzLl90aW1lQWRhcHRlci5kZXNlcmlhbGl6ZSh2YWx1ZS50b0lTT1N0cmluZygpKSlcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5fc2V0Q29sb3IoKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb25jZSB0aGUgc2VsZWN0IHBhbmVsIGhhcyByZW5kZXJlZC5cclxuICAgICAgdGhpcy5fbmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICB0aGlzLl9wb3B1cFJlZi51cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBDcmVhdGUgYSBwb3J0YWwgaW5qZWN0b3IgdG8gaW5qZWN0IHRpbWUgc2VsZWN0IGluaXRpYWwgZGF0YS4gKi9cclxuICBwcml2YXRlIF9jcmVhdGVJbmplY3RvcigpOiBQb3J0YWxJbmplY3RvciB7XHJcbiAgICBjb25zdCBkYXRhOiBNYXRUaW1lU2VsZWN0RGF0YTxEPiA9IHtcclxuICAgICAgdmFsdWU6IHRoaXMuc3RhcnRBdCxcclxuICAgICAgbWluVGltZTogdGhpcy5fdGltZVNlbGVjdElucHV0ICYmIHRoaXMuX3RpbWVTZWxlY3RJbnB1dC5taW4sXHJcbiAgICAgIG1heFRpbWU6IHRoaXMuX3RpbWVTZWxlY3RJbnB1dCAmJiB0aGlzLl90aW1lU2VsZWN0SW5wdXQubWF4XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW5qZWN0b3JUb2tlbnMgPSBuZXcgV2Vha01hcDxhbnksIGFueT4oW1xyXG4gICAgICBbTUFUX1RJTUVfU0VMRUNUX0RBVEEsIGRhdGFdXHJcbiAgICBdKTtcclxuICAgIHJldHVybiBuZXcgUG9ydGFsSW5qZWN0b3IodGhpcy5faW5qZWN0b3IsIGluamVjdG9yVG9rZW5zKTtcclxuICB9XHJcblxyXG4gIC8qKiBDcmVhdGUgdGhlIHBvcHVwLiAqL1xyXG4gIHByaXZhdGUgX2NyZWF0ZVBvcHVwKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgb3ZlcmxheUNvbmZpZyA9IG5ldyBPdmVybGF5Q29uZmlnKHtcclxuICAgICAgcG9zaXRpb25TdHJhdGVneTogdGhpcy5fY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5KCksXHJcbiAgICAgIGhhc0JhY2tkcm9wOiB0cnVlLFxyXG4gICAgICBiYWNrZHJvcENsYXNzOiAnbWF0LW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnLFxyXG4gICAgICBkaXJlY3Rpb246IHRoaXMuX2RpcixcclxuICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX3Njcm9sbFN0cmF0ZWd5KCksXHJcbiAgICAgIHBhbmVsQ2xhc3M6ICdtYXQtdGltZS1zZWxlY3QtcG9wdXAnLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fcG9wdXBSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShvdmVybGF5Q29uZmlnKTtcclxuICAgIHRoaXMuX3BvcHVwUmVmLm92ZXJsYXlFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcclxuXHJcbiAgICBtZXJnZShcclxuICAgICAgdGhpcy5fcG9wdXBSZWYuYmFja2Ryb3BDbGljaygpLFxyXG4gICAgICB0aGlzLl9wb3B1cFJlZi5kZXRhY2htZW50cygpLFxyXG4gICAgICB0aGlzLl9wb3B1cFJlZi5rZXlkb3duRXZlbnRzKCkucGlwZShmaWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgIC8vIENsb3Npbmcgb24gYWx0ICsgdXAgaXMgb25seSB2YWxpZCB3aGVuIHRoZXJlJ3MgYW4gaW5wdXQgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aW1lIHNlbGVjdC5cclxuICAgICAgICByZXR1cm4gZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFIHx8XHJcbiAgICAgICAgICAodGhpcy5fdGltZVNlbGVjdElucHV0ICYmIGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSBVUF9BUlJPVyk7XHJcbiAgICAgIH0pKVxyXG4gICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKiBDcmVhdGUgdGhlIHBvcHVwIHBvc2l0aW9uIHN0cmF0ZWd5LiAqL1xyXG4gIHByaXZhdGUgX2NyZWF0ZVBvcHVwUG9zaXRpb25TdHJhdGVneSgpOiBQb3NpdGlvblN0cmF0ZWd5IHtcclxuICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcclxuICAgICAgLmZsZXhpYmxlQ29ubmVjdGVkVG8odGhpcy5fdGltZVNlbGVjdElucHV0LmdldENvbm5lY3RlZE92ZXJsYXlPcmlnaW4oKSlcclxuICAgICAgLndpdGhUcmFuc2Zvcm1PcmlnaW5PbignLm1hdC10aW1lLXNlbGVjdC1jb250ZW50JylcclxuICAgICAgLndpdGhGbGV4aWJsZURpbWVuc2lvbnMoZmFsc2UpXHJcbiAgICAgIC53aXRoVmlld3BvcnRNYXJnaW4oOClcclxuICAgICAgLndpdGhMb2NrZWRQb3NpdGlvbigpXHJcbiAgICAgIC53aXRoUG9zaXRpb25zKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxyXG4gICAgICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXHJcbiAgICAgICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcclxuICAgICAgICAgIG92ZXJsYXlZOiAndG9wJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgb3JpZ2luWDogJ3N0YXJ0JyxcclxuICAgICAgICAgIG9yaWdpblk6ICd0b3AnLFxyXG4gICAgICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXHJcbiAgICAgICAgICBvdmVybGF5WTogJ2JvdHRvbSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG9yaWdpblg6ICdlbmQnLFxyXG4gICAgICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXHJcbiAgICAgICAgICBvdmVybGF5WDogJ2VuZCcsXHJcbiAgICAgICAgICBvdmVybGF5WTogJ3RvcCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG9yaWdpblg6ICdlbmQnLFxyXG4gICAgICAgICAgb3JpZ2luWTogJ3RvcCcsXHJcbiAgICAgICAgICBvdmVybGF5WDogJ2VuZCcsXHJcbiAgICAgICAgICBvdmVybGF5WTogJ2JvdHRvbSdcclxuICAgICAgICB9XHJcbiAgICAgIF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIFRoZSBnaXZlbiBvYmplY3QgaWYgaXQgaXMgYm90aCBhIGRhdGUgaW5zdGFuY2UgYW5kIHZhbGlkLCBvdGhlcndpc2UgbnVsbC5cclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRWYWxpZERhdGVPck51bGwob2JqOiBhbnkpOiBEIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5fdGltZUFkYXB0ZXIuaXNEYXRlSW5zdGFuY2Uob2JqKSAmJiB0aGlzLl90aW1lQWRhcHRlci5pc1ZhbGlkKG9iaikgPyBvYmogOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqIFBhc3NlcyB0aGUgY3VycmVudCB0aGVtZSBjb2xvciBhbG9uZyB0byB0aGUgdGltZSBzZWxlY3Qgb3ZlcmxheS4gKi9cclxuICBwcml2YXRlIF9zZXRDb2xvcigpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9wb3B1cENvbXBvbmVudFJlZikge1xyXG4gICAgICB0aGlzLl9wb3B1cENvbXBvbmVudFJlZi5pbnN0YW5jZS5jb2xvciA9IHRoaXMuY29sb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=