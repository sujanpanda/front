import { Directionality } from '@angular/cdk/bidi';
import { filter, take } from 'rxjs/operators';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { ESCAPE, UP_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Subject, merge, Subscription, of } from 'rxjs';
import { DOCUMENT, CommonModule } from '@angular/common';
import { A11yModule } from '@angular/cdk/a11y';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector, PortalModule } from '@angular/cdk/portal';
import * as _moment from 'moment';
import { InjectionToken, Injectable, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Inject, Input, Output, ViewChild, ViewEncapsulation, forwardRef, HostBinding, HostListener, Injector, NgZone, Optional, ViewChildren, ViewContainerRef, Directive, Attribute, ContentChild, NgModule } from '@angular/core';
import { DateAdapter, mixinDisableRipple, mixinColor, MAT_INPUT_VALUE_ACCESSOR, MatFormField, MatButtonModule, MatButtonToggleModule, MatIconModule, MatRippleModule, MAT_DATE_LOCALE } from '@angular/material';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Adapts date object to be usable as a date time by cdk-based components that work with dates.
 * @abstract
 * @template D
 */
class TimeAdapter extends DateAdapter {
    /**
     * Compares two date times.
     * @param {?} first The first date to compare.
     * @param {?} second The second date to compare.
     * @return {?} 0 if the date times are equal, a number less than 0 if the first date time is earlier,
     *     a number greater than 0 if the first date time is later.
     */
    compareTime(first, second) {
        return this.compareDate(first, second) ||
            this.getHour(first) - this.getHour(second) ||
            this.getMinute(first) - this.getMinute(second) ||
            this.getSecond(first) - this.getSecond(second);
    }
    /**
     * Checks if two date times are equal.
     * @param {?} first The first date to check.
     * @param {?} second The second date to check.
     * @return {?} Whether the two date times are equal.
     *     Null dates are considered equal to other null dates.
     */
    sameTime(first, second) {
        if (first && second) {
            /** @type {?} */
            const firstValid = this.isValid(first);
            /** @type {?} */
            const secondValid = this.isValid(second);
            if (firstValid && secondValid) {
                return !this.compareTime(first, second);
            }
            return firstValid === secondValid;
        }
        return first === second;
    }
    /**
     * Clamp the given date between min and max date times.
     * @param {?} date The date to clamp.
     * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
     * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
     * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
     *     otherwise `date`.
     */
    clampTime(date, min, max) {
        if (min && this.compareTime(date, min) < 0) {
            return min;
        }
        if (max && this.compareTime(date, max) > 0) {
            return max;
        }
        return date;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAT_TIME_FORMATS = new InjectionToken('mat-time-formats');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TimeSelect data that requires internationalization.
 */
class MatTimeSelectIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /**
         * A label for the button used to open the time select popup (used by screen readers).
         */
        this.openTimeSelectLabel = 'Open time select';
        /**
         * A label for the a.m. button toggle (used by screen readers).
         */
        this.amLabel = 'AM';
        /**
         * A label for the p.m. button toggle (used by screen readers).
         */
        this.pmLabel = 'PM';
    }
}
MatTimeSelectIntl.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Component used to select a value of a unit of time.
 * @template D
 */
class MatTimeUnitSelectComponent {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _timeAdapter
     * @param {?} _timeFormats
     */
    constructor(_changeDetectorRef, _timeAdapter, _timeFormats) {
        this._changeDetectorRef = _changeDetectorRef;
        this._timeAdapter = _timeAdapter;
        this._timeFormats = _timeFormats;
        /**
         * The list of all values of the time select.
         */
        this.options = [];
        /**
         * Emits when selected value has been changed. Output to enable support for two-way binding on `[(value)]`.
         */
        this.valueChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const unit = this.unit;
        /** @type {?} */
        const time = this._timeAdapter.createTime();
        /** @type {?} */
        const moment = this._timeAdapter.toMoment(time);
        /** @type {?} */
        const start = moment.clone().startOf('day');
        /** @type {?} */
        const end = moment.clone().endOf('day');
        /** @type {?} */
        const min = start.get(unit);
        /** @type {?} */
        const max = end.get(unit);
        /** @type {?} */
        const localeData = moment.localeData();
        /** @type {?} */
        const displayFormat = localeData.longDateFormat('LTS');
        /** @type {?} */
        const unitFormat = unit === 'hour' ?
            displayFormat.match(/hh?|HH?/g)[0] : unit === 'minute' ?
            displayFormat.match(/mm?/g)[0] : displayFormat.match(/ss?/g)[0];
        moment.set(unit, this.value);
        moment.subtract((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        for (let value = min; value <= max; value++) {
            moment.add((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
            this.options.push({ value: moment.get(unit), label: moment.format(unitFormat) });
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const element = this.panel.nativeElement;
        this._originTop = parseFloat(getComputedStyle(element).top);
        element.addEventListener('transitionend', () => {
            element.style.removeProperty('transition');
        });
        setTimeout(() => this.move(this.options.length / 2));
    }
    /**
     * Select the previous option.
     * @return {?}
     */
    prev() {
        this.move(-1);
    }
    /**
     * Select the next option.
     * @return {?}
     */
    next() {
        this.move(+1);
    }
    /**
     * Select the option moving by the given amount of step.
     * @param {?} step The amount of step to move.
     * @return {?}
     */
    move(step) {
        /** @type {?} */
        const element = this.panel.nativeElement;
        /** @type {?} */
        const option = element.querySelector('mat-time-unit-option');
        /** @type {?} */
        const optionHeight = parseFloat(getComputedStyle(option).height);
        /** @type {?} */
        const currentTop = parseFloat(getComputedStyle(element).top);
        /** @type {?} */
        const targetTop = currentTop + (step * optionHeight);
        /** @type {?} */
        const y = this._originTop - targetTop;
        element.style.top = `${targetTop}px`;
        if (step < 0) {
            // Move last option to the top
            for (let i = 0; i > step; i--) {
                this.options.unshift(this.options.pop());
            }
        }
        else if (step > 0) {
            // Move first option to the bottom
            for (let i = 0; i < step; i++) {
                this.options.push(this.options.shift());
            }
        }
        this.value = this.options[(this.options.length / 2)].value;
        this.valueChange.emit(this.value);
        element.style.transition = 'transform 0.5s';
        element.style.transform = `translateY(${y}px)`;
    }
    /**
     * Gets the previous option value.
     * @return {?}
     */
    getPrev() {
        return this.options[(this.options.length / 2) - 1].value;
    }
    /**
     * Gets the next option value.
     * @return {?}
     */
    getNext() {
        return this.options[(this.options.length / 2) + 1].value;
    }
    /**
     * Whether the given value is valid.
     * @param {?} value The value to check.
     * @return {?}
     */
    isValid(value) {
        return (this.min === null || value >= this.min) && (this.max === null || value <= this.max);
    }
}
MatTimeUnitSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-unit-select',
                template: "<div class=\"mat-time-unit-select-carousel\">\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-prev\" mat-icon-button aria-label=\"Previous\" [disabled]=\"!isValid(getPrev())\" (click)=\"prev()\">\r\n    <mat-icon>keyboard_arrow_up</mat-icon>\r\n  </button>\r\n  <div class=\"mat-time-unit-select-mask\">\r\n    <div #panel class=\"mat-time-unit-select-panel\">\r\n      <mat-time-unit-option *ngFor=\"let option of options\" [value]=\"option.value\" [disabled]=\"!isValid(option.value)\"> {{ option.label }} </mat-time-unit-option>\r\n    </div>\r\n  </div>\r\n  <button class=\"mat-time-unit-select-arrow mat-time-unit-select-next\" mat-icon-button aria-label=\"Next\" [disabled]=\"!isValid(getNext())\" (click)=\"next()\">\r\n    <mat-icon>keyboard_arrow_down</mat-icon>\r\n  </button>\r\n</div>\r\n",
                exportAs: 'matTimeSelect',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["mat-time-unit-select{display:block;height:100%}mat-time-unit-select .mat-time-unit-select-carousel{display:flex;flex-direction:column;align-items:center;height:100%}mat-time-unit-select .mat-time-unit-select-mask{flex:auto;max-height:120px;width:100%;overflow:hidden}"]
            }] }
];
/** @nocollapse */
MatTimeUnitSelectComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: TimeAdapter },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_TIME_FORMATS,] }] }
];
MatTimeUnitSelectComponent.propDecorators = {
    value: [{ type: Input }],
    unit: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    valueChange: [{ type: Output }],
    panel: [{ type: ViewChild, args: ['panel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatTimeUnitOptionBase {
}
/** @type {?} */
const _MatTimeUnitOptionMixinBase = mixinDisableRipple(MatTimeUnitOptionBase);
/**
 * Single time option inside a `<mat-time-unit-select>` element
 * @template D
 */
class MatTimeUnitOptionComponent extends _MatTimeUnitOptionMixinBase {
    /**
     * @param {?} _elementRef
     * @param {?} _changeDetectorRef
     * @param {?} timeUnitSelect
     */
    constructor(_elementRef, _changeDetectorRef, timeUnitSelect) {
        super();
        this._elementRef = _elementRef;
        this._changeDetectorRef = _changeDetectorRef;
        this.timeUnitSelect = timeUnitSelect;
        this._disabled = false;
        this._selected = false;
        /**
         * \@docs-private
         */
        this.class = 'mat-time-unit-option';
        /**
         * \@docs-private
         */
        this.role = 'option';
        /**
         * \@docs-private
         */
        this.tabindex = -1;
    }
    /**
     * Whether or not the option is currently selected.
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        /** @type {?} */
        const selected = coerceBooleanProperty(value);
        if (this._selected !== selected) {
            this._selected = selected;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * Whether the option is disabled.
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const disabled = coerceBooleanProperty(value);
        if (this._disabled !== disabled) {
            this._disabled = disabled;
            this._changeDetectorRef.markForCheck();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get ariaDisabled() { return this.disabled.toString(); }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.timeUnitSelect.valueChange.subscribe(value => this.selected = this.value === value);
    }
    /**
     * Gets the label to be used when determining whether the option should be focused.
     * @return {?}
     */
    getLabel() {
        return this._text ? (this._text.nativeElement.textContent || '').trim() : '';
    }
    /**
     * Gets the host DOM element.
     * @return {?}
     */
    _getHostElement() {
        return this._elementRef.nativeElement;
    }
    /**
     * Whether ripples for the option are disabled.
     * @return {?}
     */
    _isRippleDisabled() {
        return this.disabled || this.disableRipple;
    }
    /**
     * Handle click on the option.
     * @return {?}
     */
    _onClick() {
        if (!this.disabled) {
            this.timeUnitSelect.move(this.value - this.timeUnitSelect.value);
        }
    }
}
MatTimeUnitOptionComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-unit-option',
                template: "<div class=\"mat-time-unit-option-content\">\r\n  <div mat-ripple\r\n       class=\"mat-time-unit-option-ripple\"\r\n       [matRippleTrigger]=\"_getHostElement()\"\r\n       [matRippleDisabled]=\"_isRippleDisabled()\"></div>\r\n  <div #text class=\"mat-time-unit-option-text\">\r\n    <ng-content></ng-content>\r\n  </div>\r\n</div>\r\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".mat-time-unit-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;-webkit-transform:scale(1,1);transform:scale(1,1);transition:transform .5s;transition:transform .5s,-webkit-transform .5s}.mat-time-unit-option .mat-time-unit-option-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-time-unit-option .mat-time-unit-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-time-unit-option .mat-time-unit-option-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0;text-align:center}.mat-time-unit-option .mat-time-unit-option-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-time-unit-option .mat-time-unit-option-text:empty{display:none}.mat-time-unit-option:not(.mat-time-unit-option-disabled){cursor:pointer;outline:0}.mat-time-unit-option.mat-time-unit-option-selected:not(.mat-time-unit-option-disabled),.mat-time-unit-separator{-webkit-transform:scale(1.5,1.5);transform:scale(1.5,1.5)}"]
            }] }
];
/** @nocollapse */
MatTimeUnitOptionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: MatTimeUnitSelectComponent, decorators: [{ type: Inject, args: [forwardRef(() => MatTimeUnitSelectComponent),] }] }
];
MatTimeUnitOptionComponent.propDecorators = {
    value: [{ type: Input }],
    disableRipple: [{ type: Input }],
    _text: [{ type: ViewChild, args: ['text',] }],
    class: [{ type: HostBinding, args: ['class',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    selected: [{ type: Input }, { type: HostBinding, args: ['class.mat-time-unit-option-selected',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.mat-time-unit-option-disabled',] }],
    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    _onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@docs-private
 * @param {?} provider
 * @return {?}
 */
function createMissingTimeImplError(provider) {
    return Error(`MatTimeSelectComponent: No provider found for ${provider}. You must import one of the following ` +
        `modules at your application root: MatNativeTimeModule, MatMomentTimeModule, or provide a ` +
        `custom implementation.`);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Used to generate a unique ID for each time select instance.
 * @type {?}
 */
let timeSelectUid = 0;
/**
 * Injection token used to initialize the time select data.
 * @type {?}
 */
const MAT_TIME_SELECT_DATA = new InjectionToken('mat-time-select-data');
/**
 * Injection token that determines the scroll handling while the time select is opened.
 * @type {?}
 */
const MAT_TIME_SELECT_SCROLL_STRATEGY = new InjectionToken('mat-time-select-scroll-strategy');
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
function MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/**
 * \@docs-private
 * @type {?}
 */
const MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER = {
    provide: MAT_TIME_SELECT_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY
};
/**
 * \@docs-private
 */
class MatTimeSelectContentBase {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
/** @type {?} */
const _MatTimeSelectContentMixinBase = mixinColor(MatTimeSelectContentBase);
/**
 * Component used as the content for the time select popup.
 * \@docs-private
 * @template D
 */
class MatTimeSelectContentComponent extends _MatTimeSelectContentMixinBase {
    /**
     * @param {?} elementRef
     * @param {?} _intl
     * @param {?} _timeAdapter
     * @param {?} data
     */
    constructor(elementRef, _intl, _timeAdapter, data) {
        super(elementRef);
        this._intl = _intl;
        this._timeAdapter = _timeAdapter;
        /**
         * Emits when the time select content selected time has been changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * \@docs-private
         */
        this.class = 'mat-time-select-content';
        if (!this._timeAdapter) {
            throw createMissingTimeImplError('TimeAdapter');
        }
        /** @type {?} */
        const time = this._timeAdapter.isDateInstance(data.value) && this._timeAdapter.isValid(data.value) ?
            this._timeAdapter.clone(data.value) : this._timeAdapter.now();
        /** @type {?} */
        const value = this._timeAdapter.toMoment(this._timeAdapter.clampTime(time, data.minTime, data.maxTime));
        /** @type {?} */
        const localeData = value.localeData();
        /** @type {?} */
        const displayFormat = localeData.longDateFormat('LTS');
        this.hourClock = /hh?/g.test(displayFormat) ? 12 : 24;
        this.value = value;
        this.units = data.units || ['hour', 'minute'];
        this.minTime = data.minTime ? this._timeAdapter.toMoment(data.minTime) : null;
        this.maxTime = data.maxTime ? this._timeAdapter.toMoment(data.maxTime) : null;
    }
    /**
     * The time period of the currently selected time of the time select content. Possible values: `am` when selected time hour is less
     * than 12; `pm` when selected time hour is greater than or equal to 12.
     * @return {?}
     */
    get amPm() { return this.value ? (this.value.hour() < 12 ? 'am' : 'pm') : null; }
    /**
     * @param {?} value
     * @return {?}
     */
    set amPm(value) {
        if (this.timeUnitSelectComponents) {
            this.timeUnitSelectComponents.toArray()
                .filter(timeSelect => timeSelect.unit === 'hour')
                .forEach(timeSelect => timeSelect.move(value === 'am' ? -12 : 12));
        }
    }
    /**
     * Gets the value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The retrieved value.
     */
    get(unit) {
        return this.value.get(unit);
    }
    /**
     * Sets the value of the given unit of time.
     * @param {?} unit The unit of time to update.
     * @param {?} value The value to set.
     * @return {?}
     */
    set(unit, value) {
        this.value.set(unit, value);
        this.valueChange.emit(this.value);
    }
    /**
     * Gets the minimum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The minimum value.
     */
    getMin(unit) {
        /** @type {?} */
        let min = null;
        if (this.minTime && this.value.isSame(this.minTime, 'day')) {
            if (this.getPrev(unit).isBefore(this.minTime)) {
                min = this.value.get(unit);
            }
            if (this.getNext(unit).isBefore(this.minTime)) {
                min = this.minTime.get(unit);
            }
        }
        return min;
    }
    /**
     * Gets the maximum allowed value of the given unit of time.
     * @param {?} unit The unit of time to query.
     * @return {?} The maximum value.
     */
    getMax(unit) {
        /** @type {?} */
        let max = null;
        if (this.maxTime && this.value.isSame(this.maxTime, 'day')) {
            if (this.getNext(unit).isAfter(this.maxTime)) {
                max = this.value.get(unit);
            }
            if (this.getPrev(unit).isAfter(this.maxTime)) {
                max = this.maxTime.get(unit);
            }
        }
        return max;
    }
    /**
     * Gets the value after moving up the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    getPrev(unit) {
        /** @type {?} */
        const prev = this.value.clone().subtract((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        return this.value.clone().set(unit, prev.get(unit));
    }
    /**
     * Gets the value after moving down the given unit of time.
     * @param {?} unit The unit of time to move.
     * @return {?} The new value.
     */
    getNext(unit) {
        /** @type {?} */
        const next = this.value.clone().add((/** @type {?} */ (1)), (/** @type {?} */ (unit)));
        return this.value.clone().set(unit, next.get(unit));
    }
    /**
     * Gets the value before midday.
     * @return {?}
     */
    getAM() {
        if (this.value.hour() >= 12) {
            return this.value.clone().subtract(12, 'hour');
        }
        return this.value;
    }
    /**
     * Gets the value after midday.
     * @return {?}
     */
    getPM() {
        if (this.value.hour() < 12) {
            return this.value.clone().add(12, 'hour');
        }
        return this.value;
    }
    /**
     * Whether the given value is selectable.
     * @param {?} value The value to check.
     * @return {?} `true` if the value is valid. Otherwise `false`.
     */
    isValid(value) {
        /** @type {?} */
        const beforeMin = this.minTime && value.isBefore(this.minTime);
        /** @type {?} */
        const afterMax = this.maxTime && value.isAfter(this.maxTime);
        return !(beforeMin || afterMax);
    }
}
MatTimeSelectContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-select-content',
                template: "<table class=\"mat-time-select-table mat-{{ color }}\">\r\n  <tr>\r\n    <ng-container *ngFor=\"let unit of units; first as first\">\r\n      <td *ngIf=\"!first\" class=\"mat-time-select-column mat-time-select-separator\">\r\n        <div class=\"mat-time-unit-separator\">\r\n          <span class=\"mat-time-unit-separator-text\">:</span>\r\n        </div>\r\n      </td>\r\n      <td class=\"mat-time-select-column mat-time-select-{{ unit }}\">\r\n        <mat-time-unit-select\r\n          [min]=\"getMin(unit)\"\r\n          [max]=\"getMax(unit)\"\r\n          [unit]=\"unit\"\r\n          [value]=\"get(unit)\"\r\n          (valueChange)=\"set(unit, $event)\">\r\n        </mat-time-unit-select>\r\n      </td>\r\n    </ng-container>\r\n  </tr>\r\n  <tr *ngIf=\"hourClock === 12\">\r\n    <td class=\"mat-time-ampm\" [colSpan]=\"(units.length * 2) - 1\">\r\n      <mat-button-toggle-group [value]=\"amPm\" (change)=\"amPm = $event.value\">\r\n        <mat-button-toggle value=\"am\" [disabled]=\"!isValid(getAM())\">{{ _intl.amLabel }}</mat-button-toggle>\r\n        <mat-button-toggle value=\"pm\" [disabled]=\"!isValid(getPM())\">{{ _intl.pmLabel }}</mat-button-toggle>\r\n      </mat-button-toggle-group>\r\n    </td>\r\n  </tr>\r\n</table>\r\n",
                exportAs: 'matTimeSelectContent',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".mat-time-select-content{display:block;border-radius:4px}.mat-time-select-content .mat-time-select-table{border-collapse:collapse}.mat-time-select-content .mat-time-select-column{width:80px;padding:0}.mat-time-select-content .mat-time-select-column .mat-time-unit-select-panel{position:relative}.mat-time-select-content .mat-time-select-hour .mat-time-unit-select-panel{top:-440px}.mat-time-select-content .mat-time-select-minute .mat-time-unit-select-panel,.mat-time-select-content .mat-time-select-second .mat-time-unit-select-panel{top:-1160px}.mat-time-select-content .mat-time-select-separator{text-align:center}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;height:40px;width:100%}.mat-time-select-content .mat-time-select-separator .mat-time-unit-separator-text{width:100%}.mat-time-select-content .mat-time-ampm{text-align:center}"]
            }] }
];
/** @nocollapse */
MatTimeSelectContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MatTimeSelectIntl },
    { type: TimeAdapter, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TIME_SELECT_DATA,] }] }
];
MatTimeSelectContentComponent.propDecorators = {
    color: [{ type: Input }],
    units: [{ type: Input }],
    value: [{ type: Input }],
    minTime: [{ type: Input }],
    maxTime: [{ type: Input }],
    valueChange: [{ type: Output }],
    timeUnitSelectComponents: [{ type: ViewChildren, args: [MatTimeUnitSelectComponent,] }],
    class: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Component responsible for managing the time select popup.
 * @template D
 */
class MatTimeSelectComponent {
    /**
     * @param {?} _overlay
     * @param {?} _injector
     * @param {?} _ngZone
     * @param {?} _viewContainerRef
     * @param {?} scrollStrategy
     * @param {?} _timeAdapter
     * @param {?} _dir
     * @param {?} _document
     */
    constructor(_overlay, _injector, _ngZone, _viewContainerRef, scrollStrategy, _timeAdapter, _dir, _document) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._viewContainerRef = _viewContainerRef;
        this._timeAdapter = _timeAdapter;
        this._dir = _dir;
        this._document = _document;
        /**
         * Subscription to value changes in the associated input element.
         */
        this._inputSubscription = Subscription.EMPTY;
        this._opened = false;
        this._disabledChange = new Subject();
        this._selectedChange = new Subject();
        /**
         * The element that was focused before the time select was opened.
         */
        this._focusedElementBeforeOpen = null;
        /**
         * Emits when the time select has been opened.
         */
        this.openStream = new EventEmitter();
        /**
         * Emits when the time select has been closed.
         */
        this.closeStream = new EventEmitter();
        /**
         * The id for the time select popup.
         */
        this.id = `mat-time-select-${timeSelectUid++}`;
        if (!this._timeAdapter) {
            throw createMissingTimeImplError('TimeAdapter');
        }
        this._scrollStrategy = scrollStrategy;
    }
    /**
     * The initial time of the time select.
     * @return {?}
     */
    get startAt() { return this._startAt || (this._timeSelectInput ? this._timeSelectInput.value : null); }
    /**
     * @param {?} value
     * @return {?}
     */
    set startAt(value) { this._startAt = this._getValidDateOrNull(this._timeAdapter.deserialize(value)); }
    /**
     * The color palette to use on the time select popup.
     * @return {?}
     */
    get color() { return this._color || (this._timeSelectInput ? this._timeSelectInput.getThemePalette() : undefined); }
    /**
     * @param {?} value
     * @return {?}
     */
    set color(value) { this._color = value; }
    /**
     * Whether the time select pop-up should disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled !== undefined ? this._disabled : (this._timeSelectInput ? this._timeSelectInput.disabled : false);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const disabled = coerceBooleanProperty(value);
        if (this._disabled !== disabled) {
            this._disabled = disabled;
            this._disabledChange.next(disabled);
        }
    }
    /**
     * The currently selected time.
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) { this._selected = value; }
    /**
     * Whether the time select is opened.
     * @return {?}
     */
    get opened() { return this._opened; }
    /**
     * @param {?} value
     * @return {?}
     */
    set opened(value) { value ? this.open() : close(); }
    /**
     * Emits when the time select disabled state has been changed.
     * @return {?}
     */
    get disabledChange() { return this._disabledChange.asObservable(); }
    /**
     * Emits when the time select selected time has been changed.
     * @return {?}
     */
    get selectedChange() { return this._selectedChange.asObservable(); }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.close();
        this._inputSubscription.unsubscribe();
        this._disabledChange.complete();
        if (this._popupRef) {
            this._popupRef.dispose();
            this._popupComponentRef = null;
        }
    }
    /**
     * Selects the given time.
     * @param {?} time The date time to select.
     * @return {?}
     */
    select(time) {
        /** @type {?} */
        const oldValue = this.selected;
        /** @type {?} */
        const value = this._timeAdapter.clone(time);
        this.selected = value;
        if (!this._timeAdapter.sameTime(oldValue, value)) {
            this._selectedChange.next(value);
        }
    }
    /**
     * Register an input with this time select.
     * @param {?} input The time select input to register with this time select.
     * @return {?}
     */
    registerInput(input) {
        if (this._timeSelectInput) {
            throw Error('A MatTimeSelect can only be associated with a single input.');
        }
        this._timeSelectInput = input;
        this._inputSubscription = this._timeSelectInput.valueChange.subscribe((value) => this.selected = value);
    }
    /**
     * Open the time select.
     * @return {?}
     */
    open() {
        if (this._opened || this.disabled) {
            return;
        }
        if (!this._timeSelectInput) {
            throw Error('Attempted to open an MatTimeSelect with no associated input.');
        }
        if (this._document) {
            this._focusedElementBeforeOpen = this._document.activeElement;
        }
        this._openAsPopup();
        this._opened = true;
        this.openStream.emit();
    }
    /**
     * Close the time select.
     * @return {?}
     */
    close() {
        if (!this._opened) {
            return;
        }
        if (this._popupRef && this._popupRef.hasAttached()) {
            this._popupRef.detach();
        }
        if (this._popupComponentPortal && this._popupComponentPortal.isAttached) {
            this._popupComponentPortal.detach();
        }
        /** @type {?} */
        const completeClose = () => {
            // The `_opened` could've been reset already if
            // we got two events in quick succession.
            if (this._opened) {
                this._opened = false;
                this.closeStream.emit();
                this._focusedElementBeforeOpen = null;
            }
        };
        if (this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function') {
            // Because IE moves focus asynchronously, we can't count on it being restored before we've
            // marked the time select as closed. If the event fires out of sequence and the element that
            // we're refocusing opens the time select on focus, the user could be stuck with not being
            // able to close the select panel at all. We work around it by making the logic, that marks
            // the time select as closed, async as well.
            this._focusedElementBeforeOpen.focus();
            setTimeout(completeClose);
        }
        else {
            completeClose();
        }
    }
    /**
     * Open the time select as a popup.
     * @private
     * @return {?}
     */
    _openAsPopup() {
        this._popupComponentPortal = new ComponentPortal(MatTimeSelectContentComponent, this._viewContainerRef, this._createInjector());
        if (!this._popupRef) {
            this._createPopup();
        }
        if (!this._popupRef.hasAttached()) {
            this._popupComponentRef = this._popupRef.attach(this._popupComponentPortal);
            this._popupComponentRef.instance.valueChange.subscribe((value) => this.select(this._timeAdapter.deserialize(value.toISOString())));
            this._setColor();
            // Update the position once the select panel has rendered.
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
                this._popupRef.updatePosition();
            });
        }
    }
    /**
     * Create a portal injector to inject time select initial data.
     * @private
     * @return {?}
     */
    _createInjector() {
        /** @type {?} */
        const data = {
            value: this.startAt,
            minTime: this._timeSelectInput && this._timeSelectInput.min,
            maxTime: this._timeSelectInput && this._timeSelectInput.max
        };
        /** @type {?} */
        const injectorTokens = new WeakMap([
            [MAT_TIME_SELECT_DATA, data]
        ]);
        return new PortalInjector(this._injector, injectorTokens);
    }
    /**
     * Create the popup.
     * @private
     * @return {?}
     */
    _createPopup() {
        /** @type {?} */
        const overlayConfig = new OverlayConfig({
            positionStrategy: this._createPopupPositionStrategy(),
            hasBackdrop: true,
            backdropClass: 'mat-overlay-transparent-backdrop',
            direction: this._dir,
            scrollStrategy: this._scrollStrategy(),
            panelClass: 'mat-time-select-popup',
        });
        this._popupRef = this._overlay.create(overlayConfig);
        this._popupRef.overlayElement.setAttribute('role', 'dialog');
        merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(event => {
            // Closing on alt + up is only valid when there's an input associated with the time select.
            return event.keyCode === ESCAPE ||
                (this._timeSelectInput && event.altKey && event.keyCode === UP_ARROW);
        }))).subscribe(() => this.close());
    }
    /**
     * Create the popup position strategy.
     * @private
     * @return {?}
     */
    _createPopupPositionStrategy() {
        return this._overlay.position()
            .flexibleConnectedTo(this._timeSelectInput.getConnectedOverlayOrigin())
            .withTransformOriginOn('.mat-time-select-content')
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withLockedPosition()
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
    }
    /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    _getValidDateOrNull(obj) {
        return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
    }
    /**
     * Passes the current theme color along to the time select overlay.
     * @private
     * @return {?}
     */
    _setColor() {
        if (this._popupComponentRef) {
            this._popupComponentRef.instance.color = this.color;
        }
    }
}
MatTimeSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-select',
                template: '',
                exportAs: 'matTimeSelect',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
MatTimeSelectComponent.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: NgZone },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_TIME_SELECT_SCROLL_STRATEGY,] }] },
    { type: TimeAdapter, decorators: [{ type: Optional }] },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
MatTimeSelectComponent.propDecorators = {
    openStream: [{ type: Output, args: ['open',] }],
    closeStream: [{ type: Output, args: ['close',] }],
    startAt: [{ type: Input }],
    color: [{ type: Input }],
    disabled: [{ type: Input }],
    selected: [{ type: Input }],
    opened: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * An event used for time select input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use MatTimeSelectInputEvent instead.
 * @template D
 */
class MatTimeSelectInputEvent {
    /**
     * @param {?} target
     * @param {?} targetElement
     */
    constructor(target, targetElement) {
        this.target = target;
        this.targetElement = targetElement;
        this.value = this.target.value;
    }
}
/**
 * Directive used to connect an input to a MatTimeSelectComponent.
 * @template D
 */
class MatTimeSelectInputDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _timeAdapter
     * @param {?} _timeFormats
     * @param {?} _formField
     */
    constructor(_elementRef, _timeAdapter, _timeFormats, _formField) {
        this._elementRef = _elementRef;
        this._timeAdapter = _timeAdapter;
        this._timeFormats = _timeFormats;
        this._formField = _formField;
        this._timeSelectSubscription = Subscription.EMPTY;
        this._localeSubscription = Subscription.EMPTY;
        this._valueChange = new Subject();
        this._disabledChange = new Subject();
        /**
         * Emits when a `change` event is fired on this `<input>`.
         */
        this.timeChange = new EventEmitter();
        /**
         * Emits when an `input` event is fired on this `<input>`.
         */
        this.timeInput = new EventEmitter();
        /**
         * Emits when the value changes (either due to user input or programmatic change).
         */
        this.valueChange = this._valueChange.asObservable();
        /**
         * Emits when the disabled state has changed.
         */
        this.disabledChange = this._disabledChange.asObservable();
        this._onChange = () => { };
        this._onTouched = () => { };
        this._onValidatorChange = () => { };
        this._parseValidator = () => {
            return this._lastValueValid ? null : { 'matTimeSelectParse': { 'text': this._elementRef.nativeElement.value } };
        };
        this._minValidator = (control) => {
            /** @type {?} */
            const value = this._getValidDateOrNull(this._timeAdapter.deserialize(control.value));
            return !this.min || !value || this._timeAdapter.compareTime(this.min, value) <= 0 ?
                null : { 'matTimeSelectMin': { 'min': this.min, 'actual': value } };
        };
        this._maxValidator = (control) => {
            /** @type {?} */
            const value = this._getValidDateOrNull(this._timeAdapter.deserialize(control.value));
            return !this.max || !value || this._timeAdapter.compareTime(this.max, value) >= 0 ?
                null : { 'matTimeSelectMax': { 'max': this.max, 'actual': value } };
        };
        this._validator = Validators.compose([
            this._parseValidator,
            this._minValidator,
            this._maxValidator
        ]);
        this._localeSubscription = this._timeAdapter.localeChanges.subscribe(() => this.value = this.value);
    }
    /**
     * The time select that this input is associated with.
     * @param {?} value
     * @return {?}
     */
    set matTimeSelect(value) {
        if (!value) {
            return;
        }
        this._timeSelect = value;
        this._timeSelect.registerInput(this);
        this._timeSelectSubscription.unsubscribe();
        this._timeSelectSubscription = this._timeSelect.selectedChange.subscribe((selected) => {
            this.value = selected;
            this._onChange(selected);
            this._onTouched();
            this.timeInput.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
            this.timeChange.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
        });
    }
    /**
     * The value of the input.
     * @return {?}
     */
    get value() { return this._value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        value = this._timeAdapter.deserialize(value);
        this._lastValueValid = !value || this._timeAdapter.isValid(value);
        value = this._getValidDateOrNull(value);
        /** @type {?} */
        const oldValue = this._value;
        this._value = value;
        this._formatValue(value);
        if (!this._timeAdapter.sameTime(oldValue, value)) {
            this._valueChange.next(value);
        }
    }
    /**
     * The minimum valid date time.
     * @return {?}
     */
    get min() { return this._min; }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
        this._onValidatorChange();
    }
    /**
     * The maximum valid date time.
     * @return {?}
     */
    get max() { return this._max; }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = this._getValidDateOrNull(this._timeAdapter.deserialize(value));
        this._onValidatorChange();
    }
    /**
     * Whether the time select input is disabled.
     * @return {?}
     */
    get disabled() { return this._disabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        /** @type {?} */
        const disabled = coerceBooleanProperty(value);
        /** @type {?} */
        const element = this._elementRef.nativeElement;
        if (this.disabled !== disabled) {
            this._disabled = disabled;
            this._disabledChange.next(disabled);
        }
        if (disabled && element.blur) {
            element.blur();
        }
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get _ariaHasPopup() { return true; }
    /**
     * \@docs-private
     * @return {?}
     */
    get _ariaOwns() { return (this._timeSelect && this._timeSelect.opened && !!this._timeSelect.id) || null; }
    /**
     * \@docs-private
     * @return {?}
     */
    get _minTime() { return this.min ? this._timeAdapter.toIso8601(this.min) : null; }
    /**
     * \@docs-private
     * @return {?}
     */
    get _maxTime() { return this.max ? this._timeAdapter.toIso8601(this.max) : null; }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._timeSelectSubscription.unsubscribe();
        this._localeSubscription.unsubscribe();
        this._valueChange.complete();
        this._disabledChange.complete();
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    // Implemented as part of ControlValueAccessor.
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * \@docs-private
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        return this._validator ? this._validator(control) : null;
    }
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this._onValidatorChange = fn;
    }
    /**
     * Handle keydown event.
     * @param {?} event The event object.
     * @return {?}
     */
    onKeydown(event) {
        /** @type {?} */
        const isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;
        if (this._timeSelect && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
            this._timeSelect.open();
            event.preventDefault();
        }
    }
    /**
     * Handle input event.
     * @param {?} value The current value of the input.
     * @return {?}
     */
    onInput(value) {
        /** @type {?} */
        let time = this._timeAdapter.parse(value, this._timeFormats.parse.timeInput);
        this._lastValueValid = !time || this._timeAdapter.isValid(time);
        time = this._getValidDateOrNull(time);
        if (!this._timeAdapter.sameTime(this._value, time)) {
            this._value = time;
            this._onChange(time);
            this._valueChange.next(time);
            this.timeInput.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
        }
    }
    /**
     * Handle change event.
     * @return {?}
     */
    onChange() {
        this.timeChange.emit(new MatTimeSelectInputEvent(this, this._elementRef.nativeElement));
    }
    /**
     * Handle blur event.
     * @return {?}
     */
    onBlur() {
        if (this.value) {
            this._formatValue(this.value);
        }
        this._onTouched();
    }
    /**
     * Returns the palette used by the input's form field, if any.
     * @return {?}
     */
    getThemePalette() {
        return this._formField ? this._formField.color : undefined;
    }
    /**
     * Gets the element that the time select popup should be connected to.
     * @return {?} The element to connect the popup to.
     */
    getConnectedOverlayOrigin() {
        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
    }
    /**
     * Formats a value and sets it on the input element.
     * @private
     * @param {?} value
     * @return {?}
     */
    _formatValue(value) {
        this._elementRef.nativeElement.value = value ? this._timeAdapter.format(value, this._timeFormats.display.timeInput) : '';
    }
    /**
     * @private
     * @param {?} obj The object to check.
     * @return {?} The given object if it is both a date instance and valid, otherwise null.
     */
    _getValidDateOrNull(obj) {
        return this._timeAdapter.isDateInstance(obj) && this._timeAdapter.isValid(obj) ? obj : null;
    }
}
MatTimeSelectInputDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[matTimeSelect]',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => MatTimeSelectInputDirective), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => MatTimeSelectInputDirective), multi: true },
                    { provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: MatTimeSelectInputDirective }
                ],
                exportAs: 'matTimeSelectInput'
            },] }
];
/** @nocollapse */
MatTimeSelectInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: TimeAdapter, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TIME_FORMATS,] }] },
    { type: MatFormField, decorators: [{ type: Optional }] }
];
MatTimeSelectInputDirective.propDecorators = {
    timeChange: [{ type: Output }],
    timeInput: [{ type: Output }],
    matTimeSelect: [{ type: Input }],
    value: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    disabled: [{ type: HostBinding }, { type: Input }],
    _ariaHasPopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    _ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
    _minTime: [{ type: HostBinding, args: ['attr.min',] }],
    _maxTime: [{ type: HostBinding, args: ['attr.max',] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }],
    onChange: [{ type: HostListener, args: ['change',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Can be used to override the icon of a `matTimeSelectToggle`.
 */
class MatTimeSelectToggleIconDirective {
}
MatTimeSelectToggleIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[matTimeSelectToggleIcon]'
            },] }
];
/**
 * @template D
 */
class MatTimeSelectToggleComponent {
    /**
     * @param {?} _intl
     * @param {?} _changeDetectorRef
     * @param {?} defaultTabIndex
     */
    constructor(_intl, _changeDetectorRef, defaultTabIndex) {
        this._intl = _intl;
        this._changeDetectorRef = _changeDetectorRef;
        this._stateChanges = Subscription.EMPTY;
        /** @type {?} */
        const parsedTabIndex = parseInt(defaultTabIndex, 10);
        this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
    }
    /**
     * Whether the toggle button is disabled.
     * @return {?}
     */
    get disabled() {
        return this._disabled === undefined ? this.timeSelect.disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    /**
     * Whether ripples on the toggle should be disabled.
     * @return {?}
     */
    get disableRipple() {
        return this._disableRipple;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableRipple(value) {
        this._disableRipple = coerceBooleanProperty(value);
    }
    /**
     * \@docs-private
     * @return {?}
     */
    get class() { return 'mat-time-select-toggle'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get tabindex() { return '-1'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get active() { return this.timeSelect && this.timeSelect.opened; }
    /**
     * \@docs-private
     * @return {?}
     */
    get accent() { return this.timeSelect && this.timeSelect.color === 'accent'; }
    /**
     * \@docs-private
     * @return {?}
     */
    get warn() { return this.timeSelect && this.timeSelect.color === 'warn'; }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._watchStateChanges();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.timeSelect) {
            this._watchStateChanges();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._stateChanges.unsubscribe();
    }
    /**
     * Handle focus event.
     * @return {?}
     */
    onFocus() {
        this.button.focus();
    }
    /**
     * Open the time select.
     * @param {?} event The triggered event to open the time select.
     * @return {?}
     */
    open(event) {
        if (this.timeSelect && !this.disabled) {
            this.timeSelect.open();
            event.stopPropagation();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _watchStateChanges() {
        /** @type {?} */
        const timeSelectDisabled = this.timeSelect ? this.timeSelect.disabledChange : of();
        /** @type {?} */
        const inputDisabled = this.timeSelect && this.timeSelect._timeSelectInput ?
            this.timeSelect._timeSelectInput.disabledChange : of();
        /** @type {?} */
        const timeSelectToggled = this.timeSelect ?
            merge(this.timeSelect.openStream, this.timeSelect.closeStream) :
            of();
        this._stateChanges.unsubscribe();
        this._stateChanges = merge(this._intl.changes, timeSelectDisabled, inputDisabled, timeSelectToggled).subscribe(() => this._changeDetectorRef.markForCheck());
    }
}
MatTimeSelectToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-time-select-toggle',
                template: "<button\r\n  #button\r\n  mat-icon-button\r\n  type=\"button\"\r\n  aria-haspopup=\"true\"\r\n  [attr.aria-label]=\"_intl.openTimeSelectLabel\"\r\n  [attr.tabindex]=\"disabled ? -1 : tabIndex\"\r\n  [disabled]=\"disabled\"\r\n  [disableRipple]=\"disableRipple\"\r\n  (click)=\"open($event)\">\r\n\r\n  <svg\r\n    *ngIf=\"!customIcon\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    class=\"mat-time-select-toggle-default-icon\"\r\n    viewBox=\"0 0 24 24\"\r\n    width=\"24px\"\r\n    height=\"24px\"\r\n    fill=\"currentColor\"\r\n    focusable=\"false\">\r\n    <path d=\"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z\"/>\r\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\r\n    <path d=\"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z\"/>\r\n  </svg>\r\n\r\n  <ng-content select=\"[matTimeSelectToggleIcon]\"></ng-content>\r\n</button>\r\n",
                exportAs: 'matTimeSelectToggle',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-time-select-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-time-select-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-time-select-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-time-select-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-time-select-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-time-select-toggle-default-icon{margin:auto}"]
            }] }
];
/** @nocollapse */
MatTimeSelectToggleComponent.ctorParameters = () => [
    { type: MatTimeSelectIntl },
    { type: ChangeDetectorRef },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] }
];
MatTimeSelectToggleComponent.propDecorators = {
    timeSelect: [{ type: Input, args: ['for',] }],
    tabIndex: [{ type: Input }],
    customIcon: [{ type: ContentChild, args: [MatTimeSelectToggleIconDirective,] }],
    button: [{ type: ViewChild, args: ['button',] }],
    disabled: [{ type: Input }],
    disableRipple: [{ type: Input }],
    class: [{ type: HostBinding, args: ['class',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    active: [{ type: HostBinding, args: ['class.mat-time-select-toggle-active',] }],
    accent: [{ type: HostBinding, args: ['class.mat-accent',] }],
    warn: [{ type: HostBinding, args: ['class.mat-warn',] }],
    onFocus: [{ type: HostListener, args: ['focus',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatTimeSelectModule {
}
MatTimeSelectModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    A11yModule,
                    PortalModule,
                    MatButtonModule,
                    MatButtonToggleModule,
                    MatIconModule,
                    MatRippleModule
                ],
                declarations: [
                    MatTimeSelectComponent,
                    MatTimeSelectContentComponent,
                    MatTimeSelectInputDirective,
                    MatTimeSelectToggleComponent,
                    MatTimeSelectToggleIconDirective,
                    MatTimeUnitOptionComponent,
                    MatTimeUnitSelectComponent
                ],
                exports: [
                    MatTimeSelectComponent,
                    MatTimeSelectContentComponent,
                    MatTimeSelectInputDirective,
                    MatTimeSelectToggleComponent,
                    MatTimeSelectToggleIconDirective,
                    MatTimeUnitOptionComponent,
                    MatTimeUnitSelectComponent
                ],
                entryComponents: [
                    MatTimeSelectContentComponent
                ],
                providers: [
                    MatTimeSelectIntl,
                    MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const moment = _moment;
/**
 * Adapts the native JS Date for use with cdk-based components that work with times.
 */
class NativeTimeAdapter extends TimeAdapter {
    /**
     * @param {?} locale
     * @param {?} _dateAdapter
     */
    constructor(locale, _dateAdapter) {
        super();
        this._dateAdapter = _dateAdapter;
        this.setLocale(locale);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYear(date) {
        return this._dateAdapter.getYear(date);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMonth(date) {
        return this._dateAdapter.getMonth(date);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDate(date) {
        return this._dateAdapter.getDate(date);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayOfWeek(date) {
        return this._dateAdapter.getDayOfWeek(date);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getHour(date) {
        return date.getHours();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMinute(date) {
        return date.getMinutes();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getSecond(date) {
        return date.getSeconds();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYearName(date) {
        return this._dateAdapter.getYearName(date);
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getMonthNames(style) {
        return this._dateAdapter.getMonthNames(style);
    }
    /**
     * @return {?}
     */
    getDateNames() {
        return this._dateAdapter.getDateNames();
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getDayOfWeekNames(style) {
        return this._dateAdapter.getDayOfWeekNames(style);
    }
    /**
     * @return {?}
     */
    getFirstDayOfWeek() {
        return this._dateAdapter.getFirstDayOfWeek();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getNumDaysInMonth(date) {
        return this._dateAdapter.getNumDaysInMonth(date);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        return new Date(date.getTime());
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    createDate(year, month, date) {
        return this._dateAdapter.createDate(year, month, date);
    }
    /**
     * @param {?=} hour
     * @param {?=} minute
     * @param {?=} second
     * @return {?}
     */
    createTime(hour = 0, minute = 0, second = 0) {
        if (hour < 0 || hour > 23) {
            throw new Error(`Invalid hour ${hour}. Hour has to be between 0 and 23.`);
        }
        if (minute < 0 || minute > 59) {
            throw new Error(`Invalid minute ${minute}. Minute has to be between 0 and 59.`);
        }
        if (second < 0 || second > 59) {
            throw new Error(`Invalid second ${second}. Second has to be between 0 and 59.`);
        }
        /** @type {?} */
        const date = new Date();
        date.setHours(hour, minute, second);
        return date;
    }
    /**
     * @return {?}
     */
    today() {
        return this.now();
    }
    /**
     * @return {?}
     */
    now() {
        return new Date(Date.now());
    }
    /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    parse(value, parseFormat) {
        return this._dateAdapter.parse(value, parseFormat);
    }
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    format(date, displayFormat) {
        return this._dateAdapter.format(date, displayFormat);
    }
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    addCalendarYears(date, years) {
        return this._dateAdapter.addCalendarYears(date, years);
    }
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    addCalendarMonths(date, months) {
        return this._dateAdapter.addCalendarMonths(date, months);
    }
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    addCalendarDays(date, days) {
        return this._dateAdapter.addCalendarDays(date, days);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toIso8601(date) {
        /** @type {?} */
        const dateString = this._dateAdapter.toIso8601(date);
        /** @type {?} */
        const timeString = [
            this._2digit(date.getUTCHours()),
            this._2digit(date.getUTCMinutes()),
            this._2digit(date.getUTCSeconds())
        ].join(':');
        return `${dateString}T${timeString}Z`;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toMoment(date) {
        return moment(date).locale(this.locale);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    deserialize(value) {
        return this._dateAdapter.deserialize(value);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isDateInstance(obj) {
        return this._dateAdapter.isDateInstance(obj);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isValid(date) {
        return this._dateAdapter.isValid(date);
    }
    /**
     * @return {?}
     */
    invalid() {
        return this._dateAdapter.invalid();
    }
    /**
     * Pads a number to make it two digits.
     * @private
     * @param {?} n The number to pad.
     * @return {?} The padded number.
     */
    _2digit(n) {
        return ('00' + n).slice(-2);
    }
}
NativeTimeAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NativeTimeAdapter.ctorParameters = () => [
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_LOCALE,] }] },
    { type: DateAdapter, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAT_NATIVE_TIME_FORMATS = {
    parse: {
        timeInput: null
    },
    display: {
        timeInput: { hour: 'numeric', minute: 'numeric' },
        timeA11yLabel: { hour: 'numeric', minute: '2-digit' }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = MAT_NATIVE_TIME_FORMATS;
class MatNativeTimeModule {
}
MatNativeTimeModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: TimeAdapter, useClass: NativeTimeAdapter, deps: [MAT_DATE_LOCALE, DateAdapter] },
                    { provide: MAT_TIME_FORMATS, useValue: ɵ0 }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const moment$1 = _moment;
/**
 * Adapts Moment.js Dates for use with Angular Material.
 */
class MomentTimeAdapter extends TimeAdapter {
    /**
     * @param {?} locale
     * @param {?} _dateAdapter
     */
    constructor(locale, _dateAdapter) {
        super();
        this._dateAdapter = _dateAdapter;
        this.setLocale(locale || moment$1.locale());
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYear(date) {
        return this.clone(date).year();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMonth(date) {
        return this.clone(date).month();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDate(date) {
        return this.clone(date).date();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayOfWeek(date) {
        return this.clone(date).day();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getHour(date) {
        return this.clone(date).hour();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMinute(date) {
        return this.clone(date).minute();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getSecond(date) {
        return this.clone(date).second();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        return date.clone().locale(this.locale);
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    createDate(year, month, date) {
        return this.clone(this._dateAdapter.createDate(year, month, date));
    }
    /**
     * @param {?=} hour
     * @param {?=} minute
     * @param {?=} second
     * @return {?}
     */
    createTime(hour = 0, minute = 0, second = 0) {
        if (hour < 0 || hour > 23) {
            throw new Error(`Invalid hour ${hour}. Hour has to be between 0 and 23.`);
        }
        if (minute < 0 || minute > 59) {
            throw new Error(`Invalid minute ${minute}. Minute has to be between 0 and 59.`);
        }
        if (second < 0 || second > 59) {
            throw new Error(`Invalid second ${second}. Second has to be between 0 and 59.`);
        }
        return moment$1({ hour, minute, second }).locale(this.locale);
    }
    /**
     * @return {?}
     */
    today() {
        return this.now();
    }
    /**
     * @return {?}
     */
    now() {
        return moment$1().locale(this.locale);
    }
    /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    parse(value, parseFormat) {
        if (value && typeof value === 'string') {
            return moment$1(value, parseFormat, this.locale);
        }
        return value ? moment$1(value).locale(this.locale) : null;
    }
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    format(date, displayFormat) {
        date = this.clone(date);
        if (!this.isValid(date)) {
            throw new Error('MomentTimeAdapter: Cannot format invalid date.');
        }
        return date.format(displayFormat);
    }
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    addCalendarYears(date, years) {
        return this.clone(date).add({ years });
    }
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    addCalendarMonths(date, months) {
        return this.clone(date).add({ months });
    }
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    addCalendarDays(date, days) {
        return this.clone(date).add({ days });
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toIso8601(date) {
        return this.clone(date).format();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toMoment(date) {
        return this.clone(date);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    deserialize(value) {
        /** @type {?} */
        let date;
        if (value instanceof Date) {
            date = moment$1(value);
        }
        if (typeof value === 'string') {
            if (!value) {
                return null;
            }
            date = moment$1(value, moment$1.ISO_8601);
        }
        if (date && this.isValid(date)) {
            return date;
        }
        return super.deserialize(value);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isDateInstance(obj) {
        return moment$1.isMoment(obj);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isValid(date) {
        return this.clone(date).isValid();
    }
    /**
     * @return {?}
     */
    invalid() {
        return moment$1.invalid();
    }
    /**
     * @return {?}
     */
    getDateNames() {
        return [];
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getDayOfWeekNames(style) {
        return [];
    }
    /**
     * @return {?}
     */
    getFirstDayOfWeek() {
        return 0;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getMonthNames(style) {
        return [];
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getNumDaysInMonth(date) {
        return 0;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYearName(date) {
        return '';
    }
}
MomentTimeAdapter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
MomentTimeAdapter.ctorParameters = () => [
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_LOCALE,] }] },
    { type: DateAdapter, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAT_MOMENT_TIME_FORMATS = {
    parse: {
        timeInput: 'LT'
    },
    display: {
        timeInput: 'LT',
        timeA11yLabel: 'LT'
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0$1 = MAT_MOMENT_TIME_FORMATS;
class MatMomentTimeModule {
}
MatMomentTimeModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: TimeAdapter, useClass: MomentTimeAdapter, deps: [MAT_DATE_LOCALE, DateAdapter] },
                    { provide: MAT_TIME_FORMATS, useValue: ɵ0$1 }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TimeAdapter, MAT_TIME_FORMATS, MatTimeSelectIntl, MatTimeUnitOptionBase, _MatTimeUnitOptionMixinBase, MatTimeUnitOptionComponent, MatTimeUnitSelectComponent, MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY, MAT_TIME_SELECT_DATA, MAT_TIME_SELECT_SCROLL_STRATEGY, MAT_TIME_SELECT_SCROLL_STRATEGY_FACTORY_PROVIDER, MatTimeSelectContentBase, _MatTimeSelectContentMixinBase, MatTimeSelectContentComponent, MatTimeSelectComponent, MatTimeSelectInputEvent, MatTimeSelectInputDirective, MatTimeSelectToggleIconDirective, MatTimeSelectToggleComponent, MatTimeSelectModule, NativeTimeAdapter, MAT_NATIVE_TIME_FORMATS, MatNativeTimeModule, MomentTimeAdapter, MAT_MOMENT_TIME_FORMATS, MatMomentTimeModule };

//# sourceMappingURL=ngx-material-time-select.js.map